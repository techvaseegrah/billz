
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organisation
 * 
 */
export type Organisation = $Result.DefaultSelection<Prisma.$OrganisationPayload>
/**
 * Model CustomerSubmission
 * 
 */
export type CustomerSubmission = $Result.DefaultSelection<Prisma.$CustomerSubmissionPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Seller
 * 
 */
export type Seller = $Result.DefaultSelection<Prisma.$SellerPayload>
/**
 * Model TransactionRecord
 * 
 */
export type TransactionRecord = $Result.DefaultSelection<Prisma.$TransactionRecordPayload>
/**
 * Model TransactionItem
 * 
 */
export type TransactionItem = $Result.DefaultSelection<Prisma.$TransactionItemPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model SubscriptionDetails
 * 
 */
export type SubscriptionDetails = $Result.DefaultSelection<Prisma.$SubscriptionDetailsPayload>
/**
 * Model ShippingMethod
 * 
 */
export type ShippingMethod = $Result.DefaultSelection<Prisma.$ShippingMethodPayload>
/**
 * Model TransactionShipping
 * 
 */
export type TransactionShipping = $Result.DefaultSelection<Prisma.$TransactionShippingPayload>
/**
 * Model Mandate
 * 
 */
export type Mandate = $Result.DefaultSelection<Prisma.$MandatePayload>
/**
 * Model ActiveMandate
 * 
 */
export type ActiveMandate = $Result.DefaultSelection<Prisma.$ActiveMandatePayload>
/**
 * Model MandateNotification
 * 
 */
export type MandateNotification = $Result.DefaultSelection<Prisma.$MandateNotificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const ShippingMethodType: {
  FREE_SHIPPING: 'FREE_SHIPPING',
  COURIER_PARTNER: 'COURIER_PARTNER'
};

export type ShippingMethodType = (typeof ShippingMethodType)[keyof typeof ShippingMethodType]

}

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type ShippingMethodType = $Enums.ShippingMethodType

export const ShippingMethodType: typeof $Enums.ShippingMethodType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organisations
 * const organisations = await prisma.organisation.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organisations
   * const organisations = await prisma.organisation.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.organisation`: Exposes CRUD operations for the **Organisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organisations
    * const organisations = await prisma.organisation.findMany()
    * ```
    */
  get organisation(): Prisma.OrganisationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerSubmission`: Exposes CRUD operations for the **CustomerSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerSubmissions
    * const customerSubmissions = await prisma.customerSubmission.findMany()
    * ```
    */
  get customerSubmission(): Prisma.CustomerSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seller`: Exposes CRUD operations for the **Seller** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sellers
    * const sellers = await prisma.seller.findMany()
    * ```
    */
  get seller(): Prisma.SellerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionRecord`: Exposes CRUD operations for the **TransactionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionRecords
    * const transactionRecords = await prisma.transactionRecord.findMany()
    * ```
    */
  get transactionRecord(): Prisma.TransactionRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionItem`: Exposes CRUD operations for the **TransactionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionItems
    * const transactionItems = await prisma.transactionItem.findMany()
    * ```
    */
  get transactionItem(): Prisma.TransactionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionDetails`: Exposes CRUD operations for the **SubscriptionDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionDetails
    * const subscriptionDetails = await prisma.subscriptionDetails.findMany()
    * ```
    */
  get subscriptionDetails(): Prisma.SubscriptionDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shippingMethod`: Exposes CRUD operations for the **ShippingMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShippingMethods
    * const shippingMethods = await prisma.shippingMethod.findMany()
    * ```
    */
  get shippingMethod(): Prisma.ShippingMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionShipping`: Exposes CRUD operations for the **TransactionShipping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionShippings
    * const transactionShippings = await prisma.transactionShipping.findMany()
    * ```
    */
  get transactionShipping(): Prisma.TransactionShippingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mandate`: Exposes CRUD operations for the **Mandate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mandates
    * const mandates = await prisma.mandate.findMany()
    * ```
    */
  get mandate(): Prisma.MandateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activeMandate`: Exposes CRUD operations for the **ActiveMandate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActiveMandates
    * const activeMandates = await prisma.activeMandate.findMany()
    * ```
    */
  get activeMandate(): Prisma.ActiveMandateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mandateNotification`: Exposes CRUD operations for the **MandateNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MandateNotifications
    * const mandateNotifications = await prisma.mandateNotification.findMany()
    * ```
    */
  get mandateNotification(): Prisma.MandateNotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organisation: 'Organisation',
    CustomerSubmission: 'CustomerSubmission',
    ProductCategory: 'ProductCategory',
    Product: 'Product',
    Seller: 'Seller',
    TransactionRecord: 'TransactionRecord',
    TransactionItem: 'TransactionItem',
    Customer: 'Customer',
    Inventory: 'Inventory',
    SubscriptionDetails: 'SubscriptionDetails',
    ShippingMethod: 'ShippingMethod',
    TransactionShipping: 'TransactionShipping',
    Mandate: 'Mandate',
    ActiveMandate: 'ActiveMandate',
    MandateNotification: 'MandateNotification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "organisation" | "customerSubmission" | "productCategory" | "product" | "seller" | "transactionRecord" | "transactionItem" | "customer" | "inventory" | "subscriptionDetails" | "shippingMethod" | "transactionShipping" | "mandate" | "activeMandate" | "mandateNotification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organisation: {
        payload: Prisma.$OrganisationPayload<ExtArgs>
        fields: Prisma.OrganisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findFirst: {
            args: Prisma.OrganisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findMany: {
            args: Prisma.OrganisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>[]
          }
          create: {
            args: Prisma.OrganisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          createMany: {
            args: Prisma.OrganisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          update: {
            args: Prisma.OrganisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          deleteMany: {
            args: Prisma.OrganisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          aggregate: {
            args: Prisma.OrganisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisation>
          }
          groupBy: {
            args: Prisma.OrganisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationCountAggregateOutputType> | number
          }
        }
      }
      CustomerSubmission: {
        payload: Prisma.$CustomerSubmissionPayload<ExtArgs>
        fields: Prisma.CustomerSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload>
          }
          findFirst: {
            args: Prisma.CustomerSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload>
          }
          findMany: {
            args: Prisma.CustomerSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload>[]
          }
          create: {
            args: Prisma.CustomerSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload>
          }
          createMany: {
            args: Prisma.CustomerSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload>
          }
          update: {
            args: Prisma.CustomerSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.CustomerSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSubmissionPayload>
          }
          aggregate: {
            args: Prisma.CustomerSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerSubmission>
          }
          groupBy: {
            args: Prisma.CustomerSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerSubmissionCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Seller: {
        payload: Prisma.$SellerPayload<ExtArgs>
        fields: Prisma.SellerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          findFirst: {
            args: Prisma.SellerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          findMany: {
            args: Prisma.SellerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>[]
          }
          create: {
            args: Prisma.SellerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          createMany: {
            args: Prisma.SellerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          update: {
            args: Prisma.SellerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          deleteMany: {
            args: Prisma.SellerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          aggregate: {
            args: Prisma.SellerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeller>
          }
          groupBy: {
            args: Prisma.SellerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellerCountArgs<ExtArgs>
            result: $Utils.Optional<SellerCountAggregateOutputType> | number
          }
        }
      }
      TransactionRecord: {
        payload: Prisma.$TransactionRecordPayload<ExtArgs>
        fields: Prisma.TransactionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload>
          }
          findFirst: {
            args: Prisma.TransactionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload>
          }
          findMany: {
            args: Prisma.TransactionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload>[]
          }
          create: {
            args: Prisma.TransactionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload>
          }
          createMany: {
            args: Prisma.TransactionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload>
          }
          update: {
            args: Prisma.TransactionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload>
          }
          deleteMany: {
            args: Prisma.TransactionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionRecordPayload>
          }
          aggregate: {
            args: Prisma.TransactionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionRecord>
          }
          groupBy: {
            args: Prisma.TransactionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionRecordCountAggregateOutputType> | number
          }
        }
      }
      TransactionItem: {
        payload: Prisma.$TransactionItemPayload<ExtArgs>
        fields: Prisma.TransactionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          findFirst: {
            args: Prisma.TransactionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          findMany: {
            args: Prisma.TransactionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>[]
          }
          create: {
            args: Prisma.TransactionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          createMany: {
            args: Prisma.TransactionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          update: {
            args: Prisma.TransactionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          deleteMany: {
            args: Prisma.TransactionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionItemPayload>
          }
          aggregate: {
            args: Prisma.TransactionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionItem>
          }
          groupBy: {
            args: Prisma.TransactionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionItemCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionDetails: {
        payload: Prisma.$SubscriptionDetailsPayload<ExtArgs>
        fields: Prisma.SubscriptionDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload>
          }
          findMany: {
            args: Prisma.SubscriptionDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload>[]
          }
          create: {
            args: Prisma.SubscriptionDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload>
          }
          createMany: {
            args: Prisma.SubscriptionDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload>
          }
          update: {
            args: Prisma.SubscriptionDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionDetailsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionDetails>
          }
          groupBy: {
            args: Prisma.SubscriptionDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionDetailsCountAggregateOutputType> | number
          }
        }
      }
      ShippingMethod: {
        payload: Prisma.$ShippingMethodPayload<ExtArgs>
        fields: Prisma.ShippingMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShippingMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShippingMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          findFirst: {
            args: Prisma.ShippingMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShippingMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          findMany: {
            args: Prisma.ShippingMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>[]
          }
          create: {
            args: Prisma.ShippingMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          createMany: {
            args: Prisma.ShippingMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShippingMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          update: {
            args: Prisma.ShippingMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          deleteMany: {
            args: Prisma.ShippingMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShippingMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShippingMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShippingMethodPayload>
          }
          aggregate: {
            args: Prisma.ShippingMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShippingMethod>
          }
          groupBy: {
            args: Prisma.ShippingMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShippingMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShippingMethodCountArgs<ExtArgs>
            result: $Utils.Optional<ShippingMethodCountAggregateOutputType> | number
          }
        }
      }
      TransactionShipping: {
        payload: Prisma.$TransactionShippingPayload<ExtArgs>
        fields: Prisma.TransactionShippingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionShippingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionShippingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload>
          }
          findFirst: {
            args: Prisma.TransactionShippingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionShippingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload>
          }
          findMany: {
            args: Prisma.TransactionShippingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload>[]
          }
          create: {
            args: Prisma.TransactionShippingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload>
          }
          createMany: {
            args: Prisma.TransactionShippingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionShippingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload>
          }
          update: {
            args: Prisma.TransactionShippingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload>
          }
          deleteMany: {
            args: Prisma.TransactionShippingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionShippingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionShippingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionShippingPayload>
          }
          aggregate: {
            args: Prisma.TransactionShippingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionShipping>
          }
          groupBy: {
            args: Prisma.TransactionShippingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionShippingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionShippingCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionShippingCountAggregateOutputType> | number
          }
        }
      }
      Mandate: {
        payload: Prisma.$MandatePayload<ExtArgs>
        fields: Prisma.MandateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MandateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MandateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload>
          }
          findFirst: {
            args: Prisma.MandateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MandateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload>
          }
          findMany: {
            args: Prisma.MandateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload>[]
          }
          create: {
            args: Prisma.MandateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload>
          }
          createMany: {
            args: Prisma.MandateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MandateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload>
          }
          update: {
            args: Prisma.MandateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload>
          }
          deleteMany: {
            args: Prisma.MandateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MandateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MandateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandatePayload>
          }
          aggregate: {
            args: Prisma.MandateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMandate>
          }
          groupBy: {
            args: Prisma.MandateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MandateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MandateCountArgs<ExtArgs>
            result: $Utils.Optional<MandateCountAggregateOutputType> | number
          }
        }
      }
      ActiveMandate: {
        payload: Prisma.$ActiveMandatePayload<ExtArgs>
        fields: Prisma.ActiveMandateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActiveMandateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActiveMandateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload>
          }
          findFirst: {
            args: Prisma.ActiveMandateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActiveMandateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload>
          }
          findMany: {
            args: Prisma.ActiveMandateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload>[]
          }
          create: {
            args: Prisma.ActiveMandateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload>
          }
          createMany: {
            args: Prisma.ActiveMandateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActiveMandateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload>
          }
          update: {
            args: Prisma.ActiveMandateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload>
          }
          deleteMany: {
            args: Prisma.ActiveMandateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActiveMandateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActiveMandateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveMandatePayload>
          }
          aggregate: {
            args: Prisma.ActiveMandateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActiveMandate>
          }
          groupBy: {
            args: Prisma.ActiveMandateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActiveMandateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActiveMandateCountArgs<ExtArgs>
            result: $Utils.Optional<ActiveMandateCountAggregateOutputType> | number
          }
        }
      }
      MandateNotification: {
        payload: Prisma.$MandateNotificationPayload<ExtArgs>
        fields: Prisma.MandateNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MandateNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MandateNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload>
          }
          findFirst: {
            args: Prisma.MandateNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MandateNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload>
          }
          findMany: {
            args: Prisma.MandateNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload>[]
          }
          create: {
            args: Prisma.MandateNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload>
          }
          createMany: {
            args: Prisma.MandateNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MandateNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload>
          }
          update: {
            args: Prisma.MandateNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload>
          }
          deleteMany: {
            args: Prisma.MandateNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MandateNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MandateNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MandateNotificationPayload>
          }
          aggregate: {
            args: Prisma.MandateNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMandateNotification>
          }
          groupBy: {
            args: Prisma.MandateNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MandateNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MandateNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<MandateNotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    organisation?: OrganisationOmit
    customerSubmission?: CustomerSubmissionOmit
    productCategory?: ProductCategoryOmit
    product?: ProductOmit
    seller?: SellerOmit
    transactionRecord?: TransactionRecordOmit
    transactionItem?: TransactionItemOmit
    customer?: CustomerOmit
    inventory?: InventoryOmit
    subscriptionDetails?: SubscriptionDetailsOmit
    shippingMethod?: ShippingMethodOmit
    transactionShipping?: TransactionShippingOmit
    mandate?: MandateOmit
    activeMandate?: ActiveMandateOmit
    mandateNotification?: MandateNotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganisationCountOutputType
   */

  export type OrganisationCountOutputType = {
    productCategories: number
    products: number
    sellers: number
    transactions: number
    customers: number
    inventory: number
    CustomerSubmission: number
    ShippingMethod: number
    Mandate: number
    MandateNotification: number
  }

  export type OrganisationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCategories?: boolean | OrganisationCountOutputTypeCountProductCategoriesArgs
    products?: boolean | OrganisationCountOutputTypeCountProductsArgs
    sellers?: boolean | OrganisationCountOutputTypeCountSellersArgs
    transactions?: boolean | OrganisationCountOutputTypeCountTransactionsArgs
    customers?: boolean | OrganisationCountOutputTypeCountCustomersArgs
    inventory?: boolean | OrganisationCountOutputTypeCountInventoryArgs
    CustomerSubmission?: boolean | OrganisationCountOutputTypeCountCustomerSubmissionArgs
    ShippingMethod?: boolean | OrganisationCountOutputTypeCountShippingMethodArgs
    Mandate?: boolean | OrganisationCountOutputTypeCountMandateArgs
    MandateNotification?: boolean | OrganisationCountOutputTypeCountMandateNotificationArgs
  }

  // Custom InputTypes
  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationCountOutputType
     */
    select?: OrganisationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountSellersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionRecordWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountCustomerSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSubmissionWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountShippingMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingMethodWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountMandateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MandateWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountMandateNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MandateNotificationWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    products: number
    inventory: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
    inventory?: boolean | ProductCategoryCountOutputTypeCountInventoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    inventory: number
    transactionItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | ProductCountOutputTypeCountInventoryArgs
    transactionItems?: boolean | ProductCountOutputTypeCountTransactionItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransactionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
  }


  /**
   * Count Type TransactionRecordCountOutputType
   */

  export type TransactionRecordCountOutputType = {
    items: number
    TransactionShipping: number
  }

  export type TransactionRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransactionRecordCountOutputTypeCountItemsArgs
    TransactionShipping?: boolean | TransactionRecordCountOutputTypeCountTransactionShippingArgs
  }

  // Custom InputTypes
  /**
   * TransactionRecordCountOutputType without action
   */
  export type TransactionRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecordCountOutputType
     */
    select?: TransactionRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionRecordCountOutputType without action
   */
  export type TransactionRecordCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
  }

  /**
   * TransactionRecordCountOutputType without action
   */
  export type TransactionRecordCountOutputTypeCountTransactionShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionShippingWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    transactions: number
    CustomerSubmission: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
    CustomerSubmission?: boolean | CustomerCountOutputTypeCountCustomerSubmissionArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionRecordWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSubmissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organisation
   */

  export type AggregateOrganisation = {
    _count: OrganisationCountAggregateOutputType | null
    _avg: OrganisationAvgAggregateOutputType | null
    _sum: OrganisationSumAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  export type OrganisationAvgAggregateOutputType = {
    id: number | null
    smsCount: number | null
    smsCost: number | null
    monthlyUsage: number | null
  }

  export type OrganisationSumAggregateOutputType = {
    id: number | null
    smsCount: number | null
    smsCost: number | null
    monthlyUsage: number | null
  }

  export type OrganisationMinAggregateOutputType = {
    id: number | null
    password: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    email: string | null
    phone: string | null
    name: string | null
    companySize: string | null
    shopName: string | null
    flatNo: string | null
    street: string | null
    district: string | null
    city: string | null
    state: string | null
    smsCount: number | null
    smsCost: number | null
    country: string | null
    pincode: string | null
    mobileNumber: string | null
    landlineNumber: string | null
    websiteAddress: string | null
    gstNumber: string | null
    subscriptionType: string | null
    endDate: Date | null
    whatsappNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    razorpayAccessToken: string | null
    razorpayRefreshToken: string | null
    razorpayTokenExpiresAt: Date | null
    razorpayAccountId: string | null
    razorpayState: string | null
    razorpayStateExpiresAt: Date | null
    monthlyUsage: number | null
  }

  export type OrganisationMaxAggregateOutputType = {
    id: number | null
    password: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    email: string | null
    phone: string | null
    name: string | null
    companySize: string | null
    shopName: string | null
    flatNo: string | null
    street: string | null
    district: string | null
    city: string | null
    state: string | null
    smsCount: number | null
    smsCost: number | null
    country: string | null
    pincode: string | null
    mobileNumber: string | null
    landlineNumber: string | null
    websiteAddress: string | null
    gstNumber: string | null
    subscriptionType: string | null
    endDate: Date | null
    whatsappNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    razorpayAccessToken: string | null
    razorpayRefreshToken: string | null
    razorpayTokenExpiresAt: Date | null
    razorpayAccountId: string | null
    razorpayState: string | null
    razorpayStateExpiresAt: Date | null
    monthlyUsage: number | null
  }

  export type OrganisationCountAggregateOutputType = {
    id: number
    password: number
    resetToken: number
    resetTokenExpiry: number
    email: number
    phone: number
    name: number
    companySize: number
    shopName: number
    flatNo: number
    street: number
    district: number
    city: number
    state: number
    smsCount: number
    smsCost: number
    country: number
    pincode: number
    mobileNumber: number
    landlineNumber: number
    websiteAddress: number
    gstNumber: number
    subscriptionType: number
    endDate: number
    whatsappNumber: number
    createdAt: number
    updatedAt: number
    razorpayAccessToken: number
    razorpayRefreshToken: number
    razorpayTokenExpiresAt: number
    razorpayAccountId: number
    razorpayState: number
    razorpayStateExpiresAt: number
    monthlyUsage: number
    _all: number
  }


  export type OrganisationAvgAggregateInputType = {
    id?: true
    smsCount?: true
    smsCost?: true
    monthlyUsage?: true
  }

  export type OrganisationSumAggregateInputType = {
    id?: true
    smsCount?: true
    smsCost?: true
    monthlyUsage?: true
  }

  export type OrganisationMinAggregateInputType = {
    id?: true
    password?: true
    resetToken?: true
    resetTokenExpiry?: true
    email?: true
    phone?: true
    name?: true
    companySize?: true
    shopName?: true
    flatNo?: true
    street?: true
    district?: true
    city?: true
    state?: true
    smsCount?: true
    smsCost?: true
    country?: true
    pincode?: true
    mobileNumber?: true
    landlineNumber?: true
    websiteAddress?: true
    gstNumber?: true
    subscriptionType?: true
    endDate?: true
    whatsappNumber?: true
    createdAt?: true
    updatedAt?: true
    razorpayAccessToken?: true
    razorpayRefreshToken?: true
    razorpayTokenExpiresAt?: true
    razorpayAccountId?: true
    razorpayState?: true
    razorpayStateExpiresAt?: true
    monthlyUsage?: true
  }

  export type OrganisationMaxAggregateInputType = {
    id?: true
    password?: true
    resetToken?: true
    resetTokenExpiry?: true
    email?: true
    phone?: true
    name?: true
    companySize?: true
    shopName?: true
    flatNo?: true
    street?: true
    district?: true
    city?: true
    state?: true
    smsCount?: true
    smsCost?: true
    country?: true
    pincode?: true
    mobileNumber?: true
    landlineNumber?: true
    websiteAddress?: true
    gstNumber?: true
    subscriptionType?: true
    endDate?: true
    whatsappNumber?: true
    createdAt?: true
    updatedAt?: true
    razorpayAccessToken?: true
    razorpayRefreshToken?: true
    razorpayTokenExpiresAt?: true
    razorpayAccountId?: true
    razorpayState?: true
    razorpayStateExpiresAt?: true
    monthlyUsage?: true
  }

  export type OrganisationCountAggregateInputType = {
    id?: true
    password?: true
    resetToken?: true
    resetTokenExpiry?: true
    email?: true
    phone?: true
    name?: true
    companySize?: true
    shopName?: true
    flatNo?: true
    street?: true
    district?: true
    city?: true
    state?: true
    smsCount?: true
    smsCost?: true
    country?: true
    pincode?: true
    mobileNumber?: true
    landlineNumber?: true
    websiteAddress?: true
    gstNumber?: true
    subscriptionType?: true
    endDate?: true
    whatsappNumber?: true
    createdAt?: true
    updatedAt?: true
    razorpayAccessToken?: true
    razorpayRefreshToken?: true
    razorpayTokenExpiresAt?: true
    razorpayAccountId?: true
    razorpayState?: true
    razorpayStateExpiresAt?: true
    monthlyUsage?: true
    _all?: true
  }

  export type OrganisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisation to aggregate.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organisations
    **/
    _count?: true | OrganisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganisationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganisationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationMaxAggregateInputType
  }

  export type GetOrganisationAggregateType<T extends OrganisationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisation[P]>
      : GetScalarType<T[P], AggregateOrganisation[P]>
  }




  export type OrganisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationWhereInput
    orderBy?: OrganisationOrderByWithAggregationInput | OrganisationOrderByWithAggregationInput[]
    by: OrganisationScalarFieldEnum[] | OrganisationScalarFieldEnum
    having?: OrganisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationCountAggregateInputType | true
    _avg?: OrganisationAvgAggregateInputType
    _sum?: OrganisationSumAggregateInputType
    _min?: OrganisationMinAggregateInputType
    _max?: OrganisationMaxAggregateInputType
  }

  export type OrganisationGroupByOutputType = {
    id: number
    password: string
    resetToken: string | null
    resetTokenExpiry: Date | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city: string | null
    state: string
    smsCount: number
    smsCost: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber: string | null
    websiteAddress: string | null
    gstNumber: string | null
    subscriptionType: string
    endDate: Date
    whatsappNumber: string | null
    createdAt: Date
    updatedAt: Date
    razorpayAccessToken: string | null
    razorpayRefreshToken: string | null
    razorpayTokenExpiresAt: Date | null
    razorpayAccountId: string | null
    razorpayState: string | null
    razorpayStateExpiresAt: Date | null
    monthlyUsage: number
    _count: OrganisationCountAggregateOutputType | null
    _avg: OrganisationAvgAggregateOutputType | null
    _sum: OrganisationSumAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  type GetOrganisationGroupByPayload<T extends OrganisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    companySize?: boolean
    shopName?: boolean
    flatNo?: boolean
    street?: boolean
    district?: boolean
    city?: boolean
    state?: boolean
    smsCount?: boolean
    smsCost?: boolean
    country?: boolean
    pincode?: boolean
    mobileNumber?: boolean
    landlineNumber?: boolean
    websiteAddress?: boolean
    gstNumber?: boolean
    subscriptionType?: boolean
    endDate?: boolean
    whatsappNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    razorpayAccessToken?: boolean
    razorpayRefreshToken?: boolean
    razorpayTokenExpiresAt?: boolean
    razorpayAccountId?: boolean
    razorpayState?: boolean
    razorpayStateExpiresAt?: boolean
    monthlyUsage?: boolean
    productCategories?: boolean | Organisation$productCategoriesArgs<ExtArgs>
    products?: boolean | Organisation$productsArgs<ExtArgs>
    sellers?: boolean | Organisation$sellersArgs<ExtArgs>
    transactions?: boolean | Organisation$transactionsArgs<ExtArgs>
    customers?: boolean | Organisation$customersArgs<ExtArgs>
    inventory?: boolean | Organisation$inventoryArgs<ExtArgs>
    CustomerSubmission?: boolean | Organisation$CustomerSubmissionArgs<ExtArgs>
    ShippingMethod?: boolean | Organisation$ShippingMethodArgs<ExtArgs>
    Mandate?: boolean | Organisation$MandateArgs<ExtArgs>
    activeMandates?: boolean | Organisation$activeMandatesArgs<ExtArgs>
    MandateNotification?: boolean | Organisation$MandateNotificationArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisation"]>



  export type OrganisationSelectScalar = {
    id?: boolean
    password?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    companySize?: boolean
    shopName?: boolean
    flatNo?: boolean
    street?: boolean
    district?: boolean
    city?: boolean
    state?: boolean
    smsCount?: boolean
    smsCost?: boolean
    country?: boolean
    pincode?: boolean
    mobileNumber?: boolean
    landlineNumber?: boolean
    websiteAddress?: boolean
    gstNumber?: boolean
    subscriptionType?: boolean
    endDate?: boolean
    whatsappNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    razorpayAccessToken?: boolean
    razorpayRefreshToken?: boolean
    razorpayTokenExpiresAt?: boolean
    razorpayAccountId?: boolean
    razorpayState?: boolean
    razorpayStateExpiresAt?: boolean
    monthlyUsage?: boolean
  }

  export type OrganisationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "password" | "resetToken" | "resetTokenExpiry" | "email" | "phone" | "name" | "companySize" | "shopName" | "flatNo" | "street" | "district" | "city" | "state" | "smsCount" | "smsCost" | "country" | "pincode" | "mobileNumber" | "landlineNumber" | "websiteAddress" | "gstNumber" | "subscriptionType" | "endDate" | "whatsappNumber" | "createdAt" | "updatedAt" | "razorpayAccessToken" | "razorpayRefreshToken" | "razorpayTokenExpiresAt" | "razorpayAccountId" | "razorpayState" | "razorpayStateExpiresAt" | "monthlyUsage", ExtArgs["result"]["organisation"]>
  export type OrganisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCategories?: boolean | Organisation$productCategoriesArgs<ExtArgs>
    products?: boolean | Organisation$productsArgs<ExtArgs>
    sellers?: boolean | Organisation$sellersArgs<ExtArgs>
    transactions?: boolean | Organisation$transactionsArgs<ExtArgs>
    customers?: boolean | Organisation$customersArgs<ExtArgs>
    inventory?: boolean | Organisation$inventoryArgs<ExtArgs>
    CustomerSubmission?: boolean | Organisation$CustomerSubmissionArgs<ExtArgs>
    ShippingMethod?: boolean | Organisation$ShippingMethodArgs<ExtArgs>
    Mandate?: boolean | Organisation$MandateArgs<ExtArgs>
    activeMandates?: boolean | Organisation$activeMandatesArgs<ExtArgs>
    MandateNotification?: boolean | Organisation$MandateNotificationArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organisation"
    objects: {
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      sellers: Prisma.$SellerPayload<ExtArgs>[]
      transactions: Prisma.$TransactionRecordPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      CustomerSubmission: Prisma.$CustomerSubmissionPayload<ExtArgs>[]
      ShippingMethod: Prisma.$ShippingMethodPayload<ExtArgs>[]
      Mandate: Prisma.$MandatePayload<ExtArgs>[]
      activeMandates: Prisma.$ActiveMandatePayload<ExtArgs> | null
      MandateNotification: Prisma.$MandateNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      password: string
      resetToken: string | null
      resetTokenExpiry: Date | null
      email: string
      phone: string
      name: string
      companySize: string
      shopName: string
      flatNo: string
      street: string
      district: string
      city: string | null
      state: string
      smsCount: number
      smsCost: number
      country: string
      pincode: string
      mobileNumber: string
      landlineNumber: string | null
      websiteAddress: string | null
      gstNumber: string | null
      subscriptionType: string
      endDate: Date
      whatsappNumber: string | null
      createdAt: Date
      updatedAt: Date
      razorpayAccessToken: string | null
      razorpayRefreshToken: string | null
      razorpayTokenExpiresAt: Date | null
      razorpayAccountId: string | null
      razorpayState: string | null
      razorpayStateExpiresAt: Date | null
      monthlyUsage: number
    }, ExtArgs["result"]["organisation"]>
    composites: {}
  }

  type OrganisationGetPayload<S extends boolean | null | undefined | OrganisationDefaultArgs> = $Result.GetResult<Prisma.$OrganisationPayload, S>

  type OrganisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganisationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganisationCountAggregateInputType | true
    }

  export interface OrganisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organisation'], meta: { name: 'Organisation' } }
    /**
     * Find zero or one Organisation that matches the filter.
     * @param {OrganisationFindUniqueArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationFindUniqueArgs>(args: SelectSubset<T, OrganisationFindUniqueArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organisation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganisationFindUniqueOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationFindFirstArgs>(args?: SelectSubset<T, OrganisationFindFirstArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organisations
     * const organisations = await prisma.organisation.findMany()
     * 
     * // Get first 10 Organisations
     * const organisations = await prisma.organisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationWithIdOnly = await prisma.organisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationFindManyArgs>(args?: SelectSubset<T, OrganisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organisation.
     * @param {OrganisationCreateArgs} args - Arguments to create a Organisation.
     * @example
     * // Create one Organisation
     * const Organisation = await prisma.organisation.create({
     *   data: {
     *     // ... data to create a Organisation
     *   }
     * })
     * 
     */
    create<T extends OrganisationCreateArgs>(args: SelectSubset<T, OrganisationCreateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organisations.
     * @param {OrganisationCreateManyArgs} args - Arguments to create many Organisations.
     * @example
     * // Create many Organisations
     * const organisation = await prisma.organisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationCreateManyArgs>(args?: SelectSubset<T, OrganisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organisation.
     * @param {OrganisationDeleteArgs} args - Arguments to delete one Organisation.
     * @example
     * // Delete one Organisation
     * const Organisation = await prisma.organisation.delete({
     *   where: {
     *     // ... filter to delete one Organisation
     *   }
     * })
     * 
     */
    delete<T extends OrganisationDeleteArgs>(args: SelectSubset<T, OrganisationDeleteArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organisation.
     * @param {OrganisationUpdateArgs} args - Arguments to update one Organisation.
     * @example
     * // Update one Organisation
     * const organisation = await prisma.organisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationUpdateArgs>(args: SelectSubset<T, OrganisationUpdateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organisations.
     * @param {OrganisationDeleteManyArgs} args - Arguments to filter Organisations to delete.
     * @example
     * // Delete a few Organisations
     * const { count } = await prisma.organisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationDeleteManyArgs>(args?: SelectSubset<T, OrganisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organisations
     * const organisation = await prisma.organisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationUpdateManyArgs>(args: SelectSubset<T, OrganisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organisation.
     * @param {OrganisationUpsertArgs} args - Arguments to update or create a Organisation.
     * @example
     * // Update or create a Organisation
     * const organisation = await prisma.organisation.upsert({
     *   create: {
     *     // ... data to create a Organisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organisation we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationUpsertArgs>(args: SelectSubset<T, OrganisationUpsertArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationCountArgs} args - Arguments to filter Organisations to count.
     * @example
     * // Count the number of Organisations
     * const count = await prisma.organisation.count({
     *   where: {
     *     // ... the filter for the Organisations we want to count
     *   }
     * })
    **/
    count<T extends OrganisationCountArgs>(
      args?: Subset<T, OrganisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationAggregateArgs>(args: Subset<T, OrganisationAggregateArgs>): Prisma.PrismaPromise<GetOrganisationAggregateType<T>>

    /**
     * Group by Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organisation model
   */
  readonly fields: OrganisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productCategories<T extends Organisation$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Organisation$productsArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sellers<T extends Organisation$sellersArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$sellersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Organisation$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Organisation$customersArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends Organisation$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CustomerSubmission<T extends Organisation$CustomerSubmissionArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$CustomerSubmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShippingMethod<T extends Organisation$ShippingMethodArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$ShippingMethodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Mandate<T extends Organisation$MandateArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$MandateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activeMandates<T extends Organisation$activeMandatesArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$activeMandatesArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    MandateNotification<T extends Organisation$MandateNotificationArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$MandateNotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organisation model
   */
  interface OrganisationFieldRefs {
    readonly id: FieldRef<"Organisation", 'Int'>
    readonly password: FieldRef<"Organisation", 'String'>
    readonly resetToken: FieldRef<"Organisation", 'String'>
    readonly resetTokenExpiry: FieldRef<"Organisation", 'DateTime'>
    readonly email: FieldRef<"Organisation", 'String'>
    readonly phone: FieldRef<"Organisation", 'String'>
    readonly name: FieldRef<"Organisation", 'String'>
    readonly companySize: FieldRef<"Organisation", 'String'>
    readonly shopName: FieldRef<"Organisation", 'String'>
    readonly flatNo: FieldRef<"Organisation", 'String'>
    readonly street: FieldRef<"Organisation", 'String'>
    readonly district: FieldRef<"Organisation", 'String'>
    readonly city: FieldRef<"Organisation", 'String'>
    readonly state: FieldRef<"Organisation", 'String'>
    readonly smsCount: FieldRef<"Organisation", 'Int'>
    readonly smsCost: FieldRef<"Organisation", 'Float'>
    readonly country: FieldRef<"Organisation", 'String'>
    readonly pincode: FieldRef<"Organisation", 'String'>
    readonly mobileNumber: FieldRef<"Organisation", 'String'>
    readonly landlineNumber: FieldRef<"Organisation", 'String'>
    readonly websiteAddress: FieldRef<"Organisation", 'String'>
    readonly gstNumber: FieldRef<"Organisation", 'String'>
    readonly subscriptionType: FieldRef<"Organisation", 'String'>
    readonly endDate: FieldRef<"Organisation", 'DateTime'>
    readonly whatsappNumber: FieldRef<"Organisation", 'String'>
    readonly createdAt: FieldRef<"Organisation", 'DateTime'>
    readonly updatedAt: FieldRef<"Organisation", 'DateTime'>
    readonly razorpayAccessToken: FieldRef<"Organisation", 'String'>
    readonly razorpayRefreshToken: FieldRef<"Organisation", 'String'>
    readonly razorpayTokenExpiresAt: FieldRef<"Organisation", 'DateTime'>
    readonly razorpayAccountId: FieldRef<"Organisation", 'String'>
    readonly razorpayState: FieldRef<"Organisation", 'String'>
    readonly razorpayStateExpiresAt: FieldRef<"Organisation", 'DateTime'>
    readonly monthlyUsage: FieldRef<"Organisation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Organisation findUnique
   */
  export type OrganisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findUniqueOrThrow
   */
  export type OrganisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findFirst
   */
  export type OrganisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findFirstOrThrow
   */
  export type OrganisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findMany
   */
  export type OrganisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation create
   */
  export type OrganisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organisation.
     */
    data: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
  }

  /**
   * Organisation createMany
   */
  export type OrganisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organisations.
     */
    data: OrganisationCreateManyInput | OrganisationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organisation update
   */
  export type OrganisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organisation.
     */
    data: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
    /**
     * Choose, which Organisation to update.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation updateMany
   */
  export type OrganisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organisations.
     */
    data: XOR<OrganisationUpdateManyMutationInput, OrganisationUncheckedUpdateManyInput>
    /**
     * Filter which Organisations to update
     */
    where?: OrganisationWhereInput
    /**
     * Limit how many Organisations to update.
     */
    limit?: number
  }

  /**
   * Organisation upsert
   */
  export type OrganisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organisation to update in case it exists.
     */
    where: OrganisationWhereUniqueInput
    /**
     * In case the Organisation found by the `where` argument doesn't exist, create a new Organisation with this data.
     */
    create: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
    /**
     * In case the Organisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
  }

  /**
   * Organisation delete
   */
  export type OrganisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter which Organisation to delete.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation deleteMany
   */
  export type OrganisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisations to delete
     */
    where?: OrganisationWhereInput
    /**
     * Limit how many Organisations to delete.
     */
    limit?: number
  }

  /**
   * Organisation.productCategories
   */
  export type Organisation$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Organisation.products
   */
  export type Organisation$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Organisation.sellers
   */
  export type Organisation$sellersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    where?: SellerWhereInput
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    cursor?: SellerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Organisation.transactions
   */
  export type Organisation$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    where?: TransactionRecordWhereInput
    orderBy?: TransactionRecordOrderByWithRelationInput | TransactionRecordOrderByWithRelationInput[]
    cursor?: TransactionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionRecordScalarFieldEnum | TransactionRecordScalarFieldEnum[]
  }

  /**
   * Organisation.customers
   */
  export type Organisation$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Organisation.inventory
   */
  export type Organisation$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Organisation.CustomerSubmission
   */
  export type Organisation$CustomerSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    where?: CustomerSubmissionWhereInput
    orderBy?: CustomerSubmissionOrderByWithRelationInput | CustomerSubmissionOrderByWithRelationInput[]
    cursor?: CustomerSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerSubmissionScalarFieldEnum | CustomerSubmissionScalarFieldEnum[]
  }

  /**
   * Organisation.ShippingMethod
   */
  export type Organisation$ShippingMethodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    where?: ShippingMethodWhereInput
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    cursor?: ShippingMethodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * Organisation.Mandate
   */
  export type Organisation$MandateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    where?: MandateWhereInput
    orderBy?: MandateOrderByWithRelationInput | MandateOrderByWithRelationInput[]
    cursor?: MandateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MandateScalarFieldEnum | MandateScalarFieldEnum[]
  }

  /**
   * Organisation.activeMandates
   */
  export type Organisation$activeMandatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    where?: ActiveMandateWhereInput
  }

  /**
   * Organisation.MandateNotification
   */
  export type Organisation$MandateNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    where?: MandateNotificationWhereInput
    orderBy?: MandateNotificationOrderByWithRelationInput | MandateNotificationOrderByWithRelationInput[]
    cursor?: MandateNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MandateNotificationScalarFieldEnum | MandateNotificationScalarFieldEnum[]
  }

  /**
   * Organisation without action
   */
  export type OrganisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organisation
     */
    omit?: OrganisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
  }


  /**
   * Model CustomerSubmission
   */

  export type AggregateCustomerSubmission = {
    _count: CustomerSubmissionCountAggregateOutputType | null
    _avg: CustomerSubmissionAvgAggregateOutputType | null
    _sum: CustomerSubmissionSumAggregateOutputType | null
    _min: CustomerSubmissionMinAggregateOutputType | null
    _max: CustomerSubmissionMaxAggregateOutputType | null
  }

  export type CustomerSubmissionAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    customerId: number | null
  }

  export type CustomerSubmissionSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    customerId: number | null
  }

  export type CustomerSubmissionMinAggregateOutputType = {
    id: number | null
    token: string | null
    organisationId: number | null
    customerId: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerSubmissionMaxAggregateOutputType = {
    id: number | null
    token: string | null
    organisationId: number | null
    customerId: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerSubmissionCountAggregateOutputType = {
    id: number
    token: number
    organisationId: number
    customerId: number
    notes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerSubmissionAvgAggregateInputType = {
    id?: true
    organisationId?: true
    customerId?: true
  }

  export type CustomerSubmissionSumAggregateInputType = {
    id?: true
    organisationId?: true
    customerId?: true
  }

  export type CustomerSubmissionMinAggregateInputType = {
    id?: true
    token?: true
    organisationId?: true
    customerId?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerSubmissionMaxAggregateInputType = {
    id?: true
    token?: true
    organisationId?: true
    customerId?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerSubmissionCountAggregateInputType = {
    id?: true
    token?: true
    organisationId?: true
    customerId?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSubmission to aggregate.
     */
    where?: CustomerSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubmissions to fetch.
     */
    orderBy?: CustomerSubmissionOrderByWithRelationInput | CustomerSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerSubmissions
    **/
    _count?: true | CustomerSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerSubmissionMaxAggregateInputType
  }

  export type GetCustomerSubmissionAggregateType<T extends CustomerSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerSubmission[P]>
      : GetScalarType<T[P], AggregateCustomerSubmission[P]>
  }




  export type CustomerSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSubmissionWhereInput
    orderBy?: CustomerSubmissionOrderByWithAggregationInput | CustomerSubmissionOrderByWithAggregationInput[]
    by: CustomerSubmissionScalarFieldEnum[] | CustomerSubmissionScalarFieldEnum
    having?: CustomerSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerSubmissionCountAggregateInputType | true
    _avg?: CustomerSubmissionAvgAggregateInputType
    _sum?: CustomerSubmissionSumAggregateInputType
    _min?: CustomerSubmissionMinAggregateInputType
    _max?: CustomerSubmissionMaxAggregateInputType
  }

  export type CustomerSubmissionGroupByOutputType = {
    id: number
    token: string
    organisationId: number
    customerId: number | null
    notes: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: CustomerSubmissionCountAggregateOutputType | null
    _avg: CustomerSubmissionAvgAggregateOutputType | null
    _sum: CustomerSubmissionSumAggregateOutputType | null
    _min: CustomerSubmissionMinAggregateOutputType | null
    _max: CustomerSubmissionMaxAggregateOutputType | null
  }

  type GetCustomerSubmissionGroupByPayload<T extends CustomerSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    organisationId?: boolean
    customerId?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    customers?: boolean | CustomerSubmission$customersArgs<ExtArgs>
  }, ExtArgs["result"]["customerSubmission"]>



  export type CustomerSubmissionSelectScalar = {
    id?: boolean
    token?: boolean
    organisationId?: boolean
    customerId?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "organisationId" | "customerId" | "notes" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["customerSubmission"]>
  export type CustomerSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    customers?: boolean | CustomerSubmission$customersArgs<ExtArgs>
  }

  export type $CustomerSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerSubmission"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
      customers: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      organisationId: number
      customerId: number | null
      notes: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerSubmission"]>
    composites: {}
  }

  type CustomerSubmissionGetPayload<S extends boolean | null | undefined | CustomerSubmissionDefaultArgs> = $Result.GetResult<Prisma.$CustomerSubmissionPayload, S>

  type CustomerSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerSubmissionCountAggregateInputType | true
    }

  export interface CustomerSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerSubmission'], meta: { name: 'CustomerSubmission' } }
    /**
     * Find zero or one CustomerSubmission that matches the filter.
     * @param {CustomerSubmissionFindUniqueArgs} args - Arguments to find a CustomerSubmission
     * @example
     * // Get one CustomerSubmission
     * const customerSubmission = await prisma.customerSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerSubmissionFindUniqueArgs>(args: SelectSubset<T, CustomerSubmissionFindUniqueArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerSubmissionFindUniqueOrThrowArgs} args - Arguments to find a CustomerSubmission
     * @example
     * // Get one CustomerSubmission
     * const customerSubmission = await prisma.customerSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubmissionFindFirstArgs} args - Arguments to find a CustomerSubmission
     * @example
     * // Get one CustomerSubmission
     * const customerSubmission = await prisma.customerSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerSubmissionFindFirstArgs>(args?: SelectSubset<T, CustomerSubmissionFindFirstArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubmissionFindFirstOrThrowArgs} args - Arguments to find a CustomerSubmission
     * @example
     * // Get one CustomerSubmission
     * const customerSubmission = await prisma.customerSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerSubmissions
     * const customerSubmissions = await prisma.customerSubmission.findMany()
     * 
     * // Get first 10 CustomerSubmissions
     * const customerSubmissions = await prisma.customerSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerSubmissionWithIdOnly = await prisma.customerSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerSubmissionFindManyArgs>(args?: SelectSubset<T, CustomerSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerSubmission.
     * @param {CustomerSubmissionCreateArgs} args - Arguments to create a CustomerSubmission.
     * @example
     * // Create one CustomerSubmission
     * const CustomerSubmission = await prisma.customerSubmission.create({
     *   data: {
     *     // ... data to create a CustomerSubmission
     *   }
     * })
     * 
     */
    create<T extends CustomerSubmissionCreateArgs>(args: SelectSubset<T, CustomerSubmissionCreateArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerSubmissions.
     * @param {CustomerSubmissionCreateManyArgs} args - Arguments to create many CustomerSubmissions.
     * @example
     * // Create many CustomerSubmissions
     * const customerSubmission = await prisma.customerSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerSubmissionCreateManyArgs>(args?: SelectSubset<T, CustomerSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerSubmission.
     * @param {CustomerSubmissionDeleteArgs} args - Arguments to delete one CustomerSubmission.
     * @example
     * // Delete one CustomerSubmission
     * const CustomerSubmission = await prisma.customerSubmission.delete({
     *   where: {
     *     // ... filter to delete one CustomerSubmission
     *   }
     * })
     * 
     */
    delete<T extends CustomerSubmissionDeleteArgs>(args: SelectSubset<T, CustomerSubmissionDeleteArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerSubmission.
     * @param {CustomerSubmissionUpdateArgs} args - Arguments to update one CustomerSubmission.
     * @example
     * // Update one CustomerSubmission
     * const customerSubmission = await prisma.customerSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerSubmissionUpdateArgs>(args: SelectSubset<T, CustomerSubmissionUpdateArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerSubmissions.
     * @param {CustomerSubmissionDeleteManyArgs} args - Arguments to filter CustomerSubmissions to delete.
     * @example
     * // Delete a few CustomerSubmissions
     * const { count } = await prisma.customerSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerSubmissionDeleteManyArgs>(args?: SelectSubset<T, CustomerSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerSubmissions
     * const customerSubmission = await prisma.customerSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerSubmissionUpdateManyArgs>(args: SelectSubset<T, CustomerSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerSubmission.
     * @param {CustomerSubmissionUpsertArgs} args - Arguments to update or create a CustomerSubmission.
     * @example
     * // Update or create a CustomerSubmission
     * const customerSubmission = await prisma.customerSubmission.upsert({
     *   create: {
     *     // ... data to create a CustomerSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerSubmission we want to update
     *   }
     * })
     */
    upsert<T extends CustomerSubmissionUpsertArgs>(args: SelectSubset<T, CustomerSubmissionUpsertArgs<ExtArgs>>): Prisma__CustomerSubmissionClient<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubmissionCountArgs} args - Arguments to filter CustomerSubmissions to count.
     * @example
     * // Count the number of CustomerSubmissions
     * const count = await prisma.customerSubmission.count({
     *   where: {
     *     // ... the filter for the CustomerSubmissions we want to count
     *   }
     * })
    **/
    count<T extends CustomerSubmissionCountArgs>(
      args?: Subset<T, CustomerSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerSubmissionAggregateArgs>(args: Subset<T, CustomerSubmissionAggregateArgs>): Prisma.PrismaPromise<GetCustomerSubmissionAggregateType<T>>

    /**
     * Group by CustomerSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: CustomerSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerSubmission model
   */
  readonly fields: CustomerSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends CustomerSubmission$customersArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSubmission$customersArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerSubmission model
   */
  interface CustomerSubmissionFieldRefs {
    readonly id: FieldRef<"CustomerSubmission", 'Int'>
    readonly token: FieldRef<"CustomerSubmission", 'String'>
    readonly organisationId: FieldRef<"CustomerSubmission", 'Int'>
    readonly customerId: FieldRef<"CustomerSubmission", 'Int'>
    readonly notes: FieldRef<"CustomerSubmission", 'String'>
    readonly status: FieldRef<"CustomerSubmission", 'String'>
    readonly createdAt: FieldRef<"CustomerSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerSubmission findUnique
   */
  export type CustomerSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubmission to fetch.
     */
    where: CustomerSubmissionWhereUniqueInput
  }

  /**
   * CustomerSubmission findUniqueOrThrow
   */
  export type CustomerSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubmission to fetch.
     */
    where: CustomerSubmissionWhereUniqueInput
  }

  /**
   * CustomerSubmission findFirst
   */
  export type CustomerSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubmission to fetch.
     */
    where?: CustomerSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubmissions to fetch.
     */
    orderBy?: CustomerSubmissionOrderByWithRelationInput | CustomerSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSubmissions.
     */
    cursor?: CustomerSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSubmissions.
     */
    distinct?: CustomerSubmissionScalarFieldEnum | CustomerSubmissionScalarFieldEnum[]
  }

  /**
   * CustomerSubmission findFirstOrThrow
   */
  export type CustomerSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubmission to fetch.
     */
    where?: CustomerSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubmissions to fetch.
     */
    orderBy?: CustomerSubmissionOrderByWithRelationInput | CustomerSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSubmissions.
     */
    cursor?: CustomerSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSubmissions.
     */
    distinct?: CustomerSubmissionScalarFieldEnum | CustomerSubmissionScalarFieldEnum[]
  }

  /**
   * CustomerSubmission findMany
   */
  export type CustomerSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSubmissions to fetch.
     */
    where?: CustomerSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSubmissions to fetch.
     */
    orderBy?: CustomerSubmissionOrderByWithRelationInput | CustomerSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerSubmissions.
     */
    cursor?: CustomerSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSubmissions.
     */
    skip?: number
    distinct?: CustomerSubmissionScalarFieldEnum | CustomerSubmissionScalarFieldEnum[]
  }

  /**
   * CustomerSubmission create
   */
  export type CustomerSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerSubmission.
     */
    data: XOR<CustomerSubmissionCreateInput, CustomerSubmissionUncheckedCreateInput>
  }

  /**
   * CustomerSubmission createMany
   */
  export type CustomerSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerSubmissions.
     */
    data: CustomerSubmissionCreateManyInput | CustomerSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerSubmission update
   */
  export type CustomerSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerSubmission.
     */
    data: XOR<CustomerSubmissionUpdateInput, CustomerSubmissionUncheckedUpdateInput>
    /**
     * Choose, which CustomerSubmission to update.
     */
    where: CustomerSubmissionWhereUniqueInput
  }

  /**
   * CustomerSubmission updateMany
   */
  export type CustomerSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerSubmissions.
     */
    data: XOR<CustomerSubmissionUpdateManyMutationInput, CustomerSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which CustomerSubmissions to update
     */
    where?: CustomerSubmissionWhereInput
    /**
     * Limit how many CustomerSubmissions to update.
     */
    limit?: number
  }

  /**
   * CustomerSubmission upsert
   */
  export type CustomerSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerSubmission to update in case it exists.
     */
    where: CustomerSubmissionWhereUniqueInput
    /**
     * In case the CustomerSubmission found by the `where` argument doesn't exist, create a new CustomerSubmission with this data.
     */
    create: XOR<CustomerSubmissionCreateInput, CustomerSubmissionUncheckedCreateInput>
    /**
     * In case the CustomerSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerSubmissionUpdateInput, CustomerSubmissionUncheckedUpdateInput>
  }

  /**
   * CustomerSubmission delete
   */
  export type CustomerSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    /**
     * Filter which CustomerSubmission to delete.
     */
    where: CustomerSubmissionWhereUniqueInput
  }

  /**
   * CustomerSubmission deleteMany
   */
  export type CustomerSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSubmissions to delete
     */
    where?: CustomerSubmissionWhereInput
    /**
     * Limit how many CustomerSubmissions to delete.
     */
    limit?: number
  }

  /**
   * CustomerSubmission.customers
   */
  export type CustomerSubmission$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * CustomerSubmission without action
   */
  export type CustomerSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    organisationId: number | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    organisationId: number | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    organisationId: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    organisationId?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    organisationId?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    organisationId?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: number
    name: string
    organisationId: number
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    organisationId?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    inventory?: boolean | ProductCategory$inventoryArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>



  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    organisationId?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "organisationId", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    inventory?: boolean | ProductCategory$inventoryArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      organisationId: number
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends ProductCategory$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'Int'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly organisationId: FieldRef<"ProductCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory.inventory
   */
  export type ProductCategory$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    netPrice: number | null
    sellingPrice: number | null
    quantity: number | null
    organisationId: number | null
    categoryId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    netPrice: number | null
    sellingPrice: number | null
    quantity: number | null
    organisationId: number | null
    categoryId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    SKU: string | null
    netPrice: number | null
    sellingPrice: number | null
    quantity: number | null
    seller: string | null
    organisationId: number | null
    categoryId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    SKU: string | null
    netPrice: number | null
    sellingPrice: number | null
    quantity: number | null
    seller: string | null
    organisationId: number | null
    categoryId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    SKU: number
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: number
    organisationId: number
    categoryId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    netPrice?: true
    sellingPrice?: true
    quantity?: true
    organisationId?: true
    categoryId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    netPrice?: true
    sellingPrice?: true
    quantity?: true
    organisationId?: true
    categoryId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    SKU?: true
    netPrice?: true
    sellingPrice?: true
    quantity?: true
    seller?: true
    organisationId?: true
    categoryId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    SKU?: true
    netPrice?: true
    sellingPrice?: true
    quantity?: true
    seller?: true
    organisationId?: true
    categoryId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    SKU?: true
    netPrice?: true
    sellingPrice?: true
    quantity?: true
    seller?: true
    organisationId?: true
    categoryId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisationId: number
    categoryId: number | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    SKU?: boolean
    netPrice?: boolean
    sellingPrice?: boolean
    quantity?: boolean
    seller?: boolean
    organisationId?: boolean
    categoryId?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    transactionItems?: boolean | Product$transactionItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    SKU?: boolean
    netPrice?: boolean
    sellingPrice?: boolean
    quantity?: boolean
    seller?: boolean
    organisationId?: boolean
    categoryId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "SKU" | "netPrice" | "sellingPrice" | "quantity" | "seller" | "organisationId" | "categoryId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    inventory?: boolean | Product$inventoryArgs<ExtArgs>
    transactionItems?: boolean | Product$transactionItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      transactionItems: Prisma.$TransactionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      SKU: string
      netPrice: number
      sellingPrice: number
      quantity: number
      seller: string
      organisationId: number
      categoryId: number | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventory<T extends Product$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionItems<T extends Product$transactionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transactionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly SKU: FieldRef<"Product", 'String'>
    readonly netPrice: FieldRef<"Product", 'Float'>
    readonly sellingPrice: FieldRef<"Product", 'Float'>
    readonly quantity: FieldRef<"Product", 'Int'>
    readonly seller: FieldRef<"Product", 'String'>
    readonly organisationId: FieldRef<"Product", 'Int'>
    readonly categoryId: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * Product.inventory
   */
  export type Product$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Product.transactionItems
   */
  export type Product$transactionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    cursor?: TransactionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Seller
   */

  export type AggregateSeller = {
    _count: SellerCountAggregateOutputType | null
    _avg: SellerAvgAggregateOutputType | null
    _sum: SellerSumAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
  }

  export type SellerAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type SellerSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type SellerMinAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    type: string | null
    organisationId: number | null
  }

  export type SellerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    type: string | null
    organisationId: number | null
  }

  export type SellerCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    type: number
    organisationId: number
    _all: number
  }


  export type SellerAvgAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type SellerSumAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type SellerMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    type?: true
    organisationId?: true
  }

  export type SellerMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    type?: true
    organisationId?: true
  }

  export type SellerCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    type?: true
    organisationId?: true
    _all?: true
  }

  export type SellerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seller to aggregate.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sellers
    **/
    _count?: true | SellerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerMaxAggregateInputType
  }

  export type GetSellerAggregateType<T extends SellerAggregateArgs> = {
        [P in keyof T & keyof AggregateSeller]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeller[P]>
      : GetScalarType<T[P], AggregateSeller[P]>
  }




  export type SellerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerWhereInput
    orderBy?: SellerOrderByWithAggregationInput | SellerOrderByWithAggregationInput[]
    by: SellerScalarFieldEnum[] | SellerScalarFieldEnum
    having?: SellerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerCountAggregateInputType | true
    _avg?: SellerAvgAggregateInputType
    _sum?: SellerSumAggregateInputType
    _min?: SellerMinAggregateInputType
    _max?: SellerMaxAggregateInputType
  }

  export type SellerGroupByOutputType = {
    id: number
    name: string
    contact: string
    type: string
    organisationId: number
    _count: SellerCountAggregateOutputType | null
    _avg: SellerAvgAggregateOutputType | null
    _sum: SellerSumAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
  }

  type GetSellerGroupByPayload<T extends SellerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerGroupByOutputType[P]>
            : GetScalarType<T[P], SellerGroupByOutputType[P]>
        }
      >
    >


  export type SellerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    type?: boolean
    organisationId?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seller"]>



  export type SellerSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    type?: boolean
    organisationId?: boolean
  }

  export type SellerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contact" | "type" | "organisationId", ExtArgs["result"]["seller"]>
  export type SellerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }

  export type $SellerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seller"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contact: string
      type: string
      organisationId: number
    }, ExtArgs["result"]["seller"]>
    composites: {}
  }

  type SellerGetPayload<S extends boolean | null | undefined | SellerDefaultArgs> = $Result.GetResult<Prisma.$SellerPayload, S>

  type SellerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerCountAggregateInputType | true
    }

  export interface SellerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seller'], meta: { name: 'Seller' } }
    /**
     * Find zero or one Seller that matches the filter.
     * @param {SellerFindUniqueArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerFindUniqueArgs>(args: SelectSubset<T, SellerFindUniqueArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seller that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerFindUniqueOrThrowArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindFirstArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerFindFirstArgs>(args?: SelectSubset<T, SellerFindFirstArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindFirstOrThrowArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sellers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sellers
     * const sellers = await prisma.seller.findMany()
     * 
     * // Get first 10 Sellers
     * const sellers = await prisma.seller.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerWithIdOnly = await prisma.seller.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerFindManyArgs>(args?: SelectSubset<T, SellerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seller.
     * @param {SellerCreateArgs} args - Arguments to create a Seller.
     * @example
     * // Create one Seller
     * const Seller = await prisma.seller.create({
     *   data: {
     *     // ... data to create a Seller
     *   }
     * })
     * 
     */
    create<T extends SellerCreateArgs>(args: SelectSubset<T, SellerCreateArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sellers.
     * @param {SellerCreateManyArgs} args - Arguments to create many Sellers.
     * @example
     * // Create many Sellers
     * const seller = await prisma.seller.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerCreateManyArgs>(args?: SelectSubset<T, SellerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seller.
     * @param {SellerDeleteArgs} args - Arguments to delete one Seller.
     * @example
     * // Delete one Seller
     * const Seller = await prisma.seller.delete({
     *   where: {
     *     // ... filter to delete one Seller
     *   }
     * })
     * 
     */
    delete<T extends SellerDeleteArgs>(args: SelectSubset<T, SellerDeleteArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seller.
     * @param {SellerUpdateArgs} args - Arguments to update one Seller.
     * @example
     * // Update one Seller
     * const seller = await prisma.seller.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerUpdateArgs>(args: SelectSubset<T, SellerUpdateArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sellers.
     * @param {SellerDeleteManyArgs} args - Arguments to filter Sellers to delete.
     * @example
     * // Delete a few Sellers
     * const { count } = await prisma.seller.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerDeleteManyArgs>(args?: SelectSubset<T, SellerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sellers
     * const seller = await prisma.seller.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerUpdateManyArgs>(args: SelectSubset<T, SellerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seller.
     * @param {SellerUpsertArgs} args - Arguments to update or create a Seller.
     * @example
     * // Update or create a Seller
     * const seller = await prisma.seller.upsert({
     *   create: {
     *     // ... data to create a Seller
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seller we want to update
     *   }
     * })
     */
    upsert<T extends SellerUpsertArgs>(args: SelectSubset<T, SellerUpsertArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerCountArgs} args - Arguments to filter Sellers to count.
     * @example
     * // Count the number of Sellers
     * const count = await prisma.seller.count({
     *   where: {
     *     // ... the filter for the Sellers we want to count
     *   }
     * })
    **/
    count<T extends SellerCountArgs>(
      args?: Subset<T, SellerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerAggregateArgs>(args: Subset<T, SellerAggregateArgs>): Prisma.PrismaPromise<GetSellerAggregateType<T>>

    /**
     * Group by Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerGroupByArgs['orderBy'] }
        : { orderBy?: SellerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seller model
   */
  readonly fields: SellerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seller.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seller model
   */
  interface SellerFieldRefs {
    readonly id: FieldRef<"Seller", 'Int'>
    readonly name: FieldRef<"Seller", 'String'>
    readonly contact: FieldRef<"Seller", 'String'>
    readonly type: FieldRef<"Seller", 'String'>
    readonly organisationId: FieldRef<"Seller", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Seller findUnique
   */
  export type SellerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller findUniqueOrThrow
   */
  export type SellerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller findFirst
   */
  export type SellerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sellers.
     */
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller findFirstOrThrow
   */
  export type SellerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sellers.
     */
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller findMany
   */
  export type SellerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Sellers to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller create
   */
  export type SellerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The data needed to create a Seller.
     */
    data: XOR<SellerCreateInput, SellerUncheckedCreateInput>
  }

  /**
   * Seller createMany
   */
  export type SellerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sellers.
     */
    data: SellerCreateManyInput | SellerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seller update
   */
  export type SellerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The data needed to update a Seller.
     */
    data: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
    /**
     * Choose, which Seller to update.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller updateMany
   */
  export type SellerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sellers.
     */
    data: XOR<SellerUpdateManyMutationInput, SellerUncheckedUpdateManyInput>
    /**
     * Filter which Sellers to update
     */
    where?: SellerWhereInput
    /**
     * Limit how many Sellers to update.
     */
    limit?: number
  }

  /**
   * Seller upsert
   */
  export type SellerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The filter to search for the Seller to update in case it exists.
     */
    where: SellerWhereUniqueInput
    /**
     * In case the Seller found by the `where` argument doesn't exist, create a new Seller with this data.
     */
    create: XOR<SellerCreateInput, SellerUncheckedCreateInput>
    /**
     * In case the Seller was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
  }

  /**
   * Seller delete
   */
  export type SellerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter which Seller to delete.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller deleteMany
   */
  export type SellerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sellers to delete
     */
    where?: SellerWhereInput
    /**
     * Limit how many Sellers to delete.
     */
    limit?: number
  }

  /**
   * Seller without action
   */
  export type SellerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
  }


  /**
   * Model TransactionRecord
   */

  export type AggregateTransactionRecord = {
    _count: TransactionRecordCountAggregateOutputType | null
    _avg: TransactionRecordAvgAggregateOutputType | null
    _sum: TransactionRecordSumAggregateOutputType | null
    _min: TransactionRecordMinAggregateOutputType | null
    _max: TransactionRecordMaxAggregateOutputType | null
  }

  export type TransactionRecordAvgAggregateOutputType = {
    id: number | null
    billNo: number | null
    totalPrice: number | null
    amountPaid: number | null
    balance: number | null
    organisationId: number | null
    weight: number | null
    customerId: number | null
  }

  export type TransactionRecordSumAggregateOutputType = {
    id: number | null
    billNo: number | null
    totalPrice: number | null
    amountPaid: number | null
    balance: number | null
    organisationId: number | null
    weight: number | null
    customerId: number | null
  }

  export type TransactionRecordMinAggregateOutputType = {
    id: number | null
    billNo: number | null
    totalPrice: number | null
    paymentMethod: string | null
    amountPaid: number | null
    balance: number | null
    billingMode: string | null
    organisationId: number | null
    date: Date | null
    time: Date | null
    trackingNumber: string | null
    weight: number | null
    customerId: number | null
    status: string | null
    notes: string | null
    paymentId: string | null
    paymentStatus: $Enums.PaymentStatus | null
    isEdited: boolean | null
  }

  export type TransactionRecordMaxAggregateOutputType = {
    id: number | null
    billNo: number | null
    totalPrice: number | null
    paymentMethod: string | null
    amountPaid: number | null
    balance: number | null
    billingMode: string | null
    organisationId: number | null
    date: Date | null
    time: Date | null
    trackingNumber: string | null
    weight: number | null
    customerId: number | null
    status: string | null
    notes: string | null
    paymentId: string | null
    paymentStatus: $Enums.PaymentStatus | null
    isEdited: boolean | null
  }

  export type TransactionRecordCountAggregateOutputType = {
    id: number
    billNo: number
    totalPrice: number
    paymentMethod: number
    amountPaid: number
    balance: number
    billingMode: number
    organisationId: number
    date: number
    time: number
    trackingNumber: number
    weight: number
    customerId: number
    status: number
    notes: number
    paymentId: number
    paymentStatus: number
    isEdited: number
    _all: number
  }


  export type TransactionRecordAvgAggregateInputType = {
    id?: true
    billNo?: true
    totalPrice?: true
    amountPaid?: true
    balance?: true
    organisationId?: true
    weight?: true
    customerId?: true
  }

  export type TransactionRecordSumAggregateInputType = {
    id?: true
    billNo?: true
    totalPrice?: true
    amountPaid?: true
    balance?: true
    organisationId?: true
    weight?: true
    customerId?: true
  }

  export type TransactionRecordMinAggregateInputType = {
    id?: true
    billNo?: true
    totalPrice?: true
    paymentMethod?: true
    amountPaid?: true
    balance?: true
    billingMode?: true
    organisationId?: true
    date?: true
    time?: true
    trackingNumber?: true
    weight?: true
    customerId?: true
    status?: true
    notes?: true
    paymentId?: true
    paymentStatus?: true
    isEdited?: true
  }

  export type TransactionRecordMaxAggregateInputType = {
    id?: true
    billNo?: true
    totalPrice?: true
    paymentMethod?: true
    amountPaid?: true
    balance?: true
    billingMode?: true
    organisationId?: true
    date?: true
    time?: true
    trackingNumber?: true
    weight?: true
    customerId?: true
    status?: true
    notes?: true
    paymentId?: true
    paymentStatus?: true
    isEdited?: true
  }

  export type TransactionRecordCountAggregateInputType = {
    id?: true
    billNo?: true
    totalPrice?: true
    paymentMethod?: true
    amountPaid?: true
    balance?: true
    billingMode?: true
    organisationId?: true
    date?: true
    time?: true
    trackingNumber?: true
    weight?: true
    customerId?: true
    status?: true
    notes?: true
    paymentId?: true
    paymentStatus?: true
    isEdited?: true
    _all?: true
  }

  export type TransactionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionRecord to aggregate.
     */
    where?: TransactionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionRecords to fetch.
     */
    orderBy?: TransactionRecordOrderByWithRelationInput | TransactionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionRecords
    **/
    _count?: true | TransactionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionRecordMaxAggregateInputType
  }

  export type GetTransactionRecordAggregateType<T extends TransactionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionRecord[P]>
      : GetScalarType<T[P], AggregateTransactionRecord[P]>
  }




  export type TransactionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionRecordWhereInput
    orderBy?: TransactionRecordOrderByWithAggregationInput | TransactionRecordOrderByWithAggregationInput[]
    by: TransactionRecordScalarFieldEnum[] | TransactionRecordScalarFieldEnum
    having?: TransactionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionRecordCountAggregateInputType | true
    _avg?: TransactionRecordAvgAggregateInputType
    _sum?: TransactionRecordSumAggregateInputType
    _min?: TransactionRecordMinAggregateInputType
    _max?: TransactionRecordMaxAggregateInputType
  }

  export type TransactionRecordGroupByOutputType = {
    id: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid: number
    balance: number
    billingMode: string
    organisationId: number
    date: Date
    time: Date
    trackingNumber: string | null
    weight: number | null
    customerId: number | null
    status: string
    notes: string | null
    paymentId: string | null
    paymentStatus: $Enums.PaymentStatus
    isEdited: boolean
    _count: TransactionRecordCountAggregateOutputType | null
    _avg: TransactionRecordAvgAggregateOutputType | null
    _sum: TransactionRecordSumAggregateOutputType | null
    _min: TransactionRecordMinAggregateOutputType | null
    _max: TransactionRecordMaxAggregateOutputType | null
  }

  type GetTransactionRecordGroupByPayload<T extends TransactionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionRecordGroupByOutputType[P]>
        }
      >
    >


  export type TransactionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billNo?: boolean
    totalPrice?: boolean
    paymentMethod?: boolean
    amountPaid?: boolean
    balance?: boolean
    billingMode?: boolean
    organisationId?: boolean
    date?: boolean
    time?: boolean
    trackingNumber?: boolean
    weight?: boolean
    customerId?: boolean
    status?: boolean
    notes?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    isEdited?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    customer?: boolean | TransactionRecord$customerArgs<ExtArgs>
    items?: boolean | TransactionRecord$itemsArgs<ExtArgs>
    TransactionShipping?: boolean | TransactionRecord$TransactionShippingArgs<ExtArgs>
    _count?: boolean | TransactionRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionRecord"]>



  export type TransactionRecordSelectScalar = {
    id?: boolean
    billNo?: boolean
    totalPrice?: boolean
    paymentMethod?: boolean
    amountPaid?: boolean
    balance?: boolean
    billingMode?: boolean
    organisationId?: boolean
    date?: boolean
    time?: boolean
    trackingNumber?: boolean
    weight?: boolean
    customerId?: boolean
    status?: boolean
    notes?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    isEdited?: boolean
  }

  export type TransactionRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "billNo" | "totalPrice" | "paymentMethod" | "amountPaid" | "balance" | "billingMode" | "organisationId" | "date" | "time" | "trackingNumber" | "weight" | "customerId" | "status" | "notes" | "paymentId" | "paymentStatus" | "isEdited", ExtArgs["result"]["transactionRecord"]>
  export type TransactionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    customer?: boolean | TransactionRecord$customerArgs<ExtArgs>
    items?: boolean | TransactionRecord$itemsArgs<ExtArgs>
    TransactionShipping?: boolean | TransactionRecord$TransactionShippingArgs<ExtArgs>
    _count?: boolean | TransactionRecordCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TransactionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionRecord"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$TransactionItemPayload<ExtArgs>[]
      TransactionShipping: Prisma.$TransactionShippingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      billNo: number
      totalPrice: number
      paymentMethod: string
      amountPaid: number
      balance: number
      billingMode: string
      organisationId: number
      date: Date
      time: Date
      trackingNumber: string | null
      weight: number | null
      customerId: number | null
      status: string
      notes: string | null
      paymentId: string | null
      paymentStatus: $Enums.PaymentStatus
      isEdited: boolean
    }, ExtArgs["result"]["transactionRecord"]>
    composites: {}
  }

  type TransactionRecordGetPayload<S extends boolean | null | undefined | TransactionRecordDefaultArgs> = $Result.GetResult<Prisma.$TransactionRecordPayload, S>

  type TransactionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionRecordCountAggregateInputType | true
    }

  export interface TransactionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionRecord'], meta: { name: 'TransactionRecord' } }
    /**
     * Find zero or one TransactionRecord that matches the filter.
     * @param {TransactionRecordFindUniqueArgs} args - Arguments to find a TransactionRecord
     * @example
     * // Get one TransactionRecord
     * const transactionRecord = await prisma.transactionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionRecordFindUniqueArgs>(args: SelectSubset<T, TransactionRecordFindUniqueArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionRecordFindUniqueOrThrowArgs} args - Arguments to find a TransactionRecord
     * @example
     * // Get one TransactionRecord
     * const transactionRecord = await prisma.transactionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionRecordFindFirstArgs} args - Arguments to find a TransactionRecord
     * @example
     * // Get one TransactionRecord
     * const transactionRecord = await prisma.transactionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionRecordFindFirstArgs>(args?: SelectSubset<T, TransactionRecordFindFirstArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionRecordFindFirstOrThrowArgs} args - Arguments to find a TransactionRecord
     * @example
     * // Get one TransactionRecord
     * const transactionRecord = await prisma.transactionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionRecords
     * const transactionRecords = await prisma.transactionRecord.findMany()
     * 
     * // Get first 10 TransactionRecords
     * const transactionRecords = await prisma.transactionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionRecordWithIdOnly = await prisma.transactionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionRecordFindManyArgs>(args?: SelectSubset<T, TransactionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionRecord.
     * @param {TransactionRecordCreateArgs} args - Arguments to create a TransactionRecord.
     * @example
     * // Create one TransactionRecord
     * const TransactionRecord = await prisma.transactionRecord.create({
     *   data: {
     *     // ... data to create a TransactionRecord
     *   }
     * })
     * 
     */
    create<T extends TransactionRecordCreateArgs>(args: SelectSubset<T, TransactionRecordCreateArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionRecords.
     * @param {TransactionRecordCreateManyArgs} args - Arguments to create many TransactionRecords.
     * @example
     * // Create many TransactionRecords
     * const transactionRecord = await prisma.transactionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionRecordCreateManyArgs>(args?: SelectSubset<T, TransactionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionRecord.
     * @param {TransactionRecordDeleteArgs} args - Arguments to delete one TransactionRecord.
     * @example
     * // Delete one TransactionRecord
     * const TransactionRecord = await prisma.transactionRecord.delete({
     *   where: {
     *     // ... filter to delete one TransactionRecord
     *   }
     * })
     * 
     */
    delete<T extends TransactionRecordDeleteArgs>(args: SelectSubset<T, TransactionRecordDeleteArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionRecord.
     * @param {TransactionRecordUpdateArgs} args - Arguments to update one TransactionRecord.
     * @example
     * // Update one TransactionRecord
     * const transactionRecord = await prisma.transactionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionRecordUpdateArgs>(args: SelectSubset<T, TransactionRecordUpdateArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionRecords.
     * @param {TransactionRecordDeleteManyArgs} args - Arguments to filter TransactionRecords to delete.
     * @example
     * // Delete a few TransactionRecords
     * const { count } = await prisma.transactionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionRecordDeleteManyArgs>(args?: SelectSubset<T, TransactionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionRecords
     * const transactionRecord = await prisma.transactionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionRecordUpdateManyArgs>(args: SelectSubset<T, TransactionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionRecord.
     * @param {TransactionRecordUpsertArgs} args - Arguments to update or create a TransactionRecord.
     * @example
     * // Update or create a TransactionRecord
     * const transactionRecord = await prisma.transactionRecord.upsert({
     *   create: {
     *     // ... data to create a TransactionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionRecord we want to update
     *   }
     * })
     */
    upsert<T extends TransactionRecordUpsertArgs>(args: SelectSubset<T, TransactionRecordUpsertArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionRecordCountArgs} args - Arguments to filter TransactionRecords to count.
     * @example
     * // Count the number of TransactionRecords
     * const count = await prisma.transactionRecord.count({
     *   where: {
     *     // ... the filter for the TransactionRecords we want to count
     *   }
     * })
    **/
    count<T extends TransactionRecordCountArgs>(
      args?: Subset<T, TransactionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionRecordAggregateArgs>(args: Subset<T, TransactionRecordAggregateArgs>): Prisma.PrismaPromise<GetTransactionRecordAggregateType<T>>

    /**
     * Group by TransactionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionRecordGroupByArgs['orderBy'] }
        : { orderBy?: TransactionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionRecord model
   */
  readonly fields: TransactionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends TransactionRecord$customerArgs<ExtArgs> = {}>(args?: Subset<T, TransactionRecord$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends TransactionRecord$itemsArgs<ExtArgs> = {}>(args?: Subset<T, TransactionRecord$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TransactionShipping<T extends TransactionRecord$TransactionShippingArgs<ExtArgs> = {}>(args?: Subset<T, TransactionRecord$TransactionShippingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionRecord model
   */
  interface TransactionRecordFieldRefs {
    readonly id: FieldRef<"TransactionRecord", 'Int'>
    readonly billNo: FieldRef<"TransactionRecord", 'Int'>
    readonly totalPrice: FieldRef<"TransactionRecord", 'Float'>
    readonly paymentMethod: FieldRef<"TransactionRecord", 'String'>
    readonly amountPaid: FieldRef<"TransactionRecord", 'Float'>
    readonly balance: FieldRef<"TransactionRecord", 'Float'>
    readonly billingMode: FieldRef<"TransactionRecord", 'String'>
    readonly organisationId: FieldRef<"TransactionRecord", 'Int'>
    readonly date: FieldRef<"TransactionRecord", 'DateTime'>
    readonly time: FieldRef<"TransactionRecord", 'DateTime'>
    readonly trackingNumber: FieldRef<"TransactionRecord", 'String'>
    readonly weight: FieldRef<"TransactionRecord", 'Float'>
    readonly customerId: FieldRef<"TransactionRecord", 'Int'>
    readonly status: FieldRef<"TransactionRecord", 'String'>
    readonly notes: FieldRef<"TransactionRecord", 'String'>
    readonly paymentId: FieldRef<"TransactionRecord", 'String'>
    readonly paymentStatus: FieldRef<"TransactionRecord", 'PaymentStatus'>
    readonly isEdited: FieldRef<"TransactionRecord", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TransactionRecord findUnique
   */
  export type TransactionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * Filter, which TransactionRecord to fetch.
     */
    where: TransactionRecordWhereUniqueInput
  }

  /**
   * TransactionRecord findUniqueOrThrow
   */
  export type TransactionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * Filter, which TransactionRecord to fetch.
     */
    where: TransactionRecordWhereUniqueInput
  }

  /**
   * TransactionRecord findFirst
   */
  export type TransactionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * Filter, which TransactionRecord to fetch.
     */
    where?: TransactionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionRecords to fetch.
     */
    orderBy?: TransactionRecordOrderByWithRelationInput | TransactionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionRecords.
     */
    cursor?: TransactionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionRecords.
     */
    distinct?: TransactionRecordScalarFieldEnum | TransactionRecordScalarFieldEnum[]
  }

  /**
   * TransactionRecord findFirstOrThrow
   */
  export type TransactionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * Filter, which TransactionRecord to fetch.
     */
    where?: TransactionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionRecords to fetch.
     */
    orderBy?: TransactionRecordOrderByWithRelationInput | TransactionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionRecords.
     */
    cursor?: TransactionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionRecords.
     */
    distinct?: TransactionRecordScalarFieldEnum | TransactionRecordScalarFieldEnum[]
  }

  /**
   * TransactionRecord findMany
   */
  export type TransactionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * Filter, which TransactionRecords to fetch.
     */
    where?: TransactionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionRecords to fetch.
     */
    orderBy?: TransactionRecordOrderByWithRelationInput | TransactionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionRecords.
     */
    cursor?: TransactionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionRecords.
     */
    skip?: number
    distinct?: TransactionRecordScalarFieldEnum | TransactionRecordScalarFieldEnum[]
  }

  /**
   * TransactionRecord create
   */
  export type TransactionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionRecord.
     */
    data: XOR<TransactionRecordCreateInput, TransactionRecordUncheckedCreateInput>
  }

  /**
   * TransactionRecord createMany
   */
  export type TransactionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionRecords.
     */
    data: TransactionRecordCreateManyInput | TransactionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionRecord update
   */
  export type TransactionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionRecord.
     */
    data: XOR<TransactionRecordUpdateInput, TransactionRecordUncheckedUpdateInput>
    /**
     * Choose, which TransactionRecord to update.
     */
    where: TransactionRecordWhereUniqueInput
  }

  /**
   * TransactionRecord updateMany
   */
  export type TransactionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionRecords.
     */
    data: XOR<TransactionRecordUpdateManyMutationInput, TransactionRecordUncheckedUpdateManyInput>
    /**
     * Filter which TransactionRecords to update
     */
    where?: TransactionRecordWhereInput
    /**
     * Limit how many TransactionRecords to update.
     */
    limit?: number
  }

  /**
   * TransactionRecord upsert
   */
  export type TransactionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionRecord to update in case it exists.
     */
    where: TransactionRecordWhereUniqueInput
    /**
     * In case the TransactionRecord found by the `where` argument doesn't exist, create a new TransactionRecord with this data.
     */
    create: XOR<TransactionRecordCreateInput, TransactionRecordUncheckedCreateInput>
    /**
     * In case the TransactionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionRecordUpdateInput, TransactionRecordUncheckedUpdateInput>
  }

  /**
   * TransactionRecord delete
   */
  export type TransactionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    /**
     * Filter which TransactionRecord to delete.
     */
    where: TransactionRecordWhereUniqueInput
  }

  /**
   * TransactionRecord deleteMany
   */
  export type TransactionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionRecords to delete
     */
    where?: TransactionRecordWhereInput
    /**
     * Limit how many TransactionRecords to delete.
     */
    limit?: number
  }

  /**
   * TransactionRecord.customer
   */
  export type TransactionRecord$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * TransactionRecord.items
   */
  export type TransactionRecord$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    cursor?: TransactionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionRecord.TransactionShipping
   */
  export type TransactionRecord$TransactionShippingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    where?: TransactionShippingWhereInput
    orderBy?: TransactionShippingOrderByWithRelationInput | TransactionShippingOrderByWithRelationInput[]
    cursor?: TransactionShippingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionShippingScalarFieldEnum | TransactionShippingScalarFieldEnum[]
  }

  /**
   * TransactionRecord without action
   */
  export type TransactionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
  }


  /**
   * Model TransactionItem
   */

  export type AggregateTransactionItem = {
    _count: TransactionItemCountAggregateOutputType | null
    _avg: TransactionItemAvgAggregateOutputType | null
    _sum: TransactionItemSumAggregateOutputType | null
    _min: TransactionItemMinAggregateOutputType | null
    _max: TransactionItemMaxAggregateOutputType | null
  }

  export type TransactionItemAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type TransactionItemSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type TransactionItemMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type TransactionItemMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    productId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type TransactionItemCountAggregateOutputType = {
    id: number
    transactionId: number
    productId: number
    quantity: number
    totalPrice: number
    _all: number
  }


  export type TransactionItemAvgAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    totalPrice?: true
  }

  export type TransactionItemSumAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    totalPrice?: true
  }

  export type TransactionItemMinAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    totalPrice?: true
  }

  export type TransactionItemMaxAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    totalPrice?: true
  }

  export type TransactionItemCountAggregateInputType = {
    id?: true
    transactionId?: true
    productId?: true
    quantity?: true
    totalPrice?: true
    _all?: true
  }

  export type TransactionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionItem to aggregate.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionItems
    **/
    _count?: true | TransactionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionItemMaxAggregateInputType
  }

  export type GetTransactionItemAggregateType<T extends TransactionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionItem[P]>
      : GetScalarType<T[P], AggregateTransactionItem[P]>
  }




  export type TransactionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionItemWhereInput
    orderBy?: TransactionItemOrderByWithAggregationInput | TransactionItemOrderByWithAggregationInput[]
    by: TransactionItemScalarFieldEnum[] | TransactionItemScalarFieldEnum
    having?: TransactionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionItemCountAggregateInputType | true
    _avg?: TransactionItemAvgAggregateInputType
    _sum?: TransactionItemSumAggregateInputType
    _min?: TransactionItemMinAggregateInputType
    _max?: TransactionItemMaxAggregateInputType
  }

  export type TransactionItemGroupByOutputType = {
    id: number
    transactionId: number
    productId: number
    quantity: number
    totalPrice: number
    _count: TransactionItemCountAggregateOutputType | null
    _avg: TransactionItemAvgAggregateOutputType | null
    _sum: TransactionItemSumAggregateOutputType | null
    _min: TransactionItemMinAggregateOutputType | null
    _max: TransactionItemMaxAggregateOutputType | null
  }

  type GetTransactionItemGroupByPayload<T extends TransactionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionItemGroupByOutputType[P]>
        }
      >
    >


  export type TransactionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    transaction?: boolean | TransactionRecordDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionItem"]>



  export type TransactionItemSelectScalar = {
    id?: boolean
    transactionId?: boolean
    productId?: boolean
    quantity?: boolean
    totalPrice?: boolean
  }

  export type TransactionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "productId" | "quantity" | "totalPrice", ExtArgs["result"]["transactionItem"]>
  export type TransactionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionRecordDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $TransactionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionItem"
    objects: {
      transaction: Prisma.$TransactionRecordPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      productId: number
      quantity: number
      totalPrice: number
    }, ExtArgs["result"]["transactionItem"]>
    composites: {}
  }

  type TransactionItemGetPayload<S extends boolean | null | undefined | TransactionItemDefaultArgs> = $Result.GetResult<Prisma.$TransactionItemPayload, S>

  type TransactionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionItemCountAggregateInputType | true
    }

  export interface TransactionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionItem'], meta: { name: 'TransactionItem' } }
    /**
     * Find zero or one TransactionItem that matches the filter.
     * @param {TransactionItemFindUniqueArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionItemFindUniqueArgs>(args: SelectSubset<T, TransactionItemFindUniqueArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionItemFindUniqueOrThrowArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindFirstArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionItemFindFirstArgs>(args?: SelectSubset<T, TransactionItemFindFirstArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindFirstOrThrowArgs} args - Arguments to find a TransactionItem
     * @example
     * // Get one TransactionItem
     * const transactionItem = await prisma.transactionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionItems
     * const transactionItems = await prisma.transactionItem.findMany()
     * 
     * // Get first 10 TransactionItems
     * const transactionItems = await prisma.transactionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionItemWithIdOnly = await prisma.transactionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionItemFindManyArgs>(args?: SelectSubset<T, TransactionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionItem.
     * @param {TransactionItemCreateArgs} args - Arguments to create a TransactionItem.
     * @example
     * // Create one TransactionItem
     * const TransactionItem = await prisma.transactionItem.create({
     *   data: {
     *     // ... data to create a TransactionItem
     *   }
     * })
     * 
     */
    create<T extends TransactionItemCreateArgs>(args: SelectSubset<T, TransactionItemCreateArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionItems.
     * @param {TransactionItemCreateManyArgs} args - Arguments to create many TransactionItems.
     * @example
     * // Create many TransactionItems
     * const transactionItem = await prisma.transactionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionItemCreateManyArgs>(args?: SelectSubset<T, TransactionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionItem.
     * @param {TransactionItemDeleteArgs} args - Arguments to delete one TransactionItem.
     * @example
     * // Delete one TransactionItem
     * const TransactionItem = await prisma.transactionItem.delete({
     *   where: {
     *     // ... filter to delete one TransactionItem
     *   }
     * })
     * 
     */
    delete<T extends TransactionItemDeleteArgs>(args: SelectSubset<T, TransactionItemDeleteArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionItem.
     * @param {TransactionItemUpdateArgs} args - Arguments to update one TransactionItem.
     * @example
     * // Update one TransactionItem
     * const transactionItem = await prisma.transactionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionItemUpdateArgs>(args: SelectSubset<T, TransactionItemUpdateArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionItems.
     * @param {TransactionItemDeleteManyArgs} args - Arguments to filter TransactionItems to delete.
     * @example
     * // Delete a few TransactionItems
     * const { count } = await prisma.transactionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionItemDeleteManyArgs>(args?: SelectSubset<T, TransactionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionItems
     * const transactionItem = await prisma.transactionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionItemUpdateManyArgs>(args: SelectSubset<T, TransactionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionItem.
     * @param {TransactionItemUpsertArgs} args - Arguments to update or create a TransactionItem.
     * @example
     * // Update or create a TransactionItem
     * const transactionItem = await prisma.transactionItem.upsert({
     *   create: {
     *     // ... data to create a TransactionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionItem we want to update
     *   }
     * })
     */
    upsert<T extends TransactionItemUpsertArgs>(args: SelectSubset<T, TransactionItemUpsertArgs<ExtArgs>>): Prisma__TransactionItemClient<$Result.GetResult<Prisma.$TransactionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemCountArgs} args - Arguments to filter TransactionItems to count.
     * @example
     * // Count the number of TransactionItems
     * const count = await prisma.transactionItem.count({
     *   where: {
     *     // ... the filter for the TransactionItems we want to count
     *   }
     * })
    **/
    count<T extends TransactionItemCountArgs>(
      args?: Subset<T, TransactionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionItemAggregateArgs>(args: Subset<T, TransactionItemAggregateArgs>): Prisma.PrismaPromise<GetTransactionItemAggregateType<T>>

    /**
     * Group by TransactionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionItemGroupByArgs['orderBy'] }
        : { orderBy?: TransactionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionItem model
   */
  readonly fields: TransactionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionRecordDefaultArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionItem model
   */
  interface TransactionItemFieldRefs {
    readonly id: FieldRef<"TransactionItem", 'Int'>
    readonly transactionId: FieldRef<"TransactionItem", 'Int'>
    readonly productId: FieldRef<"TransactionItem", 'Int'>
    readonly quantity: FieldRef<"TransactionItem", 'Int'>
    readonly totalPrice: FieldRef<"TransactionItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TransactionItem findUnique
   */
  export type TransactionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem findUniqueOrThrow
   */
  export type TransactionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem findFirst
   */
  export type TransactionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionItems.
     */
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem findFirstOrThrow
   */
  export type TransactionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItem to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionItems.
     */
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem findMany
   */
  export type TransactionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter, which TransactionItems to fetch.
     */
    where?: TransactionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionItems to fetch.
     */
    orderBy?: TransactionItemOrderByWithRelationInput | TransactionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionItems.
     */
    cursor?: TransactionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionItems.
     */
    skip?: number
    distinct?: TransactionItemScalarFieldEnum | TransactionItemScalarFieldEnum[]
  }

  /**
   * TransactionItem create
   */
  export type TransactionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionItem.
     */
    data: XOR<TransactionItemCreateInput, TransactionItemUncheckedCreateInput>
  }

  /**
   * TransactionItem createMany
   */
  export type TransactionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionItems.
     */
    data: TransactionItemCreateManyInput | TransactionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionItem update
   */
  export type TransactionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionItem.
     */
    data: XOR<TransactionItemUpdateInput, TransactionItemUncheckedUpdateInput>
    /**
     * Choose, which TransactionItem to update.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem updateMany
   */
  export type TransactionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionItems.
     */
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyInput>
    /**
     * Filter which TransactionItems to update
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to update.
     */
    limit?: number
  }

  /**
   * TransactionItem upsert
   */
  export type TransactionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionItem to update in case it exists.
     */
    where: TransactionItemWhereUniqueInput
    /**
     * In case the TransactionItem found by the `where` argument doesn't exist, create a new TransactionItem with this data.
     */
    create: XOR<TransactionItemCreateInput, TransactionItemUncheckedCreateInput>
    /**
     * In case the TransactionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionItemUpdateInput, TransactionItemUncheckedUpdateInput>
  }

  /**
   * TransactionItem delete
   */
  export type TransactionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
    /**
     * Filter which TransactionItem to delete.
     */
    where: TransactionItemWhereUniqueInput
  }

  /**
   * TransactionItem deleteMany
   */
  export type TransactionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionItems to delete
     */
    where?: TransactionItemWhereInput
    /**
     * Limit how many TransactionItems to delete.
     */
    limit?: number
  }

  /**
   * TransactionItem without action
   */
  export type TransactionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionItem
     */
    select?: TransactionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionItem
     */
    omit?: TransactionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionItemInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    district: string | null
    state: string | null
    pincode: string | null
    email: string | null
    flatNo: string | null
    street: string | null
    organisationId: number | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    district: string | null
    state: string | null
    pincode: string | null
    email: string | null
    flatNo: string | null
    street: string | null
    organisationId: number | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    district: number
    state: number
    pincode: number
    email: number
    flatNo: number
    street: number
    organisationId: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    district?: true
    state?: true
    pincode?: true
    email?: true
    flatNo?: true
    street?: true
    organisationId?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    district?: true
    state?: true
    pincode?: true
    email?: true
    flatNo?: true
    street?: true
    organisationId?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    district?: true
    state?: true
    pincode?: true
    email?: true
    flatNo?: true
    street?: true
    organisationId?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    phone: string
    district: string | null
    state: string | null
    pincode: string | null
    email: string | null
    flatNo: string | null
    street: string | null
    organisationId: number
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    district?: boolean
    state?: boolean
    pincode?: boolean
    email?: boolean
    flatNo?: boolean
    street?: boolean
    organisationId?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    CustomerSubmission?: boolean | Customer$CustomerSubmissionArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    district?: boolean
    state?: boolean
    pincode?: boolean
    email?: boolean
    flatNo?: boolean
    street?: boolean
    organisationId?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "district" | "state" | "pincode" | "email" | "flatNo" | "street" | "organisationId", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    CustomerSubmission?: boolean | Customer$CustomerSubmissionArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
      transactions: Prisma.$TransactionRecordPayload<ExtArgs>[]
      CustomerSubmission: Prisma.$CustomerSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
      district: string | null
      state: string | null
      pincode: string | null
      email: string | null
      flatNo: string | null
      street: string | null
      organisationId: number
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CustomerSubmission<T extends Customer$CustomerSubmissionArgs<ExtArgs> = {}>(args?: Subset<T, Customer$CustomerSubmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly district: FieldRef<"Customer", 'String'>
    readonly state: FieldRef<"Customer", 'String'>
    readonly pincode: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly flatNo: FieldRef<"Customer", 'String'>
    readonly street: FieldRef<"Customer", 'String'>
    readonly organisationId: FieldRef<"Customer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionRecord
     */
    select?: TransactionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionRecord
     */
    omit?: TransactionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionRecordInclude<ExtArgs> | null
    where?: TransactionRecordWhereInput
    orderBy?: TransactionRecordOrderByWithRelationInput | TransactionRecordOrderByWithRelationInput[]
    cursor?: TransactionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionRecordScalarFieldEnum | TransactionRecordScalarFieldEnum[]
  }

  /**
   * Customer.CustomerSubmission
   */
  export type Customer$CustomerSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSubmission
     */
    select?: CustomerSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerSubmission
     */
    omit?: CustomerSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSubmissionInclude<ExtArgs> | null
    where?: CustomerSubmissionWhereInput
    orderBy?: CustomerSubmissionOrderByWithRelationInput | CustomerSubmissionOrderByWithRelationInput[]
    cursor?: CustomerSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerSubmissionScalarFieldEnum | CustomerSubmissionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    categoryId: number | null
    organisationId: number | null
    quantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
    productId: number | null
    categoryId: number | null
    organisationId: number | null
    quantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    productId: number | null
    categoryId: number | null
    organisationId: number | null
    quantity: number | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    categoryId: number | null
    organisationId: number | null
    quantity: number | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    productId: number
    categoryId: number
    organisationId: number
    quantity: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    organisationId?: true
    quantity?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    organisationId?: true
    quantity?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    organisationId?: true
    quantity?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    organisationId?: true
    quantity?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    organisationId?: true
    quantity?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: number
    productId: number
    categoryId: number | null
    organisationId: number
    quantity: number
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    organisationId?: boolean
    quantity?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>



  export type InventorySelectScalar = {
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    organisationId?: boolean
    quantity?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "categoryId" | "organisationId" | "quantity", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | Inventory$categoryArgs<ExtArgs>
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
      organisation: Prisma.$OrganisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      categoryId: number | null
      organisationId: number
      quantity: number
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Inventory$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'Int'>
    readonly productId: FieldRef<"Inventory", 'Int'>
    readonly categoryId: FieldRef<"Inventory", 'Int'>
    readonly organisationId: FieldRef<"Inventory", 'Int'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory.category
   */
  export type Inventory$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionDetails
   */

  export type AggregateSubscriptionDetails = {
    _count: SubscriptionDetailsCountAggregateOutputType | null
    _avg: SubscriptionDetailsAvgAggregateOutputType | null
    _sum: SubscriptionDetailsSumAggregateOutputType | null
    _min: SubscriptionDetailsMinAggregateOutputType | null
    _max: SubscriptionDetailsMaxAggregateOutputType | null
  }

  export type SubscriptionDetailsAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    month: number | null
    year: number | null
    smsCount: number | null
  }

  export type SubscriptionDetailsSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    month: number | null
    year: number | null
    smsCount: number | null
  }

  export type SubscriptionDetailsMinAggregateOutputType = {
    id: number | null
    organisationId: number | null
    date: Date | null
    month: number | null
    year: number | null
    smsCount: number | null
    shopName: string | null
    mobileNumber: string | null
  }

  export type SubscriptionDetailsMaxAggregateOutputType = {
    id: number | null
    organisationId: number | null
    date: Date | null
    month: number | null
    year: number | null
    smsCount: number | null
    shopName: string | null
    mobileNumber: string | null
  }

  export type SubscriptionDetailsCountAggregateOutputType = {
    id: number
    organisationId: number
    date: number
    month: number
    year: number
    smsCount: number
    shopName: number
    mobileNumber: number
    _all: number
  }


  export type SubscriptionDetailsAvgAggregateInputType = {
    id?: true
    organisationId?: true
    month?: true
    year?: true
    smsCount?: true
  }

  export type SubscriptionDetailsSumAggregateInputType = {
    id?: true
    organisationId?: true
    month?: true
    year?: true
    smsCount?: true
  }

  export type SubscriptionDetailsMinAggregateInputType = {
    id?: true
    organisationId?: true
    date?: true
    month?: true
    year?: true
    smsCount?: true
    shopName?: true
    mobileNumber?: true
  }

  export type SubscriptionDetailsMaxAggregateInputType = {
    id?: true
    organisationId?: true
    date?: true
    month?: true
    year?: true
    smsCount?: true
    shopName?: true
    mobileNumber?: true
  }

  export type SubscriptionDetailsCountAggregateInputType = {
    id?: true
    organisationId?: true
    date?: true
    month?: true
    year?: true
    smsCount?: true
    shopName?: true
    mobileNumber?: true
    _all?: true
  }

  export type SubscriptionDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionDetails to aggregate.
     */
    where?: SubscriptionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDetails to fetch.
     */
    orderBy?: SubscriptionDetailsOrderByWithRelationInput | SubscriptionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionDetails
    **/
    _count?: true | SubscriptionDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionDetailsMaxAggregateInputType
  }

  export type GetSubscriptionDetailsAggregateType<T extends SubscriptionDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionDetails[P]>
      : GetScalarType<T[P], AggregateSubscriptionDetails[P]>
  }




  export type SubscriptionDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionDetailsWhereInput
    orderBy?: SubscriptionDetailsOrderByWithAggregationInput | SubscriptionDetailsOrderByWithAggregationInput[]
    by: SubscriptionDetailsScalarFieldEnum[] | SubscriptionDetailsScalarFieldEnum
    having?: SubscriptionDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionDetailsCountAggregateInputType | true
    _avg?: SubscriptionDetailsAvgAggregateInputType
    _sum?: SubscriptionDetailsSumAggregateInputType
    _min?: SubscriptionDetailsMinAggregateInputType
    _max?: SubscriptionDetailsMaxAggregateInputType
  }

  export type SubscriptionDetailsGroupByOutputType = {
    id: number
    organisationId: number
    date: Date
    month: number
    year: number
    smsCount: number
    shopName: string
    mobileNumber: string
    _count: SubscriptionDetailsCountAggregateOutputType | null
    _avg: SubscriptionDetailsAvgAggregateOutputType | null
    _sum: SubscriptionDetailsSumAggregateOutputType | null
    _min: SubscriptionDetailsMinAggregateOutputType | null
    _max: SubscriptionDetailsMaxAggregateOutputType | null
  }

  type GetSubscriptionDetailsGroupByPayload<T extends SubscriptionDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionDetailsGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organisationId?: boolean
    date?: boolean
    month?: boolean
    year?: boolean
    smsCount?: boolean
    shopName?: boolean
    mobileNumber?: boolean
  }, ExtArgs["result"]["subscriptionDetails"]>



  export type SubscriptionDetailsSelectScalar = {
    id?: boolean
    organisationId?: boolean
    date?: boolean
    month?: boolean
    year?: boolean
    smsCount?: boolean
    shopName?: boolean
    mobileNumber?: boolean
  }

  export type SubscriptionDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organisationId" | "date" | "month" | "year" | "smsCount" | "shopName" | "mobileNumber", ExtArgs["result"]["subscriptionDetails"]>

  export type $SubscriptionDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionDetails"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organisationId: number
      date: Date
      month: number
      year: number
      smsCount: number
      shopName: string
      mobileNumber: string
    }, ExtArgs["result"]["subscriptionDetails"]>
    composites: {}
  }

  type SubscriptionDetailsGetPayload<S extends boolean | null | undefined | SubscriptionDetailsDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionDetailsPayload, S>

  type SubscriptionDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionDetailsCountAggregateInputType | true
    }

  export interface SubscriptionDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionDetails'], meta: { name: 'SubscriptionDetails' } }
    /**
     * Find zero or one SubscriptionDetails that matches the filter.
     * @param {SubscriptionDetailsFindUniqueArgs} args - Arguments to find a SubscriptionDetails
     * @example
     * // Get one SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionDetailsFindUniqueArgs>(args: SelectSubset<T, SubscriptionDetailsFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionDetailsFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionDetails
     * @example
     * // Get one SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDetailsFindFirstArgs} args - Arguments to find a SubscriptionDetails
     * @example
     * // Get one SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionDetailsFindFirstArgs>(args?: SelectSubset<T, SubscriptionDetailsFindFirstArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDetailsFindFirstOrThrowArgs} args - Arguments to find a SubscriptionDetails
     * @example
     * // Get one SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.findMany()
     * 
     * // Get first 10 SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionDetailsWithIdOnly = await prisma.subscriptionDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionDetailsFindManyArgs>(args?: SelectSubset<T, SubscriptionDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionDetails.
     * @param {SubscriptionDetailsCreateArgs} args - Arguments to create a SubscriptionDetails.
     * @example
     * // Create one SubscriptionDetails
     * const SubscriptionDetails = await prisma.subscriptionDetails.create({
     *   data: {
     *     // ... data to create a SubscriptionDetails
     *   }
     * })
     * 
     */
    create<T extends SubscriptionDetailsCreateArgs>(args: SelectSubset<T, SubscriptionDetailsCreateArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionDetails.
     * @param {SubscriptionDetailsCreateManyArgs} args - Arguments to create many SubscriptionDetails.
     * @example
     * // Create many SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionDetailsCreateManyArgs>(args?: SelectSubset<T, SubscriptionDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubscriptionDetails.
     * @param {SubscriptionDetailsDeleteArgs} args - Arguments to delete one SubscriptionDetails.
     * @example
     * // Delete one SubscriptionDetails
     * const SubscriptionDetails = await prisma.subscriptionDetails.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionDetails
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDetailsDeleteArgs>(args: SelectSubset<T, SubscriptionDetailsDeleteArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionDetails.
     * @param {SubscriptionDetailsUpdateArgs} args - Arguments to update one SubscriptionDetails.
     * @example
     * // Update one SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionDetailsUpdateArgs>(args: SelectSubset<T, SubscriptionDetailsUpdateArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionDetails.
     * @param {SubscriptionDetailsDeleteManyArgs} args - Arguments to filter SubscriptionDetails to delete.
     * @example
     * // Delete a few SubscriptionDetails
     * const { count } = await prisma.subscriptionDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDetailsDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionDetailsUpdateManyArgs>(args: SelectSubset<T, SubscriptionDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionDetails.
     * @param {SubscriptionDetailsUpsertArgs} args - Arguments to update or create a SubscriptionDetails.
     * @example
     * // Update or create a SubscriptionDetails
     * const subscriptionDetails = await prisma.subscriptionDetails.upsert({
     *   create: {
     *     // ... data to create a SubscriptionDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionDetails we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionDetailsUpsertArgs>(args: SelectSubset<T, SubscriptionDetailsUpsertArgs<ExtArgs>>): Prisma__SubscriptionDetailsClient<$Result.GetResult<Prisma.$SubscriptionDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDetailsCountArgs} args - Arguments to filter SubscriptionDetails to count.
     * @example
     * // Count the number of SubscriptionDetails
     * const count = await prisma.subscriptionDetails.count({
     *   where: {
     *     // ... the filter for the SubscriptionDetails we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionDetailsCountArgs>(
      args?: Subset<T, SubscriptionDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionDetailsAggregateArgs>(args: Subset<T, SubscriptionDetailsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionDetailsAggregateType<T>>

    /**
     * Group by SubscriptionDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionDetailsGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionDetails model
   */
  readonly fields: SubscriptionDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionDetails model
   */
  interface SubscriptionDetailsFieldRefs {
    readonly id: FieldRef<"SubscriptionDetails", 'Int'>
    readonly organisationId: FieldRef<"SubscriptionDetails", 'Int'>
    readonly date: FieldRef<"SubscriptionDetails", 'DateTime'>
    readonly month: FieldRef<"SubscriptionDetails", 'Int'>
    readonly year: FieldRef<"SubscriptionDetails", 'Int'>
    readonly smsCount: FieldRef<"SubscriptionDetails", 'Int'>
    readonly shopName: FieldRef<"SubscriptionDetails", 'String'>
    readonly mobileNumber: FieldRef<"SubscriptionDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionDetails findUnique
   */
  export type SubscriptionDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionDetails to fetch.
     */
    where: SubscriptionDetailsWhereUniqueInput
  }

  /**
   * SubscriptionDetails findUniqueOrThrow
   */
  export type SubscriptionDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionDetails to fetch.
     */
    where: SubscriptionDetailsWhereUniqueInput
  }

  /**
   * SubscriptionDetails findFirst
   */
  export type SubscriptionDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionDetails to fetch.
     */
    where?: SubscriptionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDetails to fetch.
     */
    orderBy?: SubscriptionDetailsOrderByWithRelationInput | SubscriptionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionDetails.
     */
    cursor?: SubscriptionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionDetails.
     */
    distinct?: SubscriptionDetailsScalarFieldEnum | SubscriptionDetailsScalarFieldEnum[]
  }

  /**
   * SubscriptionDetails findFirstOrThrow
   */
  export type SubscriptionDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionDetails to fetch.
     */
    where?: SubscriptionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDetails to fetch.
     */
    orderBy?: SubscriptionDetailsOrderByWithRelationInput | SubscriptionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionDetails.
     */
    cursor?: SubscriptionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionDetails.
     */
    distinct?: SubscriptionDetailsScalarFieldEnum | SubscriptionDetailsScalarFieldEnum[]
  }

  /**
   * SubscriptionDetails findMany
   */
  export type SubscriptionDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * Filter, which SubscriptionDetails to fetch.
     */
    where?: SubscriptionDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionDetails to fetch.
     */
    orderBy?: SubscriptionDetailsOrderByWithRelationInput | SubscriptionDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionDetails.
     */
    cursor?: SubscriptionDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionDetails.
     */
    skip?: number
    distinct?: SubscriptionDetailsScalarFieldEnum | SubscriptionDetailsScalarFieldEnum[]
  }

  /**
   * SubscriptionDetails create
   */
  export type SubscriptionDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionDetails.
     */
    data: XOR<SubscriptionDetailsCreateInput, SubscriptionDetailsUncheckedCreateInput>
  }

  /**
   * SubscriptionDetails createMany
   */
  export type SubscriptionDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionDetails.
     */
    data: SubscriptionDetailsCreateManyInput | SubscriptionDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionDetails update
   */
  export type SubscriptionDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionDetails.
     */
    data: XOR<SubscriptionDetailsUpdateInput, SubscriptionDetailsUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionDetails to update.
     */
    where: SubscriptionDetailsWhereUniqueInput
  }

  /**
   * SubscriptionDetails updateMany
   */
  export type SubscriptionDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionDetails.
     */
    data: XOR<SubscriptionDetailsUpdateManyMutationInput, SubscriptionDetailsUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionDetails to update
     */
    where?: SubscriptionDetailsWhereInput
    /**
     * Limit how many SubscriptionDetails to update.
     */
    limit?: number
  }

  /**
   * SubscriptionDetails upsert
   */
  export type SubscriptionDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionDetails to update in case it exists.
     */
    where: SubscriptionDetailsWhereUniqueInput
    /**
     * In case the SubscriptionDetails found by the `where` argument doesn't exist, create a new SubscriptionDetails with this data.
     */
    create: XOR<SubscriptionDetailsCreateInput, SubscriptionDetailsUncheckedCreateInput>
    /**
     * In case the SubscriptionDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionDetailsUpdateInput, SubscriptionDetailsUncheckedUpdateInput>
  }

  /**
   * SubscriptionDetails delete
   */
  export type SubscriptionDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
    /**
     * Filter which SubscriptionDetails to delete.
     */
    where: SubscriptionDetailsWhereUniqueInput
  }

  /**
   * SubscriptionDetails deleteMany
   */
  export type SubscriptionDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionDetails to delete
     */
    where?: SubscriptionDetailsWhereInput
    /**
     * Limit how many SubscriptionDetails to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionDetails without action
   */
  export type SubscriptionDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionDetails
     */
    select?: SubscriptionDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionDetails
     */
    omit?: SubscriptionDetailsOmit<ExtArgs> | null
  }


  /**
   * Model ShippingMethod
   */

  export type AggregateShippingMethod = {
    _count: ShippingMethodCountAggregateOutputType | null
    _avg: ShippingMethodAvgAggregateOutputType | null
    _sum: ShippingMethodSumAggregateOutputType | null
    _min: ShippingMethodMinAggregateOutputType | null
    _max: ShippingMethodMaxAggregateOutputType | null
  }

  export type ShippingMethodAvgAggregateOutputType = {
    id: number | null
    minAmount: number | null
    ratePerKg: number | null
    fixedRate: number | null
    organisationId: number | null
  }

  export type ShippingMethodSumAggregateOutputType = {
    id: number | null
    minAmount: number | null
    ratePerKg: number | null
    fixedRate: number | null
    organisationId: number | null
  }

  export type ShippingMethodMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.ShippingMethodType | null
    minAmount: number | null
    useWeight: boolean | null
    ratePerKg: number | null
    fixedRate: number | null
    isActive: boolean | null
    organisationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingMethodMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.ShippingMethodType | null
    minAmount: number | null
    useWeight: boolean | null
    ratePerKg: number | null
    fixedRate: number | null
    isActive: boolean | null
    organisationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShippingMethodCountAggregateOutputType = {
    id: number
    name: number
    type: number
    minAmount: number
    useWeight: number
    ratePerKg: number
    fixedRate: number
    isActive: number
    organisationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShippingMethodAvgAggregateInputType = {
    id?: true
    minAmount?: true
    ratePerKg?: true
    fixedRate?: true
    organisationId?: true
  }

  export type ShippingMethodSumAggregateInputType = {
    id?: true
    minAmount?: true
    ratePerKg?: true
    fixedRate?: true
    organisationId?: true
  }

  export type ShippingMethodMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    minAmount?: true
    useWeight?: true
    ratePerKg?: true
    fixedRate?: true
    isActive?: true
    organisationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingMethodMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    minAmount?: true
    useWeight?: true
    ratePerKg?: true
    fixedRate?: true
    isActive?: true
    organisationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShippingMethodCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    minAmount?: true
    useWeight?: true
    ratePerKg?: true
    fixedRate?: true
    isActive?: true
    organisationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShippingMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingMethod to aggregate.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShippingMethods
    **/
    _count?: true | ShippingMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShippingMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShippingMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShippingMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShippingMethodMaxAggregateInputType
  }

  export type GetShippingMethodAggregateType<T extends ShippingMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateShippingMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShippingMethod[P]>
      : GetScalarType<T[P], AggregateShippingMethod[P]>
  }




  export type ShippingMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShippingMethodWhereInput
    orderBy?: ShippingMethodOrderByWithAggregationInput | ShippingMethodOrderByWithAggregationInput[]
    by: ShippingMethodScalarFieldEnum[] | ShippingMethodScalarFieldEnum
    having?: ShippingMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShippingMethodCountAggregateInputType | true
    _avg?: ShippingMethodAvgAggregateInputType
    _sum?: ShippingMethodSumAggregateInputType
    _min?: ShippingMethodMinAggregateInputType
    _max?: ShippingMethodMaxAggregateInputType
  }

  export type ShippingMethodGroupByOutputType = {
    id: number
    name: string
    type: $Enums.ShippingMethodType
    minAmount: number | null
    useWeight: boolean
    ratePerKg: number | null
    fixedRate: number | null
    isActive: boolean
    organisationId: number
    createdAt: Date
    updatedAt: Date
    _count: ShippingMethodCountAggregateOutputType | null
    _avg: ShippingMethodAvgAggregateOutputType | null
    _sum: ShippingMethodSumAggregateOutputType | null
    _min: ShippingMethodMinAggregateOutputType | null
    _max: ShippingMethodMaxAggregateOutputType | null
  }

  type GetShippingMethodGroupByPayload<T extends ShippingMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShippingMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShippingMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShippingMethodGroupByOutputType[P]>
            : GetScalarType<T[P], ShippingMethodGroupByOutputType[P]>
        }
      >
    >


  export type ShippingMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    minAmount?: boolean
    useWeight?: boolean
    ratePerKg?: boolean
    fixedRate?: boolean
    isActive?: boolean
    organisationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shippingMethod"]>



  export type ShippingMethodSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    minAmount?: boolean
    useWeight?: boolean
    ratePerKg?: boolean
    fixedRate?: boolean
    isActive?: boolean
    organisationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShippingMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "minAmount" | "useWeight" | "ratePerKg" | "fixedRate" | "isActive" | "organisationId" | "createdAt" | "updatedAt", ExtArgs["result"]["shippingMethod"]>
  export type ShippingMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }

  export type $ShippingMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShippingMethod"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: $Enums.ShippingMethodType
      minAmount: number | null
      useWeight: boolean
      ratePerKg: number | null
      fixedRate: number | null
      isActive: boolean
      organisationId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shippingMethod"]>
    composites: {}
  }

  type ShippingMethodGetPayload<S extends boolean | null | undefined | ShippingMethodDefaultArgs> = $Result.GetResult<Prisma.$ShippingMethodPayload, S>

  type ShippingMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShippingMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShippingMethodCountAggregateInputType | true
    }

  export interface ShippingMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShippingMethod'], meta: { name: 'ShippingMethod' } }
    /**
     * Find zero or one ShippingMethod that matches the filter.
     * @param {ShippingMethodFindUniqueArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShippingMethodFindUniqueArgs>(args: SelectSubset<T, ShippingMethodFindUniqueArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShippingMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShippingMethodFindUniqueOrThrowArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShippingMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, ShippingMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodFindFirstArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShippingMethodFindFirstArgs>(args?: SelectSubset<T, ShippingMethodFindFirstArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShippingMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodFindFirstOrThrowArgs} args - Arguments to find a ShippingMethod
     * @example
     * // Get one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShippingMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, ShippingMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShippingMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShippingMethods
     * const shippingMethods = await prisma.shippingMethod.findMany()
     * 
     * // Get first 10 ShippingMethods
     * const shippingMethods = await prisma.shippingMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shippingMethodWithIdOnly = await prisma.shippingMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShippingMethodFindManyArgs>(args?: SelectSubset<T, ShippingMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShippingMethod.
     * @param {ShippingMethodCreateArgs} args - Arguments to create a ShippingMethod.
     * @example
     * // Create one ShippingMethod
     * const ShippingMethod = await prisma.shippingMethod.create({
     *   data: {
     *     // ... data to create a ShippingMethod
     *   }
     * })
     * 
     */
    create<T extends ShippingMethodCreateArgs>(args: SelectSubset<T, ShippingMethodCreateArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShippingMethods.
     * @param {ShippingMethodCreateManyArgs} args - Arguments to create many ShippingMethods.
     * @example
     * // Create many ShippingMethods
     * const shippingMethod = await prisma.shippingMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShippingMethodCreateManyArgs>(args?: SelectSubset<T, ShippingMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShippingMethod.
     * @param {ShippingMethodDeleteArgs} args - Arguments to delete one ShippingMethod.
     * @example
     * // Delete one ShippingMethod
     * const ShippingMethod = await prisma.shippingMethod.delete({
     *   where: {
     *     // ... filter to delete one ShippingMethod
     *   }
     * })
     * 
     */
    delete<T extends ShippingMethodDeleteArgs>(args: SelectSubset<T, ShippingMethodDeleteArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShippingMethod.
     * @param {ShippingMethodUpdateArgs} args - Arguments to update one ShippingMethod.
     * @example
     * // Update one ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShippingMethodUpdateArgs>(args: SelectSubset<T, ShippingMethodUpdateArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShippingMethods.
     * @param {ShippingMethodDeleteManyArgs} args - Arguments to filter ShippingMethods to delete.
     * @example
     * // Delete a few ShippingMethods
     * const { count } = await prisma.shippingMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShippingMethodDeleteManyArgs>(args?: SelectSubset<T, ShippingMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShippingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShippingMethods
     * const shippingMethod = await prisma.shippingMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShippingMethodUpdateManyArgs>(args: SelectSubset<T, ShippingMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShippingMethod.
     * @param {ShippingMethodUpsertArgs} args - Arguments to update or create a ShippingMethod.
     * @example
     * // Update or create a ShippingMethod
     * const shippingMethod = await prisma.shippingMethod.upsert({
     *   create: {
     *     // ... data to create a ShippingMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShippingMethod we want to update
     *   }
     * })
     */
    upsert<T extends ShippingMethodUpsertArgs>(args: SelectSubset<T, ShippingMethodUpsertArgs<ExtArgs>>): Prisma__ShippingMethodClient<$Result.GetResult<Prisma.$ShippingMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShippingMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodCountArgs} args - Arguments to filter ShippingMethods to count.
     * @example
     * // Count the number of ShippingMethods
     * const count = await prisma.shippingMethod.count({
     *   where: {
     *     // ... the filter for the ShippingMethods we want to count
     *   }
     * })
    **/
    count<T extends ShippingMethodCountArgs>(
      args?: Subset<T, ShippingMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShippingMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShippingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShippingMethodAggregateArgs>(args: Subset<T, ShippingMethodAggregateArgs>): Prisma.PrismaPromise<GetShippingMethodAggregateType<T>>

    /**
     * Group by ShippingMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShippingMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShippingMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShippingMethodGroupByArgs['orderBy'] }
        : { orderBy?: ShippingMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShippingMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShippingMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShippingMethod model
   */
  readonly fields: ShippingMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShippingMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShippingMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShippingMethod model
   */
  interface ShippingMethodFieldRefs {
    readonly id: FieldRef<"ShippingMethod", 'Int'>
    readonly name: FieldRef<"ShippingMethod", 'String'>
    readonly type: FieldRef<"ShippingMethod", 'ShippingMethodType'>
    readonly minAmount: FieldRef<"ShippingMethod", 'Float'>
    readonly useWeight: FieldRef<"ShippingMethod", 'Boolean'>
    readonly ratePerKg: FieldRef<"ShippingMethod", 'Float'>
    readonly fixedRate: FieldRef<"ShippingMethod", 'Float'>
    readonly isActive: FieldRef<"ShippingMethod", 'Boolean'>
    readonly organisationId: FieldRef<"ShippingMethod", 'Int'>
    readonly createdAt: FieldRef<"ShippingMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"ShippingMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShippingMethod findUnique
   */
  export type ShippingMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod findUniqueOrThrow
   */
  export type ShippingMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod findFirst
   */
  export type ShippingMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingMethods.
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingMethods.
     */
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * ShippingMethod findFirstOrThrow
   */
  export type ShippingMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethod to fetch.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShippingMethods.
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShippingMethods.
     */
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * ShippingMethod findMany
   */
  export type ShippingMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter, which ShippingMethods to fetch.
     */
    where?: ShippingMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShippingMethods to fetch.
     */
    orderBy?: ShippingMethodOrderByWithRelationInput | ShippingMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShippingMethods.
     */
    cursor?: ShippingMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShippingMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShippingMethods.
     */
    skip?: number
    distinct?: ShippingMethodScalarFieldEnum | ShippingMethodScalarFieldEnum[]
  }

  /**
   * ShippingMethod create
   */
  export type ShippingMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a ShippingMethod.
     */
    data: XOR<ShippingMethodCreateInput, ShippingMethodUncheckedCreateInput>
  }

  /**
   * ShippingMethod createMany
   */
  export type ShippingMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShippingMethods.
     */
    data: ShippingMethodCreateManyInput | ShippingMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShippingMethod update
   */
  export type ShippingMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a ShippingMethod.
     */
    data: XOR<ShippingMethodUpdateInput, ShippingMethodUncheckedUpdateInput>
    /**
     * Choose, which ShippingMethod to update.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod updateMany
   */
  export type ShippingMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShippingMethods.
     */
    data: XOR<ShippingMethodUpdateManyMutationInput, ShippingMethodUncheckedUpdateManyInput>
    /**
     * Filter which ShippingMethods to update
     */
    where?: ShippingMethodWhereInput
    /**
     * Limit how many ShippingMethods to update.
     */
    limit?: number
  }

  /**
   * ShippingMethod upsert
   */
  export type ShippingMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the ShippingMethod to update in case it exists.
     */
    where: ShippingMethodWhereUniqueInput
    /**
     * In case the ShippingMethod found by the `where` argument doesn't exist, create a new ShippingMethod with this data.
     */
    create: XOR<ShippingMethodCreateInput, ShippingMethodUncheckedCreateInput>
    /**
     * In case the ShippingMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShippingMethodUpdateInput, ShippingMethodUncheckedUpdateInput>
  }

  /**
   * ShippingMethod delete
   */
  export type ShippingMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
    /**
     * Filter which ShippingMethod to delete.
     */
    where: ShippingMethodWhereUniqueInput
  }

  /**
   * ShippingMethod deleteMany
   */
  export type ShippingMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShippingMethods to delete
     */
    where?: ShippingMethodWhereInput
    /**
     * Limit how many ShippingMethods to delete.
     */
    limit?: number
  }

  /**
   * ShippingMethod without action
   */
  export type ShippingMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShippingMethod
     */
    select?: ShippingMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShippingMethod
     */
    omit?: ShippingMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShippingMethodInclude<ExtArgs> | null
  }


  /**
   * Model TransactionShipping
   */

  export type AggregateTransactionShipping = {
    _count: TransactionShippingCountAggregateOutputType | null
    _avg: TransactionShippingAvgAggregateOutputType | null
    _sum: TransactionShippingSumAggregateOutputType | null
    _min: TransactionShippingMinAggregateOutputType | null
    _max: TransactionShippingMaxAggregateOutputType | null
  }

  export type TransactionShippingAvgAggregateOutputType = {
    id: number | null
    transactionId: number | null
    baseRate: number | null
    weightCharge: number | null
    totalWeight: number | null
    totalCost: number | null
  }

  export type TransactionShippingSumAggregateOutputType = {
    id: number | null
    transactionId: number | null
    baseRate: number | null
    weightCharge: number | null
    totalWeight: number | null
    totalCost: number | null
  }

  export type TransactionShippingMinAggregateOutputType = {
    id: number | null
    transactionId: number | null
    methodName: string | null
    methodType: $Enums.ShippingMethodType | null
    baseRate: number | null
    weightCharge: number | null
    totalWeight: number | null
    totalCost: number | null
  }

  export type TransactionShippingMaxAggregateOutputType = {
    id: number | null
    transactionId: number | null
    methodName: string | null
    methodType: $Enums.ShippingMethodType | null
    baseRate: number | null
    weightCharge: number | null
    totalWeight: number | null
    totalCost: number | null
  }

  export type TransactionShippingCountAggregateOutputType = {
    id: number
    transactionId: number
    methodName: number
    methodType: number
    baseRate: number
    weightCharge: number
    totalWeight: number
    totalCost: number
    _all: number
  }


  export type TransactionShippingAvgAggregateInputType = {
    id?: true
    transactionId?: true
    baseRate?: true
    weightCharge?: true
    totalWeight?: true
    totalCost?: true
  }

  export type TransactionShippingSumAggregateInputType = {
    id?: true
    transactionId?: true
    baseRate?: true
    weightCharge?: true
    totalWeight?: true
    totalCost?: true
  }

  export type TransactionShippingMinAggregateInputType = {
    id?: true
    transactionId?: true
    methodName?: true
    methodType?: true
    baseRate?: true
    weightCharge?: true
    totalWeight?: true
    totalCost?: true
  }

  export type TransactionShippingMaxAggregateInputType = {
    id?: true
    transactionId?: true
    methodName?: true
    methodType?: true
    baseRate?: true
    weightCharge?: true
    totalWeight?: true
    totalCost?: true
  }

  export type TransactionShippingCountAggregateInputType = {
    id?: true
    transactionId?: true
    methodName?: true
    methodType?: true
    baseRate?: true
    weightCharge?: true
    totalWeight?: true
    totalCost?: true
    _all?: true
  }

  export type TransactionShippingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionShipping to aggregate.
     */
    where?: TransactionShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionShippings to fetch.
     */
    orderBy?: TransactionShippingOrderByWithRelationInput | TransactionShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionShippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionShippings
    **/
    _count?: true | TransactionShippingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionShippingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionShippingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionShippingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionShippingMaxAggregateInputType
  }

  export type GetTransactionShippingAggregateType<T extends TransactionShippingAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionShipping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionShipping[P]>
      : GetScalarType<T[P], AggregateTransactionShipping[P]>
  }




  export type TransactionShippingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionShippingWhereInput
    orderBy?: TransactionShippingOrderByWithAggregationInput | TransactionShippingOrderByWithAggregationInput[]
    by: TransactionShippingScalarFieldEnum[] | TransactionShippingScalarFieldEnum
    having?: TransactionShippingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionShippingCountAggregateInputType | true
    _avg?: TransactionShippingAvgAggregateInputType
    _sum?: TransactionShippingSumAggregateInputType
    _min?: TransactionShippingMinAggregateInputType
    _max?: TransactionShippingMaxAggregateInputType
  }

  export type TransactionShippingGroupByOutputType = {
    id: number
    transactionId: number
    methodName: string
    methodType: $Enums.ShippingMethodType
    baseRate: number | null
    weightCharge: number | null
    totalWeight: number | null
    totalCost: number
    _count: TransactionShippingCountAggregateOutputType | null
    _avg: TransactionShippingAvgAggregateOutputType | null
    _sum: TransactionShippingSumAggregateOutputType | null
    _min: TransactionShippingMinAggregateOutputType | null
    _max: TransactionShippingMaxAggregateOutputType | null
  }

  type GetTransactionShippingGroupByPayload<T extends TransactionShippingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionShippingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionShippingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionShippingGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionShippingGroupByOutputType[P]>
        }
      >
    >


  export type TransactionShippingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    methodName?: boolean
    methodType?: boolean
    baseRate?: boolean
    weightCharge?: boolean
    totalWeight?: boolean
    totalCost?: boolean
    transaction?: boolean | TransactionRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionShipping"]>



  export type TransactionShippingSelectScalar = {
    id?: boolean
    transactionId?: boolean
    methodName?: boolean
    methodType?: boolean
    baseRate?: boolean
    weightCharge?: boolean
    totalWeight?: boolean
    totalCost?: boolean
  }

  export type TransactionShippingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "methodName" | "methodType" | "baseRate" | "weightCharge" | "totalWeight" | "totalCost", ExtArgs["result"]["transactionShipping"]>
  export type TransactionShippingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionRecordDefaultArgs<ExtArgs>
  }

  export type $TransactionShippingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionShipping"
    objects: {
      transaction: Prisma.$TransactionRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transactionId: number
      methodName: string
      methodType: $Enums.ShippingMethodType
      baseRate: number | null
      weightCharge: number | null
      totalWeight: number | null
      totalCost: number
    }, ExtArgs["result"]["transactionShipping"]>
    composites: {}
  }

  type TransactionShippingGetPayload<S extends boolean | null | undefined | TransactionShippingDefaultArgs> = $Result.GetResult<Prisma.$TransactionShippingPayload, S>

  type TransactionShippingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionShippingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionShippingCountAggregateInputType | true
    }

  export interface TransactionShippingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionShipping'], meta: { name: 'TransactionShipping' } }
    /**
     * Find zero or one TransactionShipping that matches the filter.
     * @param {TransactionShippingFindUniqueArgs} args - Arguments to find a TransactionShipping
     * @example
     * // Get one TransactionShipping
     * const transactionShipping = await prisma.transactionShipping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionShippingFindUniqueArgs>(args: SelectSubset<T, TransactionShippingFindUniqueArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionShipping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionShippingFindUniqueOrThrowArgs} args - Arguments to find a TransactionShipping
     * @example
     * // Get one TransactionShipping
     * const transactionShipping = await prisma.transactionShipping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionShippingFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionShippingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionShipping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionShippingFindFirstArgs} args - Arguments to find a TransactionShipping
     * @example
     * // Get one TransactionShipping
     * const transactionShipping = await prisma.transactionShipping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionShippingFindFirstArgs>(args?: SelectSubset<T, TransactionShippingFindFirstArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionShipping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionShippingFindFirstOrThrowArgs} args - Arguments to find a TransactionShipping
     * @example
     * // Get one TransactionShipping
     * const transactionShipping = await prisma.transactionShipping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionShippingFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionShippingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionShippings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionShippingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionShippings
     * const transactionShippings = await prisma.transactionShipping.findMany()
     * 
     * // Get first 10 TransactionShippings
     * const transactionShippings = await prisma.transactionShipping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionShippingWithIdOnly = await prisma.transactionShipping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionShippingFindManyArgs>(args?: SelectSubset<T, TransactionShippingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionShipping.
     * @param {TransactionShippingCreateArgs} args - Arguments to create a TransactionShipping.
     * @example
     * // Create one TransactionShipping
     * const TransactionShipping = await prisma.transactionShipping.create({
     *   data: {
     *     // ... data to create a TransactionShipping
     *   }
     * })
     * 
     */
    create<T extends TransactionShippingCreateArgs>(args: SelectSubset<T, TransactionShippingCreateArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionShippings.
     * @param {TransactionShippingCreateManyArgs} args - Arguments to create many TransactionShippings.
     * @example
     * // Create many TransactionShippings
     * const transactionShipping = await prisma.transactionShipping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionShippingCreateManyArgs>(args?: SelectSubset<T, TransactionShippingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionShipping.
     * @param {TransactionShippingDeleteArgs} args - Arguments to delete one TransactionShipping.
     * @example
     * // Delete one TransactionShipping
     * const TransactionShipping = await prisma.transactionShipping.delete({
     *   where: {
     *     // ... filter to delete one TransactionShipping
     *   }
     * })
     * 
     */
    delete<T extends TransactionShippingDeleteArgs>(args: SelectSubset<T, TransactionShippingDeleteArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionShipping.
     * @param {TransactionShippingUpdateArgs} args - Arguments to update one TransactionShipping.
     * @example
     * // Update one TransactionShipping
     * const transactionShipping = await prisma.transactionShipping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionShippingUpdateArgs>(args: SelectSubset<T, TransactionShippingUpdateArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionShippings.
     * @param {TransactionShippingDeleteManyArgs} args - Arguments to filter TransactionShippings to delete.
     * @example
     * // Delete a few TransactionShippings
     * const { count } = await prisma.transactionShipping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionShippingDeleteManyArgs>(args?: SelectSubset<T, TransactionShippingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionShippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionShippingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionShippings
     * const transactionShipping = await prisma.transactionShipping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionShippingUpdateManyArgs>(args: SelectSubset<T, TransactionShippingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionShipping.
     * @param {TransactionShippingUpsertArgs} args - Arguments to update or create a TransactionShipping.
     * @example
     * // Update or create a TransactionShipping
     * const transactionShipping = await prisma.transactionShipping.upsert({
     *   create: {
     *     // ... data to create a TransactionShipping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionShipping we want to update
     *   }
     * })
     */
    upsert<T extends TransactionShippingUpsertArgs>(args: SelectSubset<T, TransactionShippingUpsertArgs<ExtArgs>>): Prisma__TransactionShippingClient<$Result.GetResult<Prisma.$TransactionShippingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionShippings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionShippingCountArgs} args - Arguments to filter TransactionShippings to count.
     * @example
     * // Count the number of TransactionShippings
     * const count = await prisma.transactionShipping.count({
     *   where: {
     *     // ... the filter for the TransactionShippings we want to count
     *   }
     * })
    **/
    count<T extends TransactionShippingCountArgs>(
      args?: Subset<T, TransactionShippingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionShippingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionShipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionShippingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionShippingAggregateArgs>(args: Subset<T, TransactionShippingAggregateArgs>): Prisma.PrismaPromise<GetTransactionShippingAggregateType<T>>

    /**
     * Group by TransactionShipping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionShippingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionShippingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionShippingGroupByArgs['orderBy'] }
        : { orderBy?: TransactionShippingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionShippingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionShippingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionShipping model
   */
  readonly fields: TransactionShippingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionShipping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionShippingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionRecordDefaultArgs<ExtArgs>>): Prisma__TransactionRecordClient<$Result.GetResult<Prisma.$TransactionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionShipping model
   */
  interface TransactionShippingFieldRefs {
    readonly id: FieldRef<"TransactionShipping", 'Int'>
    readonly transactionId: FieldRef<"TransactionShipping", 'Int'>
    readonly methodName: FieldRef<"TransactionShipping", 'String'>
    readonly methodType: FieldRef<"TransactionShipping", 'ShippingMethodType'>
    readonly baseRate: FieldRef<"TransactionShipping", 'Float'>
    readonly weightCharge: FieldRef<"TransactionShipping", 'Float'>
    readonly totalWeight: FieldRef<"TransactionShipping", 'Float'>
    readonly totalCost: FieldRef<"TransactionShipping", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TransactionShipping findUnique
   */
  export type TransactionShippingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * Filter, which TransactionShipping to fetch.
     */
    where: TransactionShippingWhereUniqueInput
  }

  /**
   * TransactionShipping findUniqueOrThrow
   */
  export type TransactionShippingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * Filter, which TransactionShipping to fetch.
     */
    where: TransactionShippingWhereUniqueInput
  }

  /**
   * TransactionShipping findFirst
   */
  export type TransactionShippingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * Filter, which TransactionShipping to fetch.
     */
    where?: TransactionShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionShippings to fetch.
     */
    orderBy?: TransactionShippingOrderByWithRelationInput | TransactionShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionShippings.
     */
    cursor?: TransactionShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionShippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionShippings.
     */
    distinct?: TransactionShippingScalarFieldEnum | TransactionShippingScalarFieldEnum[]
  }

  /**
   * TransactionShipping findFirstOrThrow
   */
  export type TransactionShippingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * Filter, which TransactionShipping to fetch.
     */
    where?: TransactionShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionShippings to fetch.
     */
    orderBy?: TransactionShippingOrderByWithRelationInput | TransactionShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionShippings.
     */
    cursor?: TransactionShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionShippings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionShippings.
     */
    distinct?: TransactionShippingScalarFieldEnum | TransactionShippingScalarFieldEnum[]
  }

  /**
   * TransactionShipping findMany
   */
  export type TransactionShippingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * Filter, which TransactionShippings to fetch.
     */
    where?: TransactionShippingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionShippings to fetch.
     */
    orderBy?: TransactionShippingOrderByWithRelationInput | TransactionShippingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionShippings.
     */
    cursor?: TransactionShippingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionShippings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionShippings.
     */
    skip?: number
    distinct?: TransactionShippingScalarFieldEnum | TransactionShippingScalarFieldEnum[]
  }

  /**
   * TransactionShipping create
   */
  export type TransactionShippingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionShipping.
     */
    data: XOR<TransactionShippingCreateInput, TransactionShippingUncheckedCreateInput>
  }

  /**
   * TransactionShipping createMany
   */
  export type TransactionShippingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionShippings.
     */
    data: TransactionShippingCreateManyInput | TransactionShippingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionShipping update
   */
  export type TransactionShippingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionShipping.
     */
    data: XOR<TransactionShippingUpdateInput, TransactionShippingUncheckedUpdateInput>
    /**
     * Choose, which TransactionShipping to update.
     */
    where: TransactionShippingWhereUniqueInput
  }

  /**
   * TransactionShipping updateMany
   */
  export type TransactionShippingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionShippings.
     */
    data: XOR<TransactionShippingUpdateManyMutationInput, TransactionShippingUncheckedUpdateManyInput>
    /**
     * Filter which TransactionShippings to update
     */
    where?: TransactionShippingWhereInput
    /**
     * Limit how many TransactionShippings to update.
     */
    limit?: number
  }

  /**
   * TransactionShipping upsert
   */
  export type TransactionShippingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionShipping to update in case it exists.
     */
    where: TransactionShippingWhereUniqueInput
    /**
     * In case the TransactionShipping found by the `where` argument doesn't exist, create a new TransactionShipping with this data.
     */
    create: XOR<TransactionShippingCreateInput, TransactionShippingUncheckedCreateInput>
    /**
     * In case the TransactionShipping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionShippingUpdateInput, TransactionShippingUncheckedUpdateInput>
  }

  /**
   * TransactionShipping delete
   */
  export type TransactionShippingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
    /**
     * Filter which TransactionShipping to delete.
     */
    where: TransactionShippingWhereUniqueInput
  }

  /**
   * TransactionShipping deleteMany
   */
  export type TransactionShippingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionShippings to delete
     */
    where?: TransactionShippingWhereInput
    /**
     * Limit how many TransactionShippings to delete.
     */
    limit?: number
  }

  /**
   * TransactionShipping without action
   */
  export type TransactionShippingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionShipping
     */
    select?: TransactionShippingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionShipping
     */
    omit?: TransactionShippingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionShippingInclude<ExtArgs> | null
  }


  /**
   * Model Mandate
   */

  export type AggregateMandate = {
    _count: MandateCountAggregateOutputType | null
    _avg: MandateAvgAggregateOutputType | null
    _sum: MandateSumAggregateOutputType | null
    _min: MandateMinAggregateOutputType | null
    _max: MandateMaxAggregateOutputType | null
  }

  export type MandateAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    amount: number | null
  }

  export type MandateSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    amount: number | null
  }

  export type MandateMinAggregateOutputType = {
    id: number | null
    organisationId: number | null
    merchantTranId: string | null
    bankRRN: string | null
    UMN: string | null
    amount: number | null
    status: string | null
    payerVA: string | null
    payerName: string | null
    payerMobile: string | null
    txnInitDate: Date | null
    txnCompletionDate: Date | null
    responseCode: string | null
    respCodeDescription: string | null
  }

  export type MandateMaxAggregateOutputType = {
    id: number | null
    organisationId: number | null
    merchantTranId: string | null
    bankRRN: string | null
    UMN: string | null
    amount: number | null
    status: string | null
    payerVA: string | null
    payerName: string | null
    payerMobile: string | null
    txnInitDate: Date | null
    txnCompletionDate: Date | null
    responseCode: string | null
    respCodeDescription: string | null
  }

  export type MandateCountAggregateOutputType = {
    id: number
    organisationId: number
    merchantTranId: number
    bankRRN: number
    UMN: number
    amount: number
    status: number
    payerVA: number
    payerName: number
    payerMobile: number
    txnInitDate: number
    txnCompletionDate: number
    responseCode: number
    respCodeDescription: number
    _all: number
  }


  export type MandateAvgAggregateInputType = {
    id?: true
    organisationId?: true
    amount?: true
  }

  export type MandateSumAggregateInputType = {
    id?: true
    organisationId?: true
    amount?: true
  }

  export type MandateMinAggregateInputType = {
    id?: true
    organisationId?: true
    merchantTranId?: true
    bankRRN?: true
    UMN?: true
    amount?: true
    status?: true
    payerVA?: true
    payerName?: true
    payerMobile?: true
    txnInitDate?: true
    txnCompletionDate?: true
    responseCode?: true
    respCodeDescription?: true
  }

  export type MandateMaxAggregateInputType = {
    id?: true
    organisationId?: true
    merchantTranId?: true
    bankRRN?: true
    UMN?: true
    amount?: true
    status?: true
    payerVA?: true
    payerName?: true
    payerMobile?: true
    txnInitDate?: true
    txnCompletionDate?: true
    responseCode?: true
    respCodeDescription?: true
  }

  export type MandateCountAggregateInputType = {
    id?: true
    organisationId?: true
    merchantTranId?: true
    bankRRN?: true
    UMN?: true
    amount?: true
    status?: true
    payerVA?: true
    payerName?: true
    payerMobile?: true
    txnInitDate?: true
    txnCompletionDate?: true
    responseCode?: true
    respCodeDescription?: true
    _all?: true
  }

  export type MandateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mandate to aggregate.
     */
    where?: MandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mandates to fetch.
     */
    orderBy?: MandateOrderByWithRelationInput | MandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mandates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mandates
    **/
    _count?: true | MandateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MandateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MandateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MandateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MandateMaxAggregateInputType
  }

  export type GetMandateAggregateType<T extends MandateAggregateArgs> = {
        [P in keyof T & keyof AggregateMandate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMandate[P]>
      : GetScalarType<T[P], AggregateMandate[P]>
  }




  export type MandateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MandateWhereInput
    orderBy?: MandateOrderByWithAggregationInput | MandateOrderByWithAggregationInput[]
    by: MandateScalarFieldEnum[] | MandateScalarFieldEnum
    having?: MandateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MandateCountAggregateInputType | true
    _avg?: MandateAvgAggregateInputType
    _sum?: MandateSumAggregateInputType
    _min?: MandateMinAggregateInputType
    _max?: MandateMaxAggregateInputType
  }

  export type MandateGroupByOutputType = {
    id: number
    organisationId: number
    merchantTranId: string
    bankRRN: string | null
    UMN: string | null
    amount: number
    status: string
    payerVA: string
    payerName: string | null
    payerMobile: string | null
    txnInitDate: Date | null
    txnCompletionDate: Date | null
    responseCode: string | null
    respCodeDescription: string | null
    _count: MandateCountAggregateOutputType | null
    _avg: MandateAvgAggregateOutputType | null
    _sum: MandateSumAggregateOutputType | null
    _min: MandateMinAggregateOutputType | null
    _max: MandateMaxAggregateOutputType | null
  }

  type GetMandateGroupByPayload<T extends MandateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MandateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MandateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MandateGroupByOutputType[P]>
            : GetScalarType<T[P], MandateGroupByOutputType[P]>
        }
      >
    >


  export type MandateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organisationId?: boolean
    merchantTranId?: boolean
    bankRRN?: boolean
    UMN?: boolean
    amount?: boolean
    status?: boolean
    payerVA?: boolean
    payerName?: boolean
    payerMobile?: boolean
    txnInitDate?: boolean
    txnCompletionDate?: boolean
    responseCode?: boolean
    respCodeDescription?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mandate"]>



  export type MandateSelectScalar = {
    id?: boolean
    organisationId?: boolean
    merchantTranId?: boolean
    bankRRN?: boolean
    UMN?: boolean
    amount?: boolean
    status?: boolean
    payerVA?: boolean
    payerName?: boolean
    payerMobile?: boolean
    txnInitDate?: boolean
    txnCompletionDate?: boolean
    responseCode?: boolean
    respCodeDescription?: boolean
  }

  export type MandateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organisationId" | "merchantTranId" | "bankRRN" | "UMN" | "amount" | "status" | "payerVA" | "payerName" | "payerMobile" | "txnInitDate" | "txnCompletionDate" | "responseCode" | "respCodeDescription", ExtArgs["result"]["mandate"]>
  export type MandateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }

  export type $MandatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mandate"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organisationId: number
      merchantTranId: string
      bankRRN: string | null
      UMN: string | null
      amount: number
      status: string
      payerVA: string
      payerName: string | null
      payerMobile: string | null
      txnInitDate: Date | null
      txnCompletionDate: Date | null
      responseCode: string | null
      respCodeDescription: string | null
    }, ExtArgs["result"]["mandate"]>
    composites: {}
  }

  type MandateGetPayload<S extends boolean | null | undefined | MandateDefaultArgs> = $Result.GetResult<Prisma.$MandatePayload, S>

  type MandateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MandateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MandateCountAggregateInputType | true
    }

  export interface MandateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mandate'], meta: { name: 'Mandate' } }
    /**
     * Find zero or one Mandate that matches the filter.
     * @param {MandateFindUniqueArgs} args - Arguments to find a Mandate
     * @example
     * // Get one Mandate
     * const mandate = await prisma.mandate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MandateFindUniqueArgs>(args: SelectSubset<T, MandateFindUniqueArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mandate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MandateFindUniqueOrThrowArgs} args - Arguments to find a Mandate
     * @example
     * // Get one Mandate
     * const mandate = await prisma.mandate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MandateFindUniqueOrThrowArgs>(args: SelectSubset<T, MandateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mandate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateFindFirstArgs} args - Arguments to find a Mandate
     * @example
     * // Get one Mandate
     * const mandate = await prisma.mandate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MandateFindFirstArgs>(args?: SelectSubset<T, MandateFindFirstArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mandate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateFindFirstOrThrowArgs} args - Arguments to find a Mandate
     * @example
     * // Get one Mandate
     * const mandate = await prisma.mandate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MandateFindFirstOrThrowArgs>(args?: SelectSubset<T, MandateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mandates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mandates
     * const mandates = await prisma.mandate.findMany()
     * 
     * // Get first 10 Mandates
     * const mandates = await prisma.mandate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mandateWithIdOnly = await prisma.mandate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MandateFindManyArgs>(args?: SelectSubset<T, MandateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mandate.
     * @param {MandateCreateArgs} args - Arguments to create a Mandate.
     * @example
     * // Create one Mandate
     * const Mandate = await prisma.mandate.create({
     *   data: {
     *     // ... data to create a Mandate
     *   }
     * })
     * 
     */
    create<T extends MandateCreateArgs>(args: SelectSubset<T, MandateCreateArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mandates.
     * @param {MandateCreateManyArgs} args - Arguments to create many Mandates.
     * @example
     * // Create many Mandates
     * const mandate = await prisma.mandate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MandateCreateManyArgs>(args?: SelectSubset<T, MandateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mandate.
     * @param {MandateDeleteArgs} args - Arguments to delete one Mandate.
     * @example
     * // Delete one Mandate
     * const Mandate = await prisma.mandate.delete({
     *   where: {
     *     // ... filter to delete one Mandate
     *   }
     * })
     * 
     */
    delete<T extends MandateDeleteArgs>(args: SelectSubset<T, MandateDeleteArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mandate.
     * @param {MandateUpdateArgs} args - Arguments to update one Mandate.
     * @example
     * // Update one Mandate
     * const mandate = await prisma.mandate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MandateUpdateArgs>(args: SelectSubset<T, MandateUpdateArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mandates.
     * @param {MandateDeleteManyArgs} args - Arguments to filter Mandates to delete.
     * @example
     * // Delete a few Mandates
     * const { count } = await prisma.mandate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MandateDeleteManyArgs>(args?: SelectSubset<T, MandateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mandates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mandates
     * const mandate = await prisma.mandate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MandateUpdateManyArgs>(args: SelectSubset<T, MandateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mandate.
     * @param {MandateUpsertArgs} args - Arguments to update or create a Mandate.
     * @example
     * // Update or create a Mandate
     * const mandate = await prisma.mandate.upsert({
     *   create: {
     *     // ... data to create a Mandate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mandate we want to update
     *   }
     * })
     */
    upsert<T extends MandateUpsertArgs>(args: SelectSubset<T, MandateUpsertArgs<ExtArgs>>): Prisma__MandateClient<$Result.GetResult<Prisma.$MandatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mandates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateCountArgs} args - Arguments to filter Mandates to count.
     * @example
     * // Count the number of Mandates
     * const count = await prisma.mandate.count({
     *   where: {
     *     // ... the filter for the Mandates we want to count
     *   }
     * })
    **/
    count<T extends MandateCountArgs>(
      args?: Subset<T, MandateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MandateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mandate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MandateAggregateArgs>(args: Subset<T, MandateAggregateArgs>): Prisma.PrismaPromise<GetMandateAggregateType<T>>

    /**
     * Group by Mandate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MandateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MandateGroupByArgs['orderBy'] }
        : { orderBy?: MandateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MandateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMandateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mandate model
   */
  readonly fields: MandateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mandate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MandateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mandate model
   */
  interface MandateFieldRefs {
    readonly id: FieldRef<"Mandate", 'Int'>
    readonly organisationId: FieldRef<"Mandate", 'Int'>
    readonly merchantTranId: FieldRef<"Mandate", 'String'>
    readonly bankRRN: FieldRef<"Mandate", 'String'>
    readonly UMN: FieldRef<"Mandate", 'String'>
    readonly amount: FieldRef<"Mandate", 'Float'>
    readonly status: FieldRef<"Mandate", 'String'>
    readonly payerVA: FieldRef<"Mandate", 'String'>
    readonly payerName: FieldRef<"Mandate", 'String'>
    readonly payerMobile: FieldRef<"Mandate", 'String'>
    readonly txnInitDate: FieldRef<"Mandate", 'DateTime'>
    readonly txnCompletionDate: FieldRef<"Mandate", 'DateTime'>
    readonly responseCode: FieldRef<"Mandate", 'String'>
    readonly respCodeDescription: FieldRef<"Mandate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Mandate findUnique
   */
  export type MandateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * Filter, which Mandate to fetch.
     */
    where: MandateWhereUniqueInput
  }

  /**
   * Mandate findUniqueOrThrow
   */
  export type MandateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * Filter, which Mandate to fetch.
     */
    where: MandateWhereUniqueInput
  }

  /**
   * Mandate findFirst
   */
  export type MandateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * Filter, which Mandate to fetch.
     */
    where?: MandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mandates to fetch.
     */
    orderBy?: MandateOrderByWithRelationInput | MandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mandates.
     */
    cursor?: MandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mandates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mandates.
     */
    distinct?: MandateScalarFieldEnum | MandateScalarFieldEnum[]
  }

  /**
   * Mandate findFirstOrThrow
   */
  export type MandateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * Filter, which Mandate to fetch.
     */
    where?: MandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mandates to fetch.
     */
    orderBy?: MandateOrderByWithRelationInput | MandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mandates.
     */
    cursor?: MandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mandates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mandates.
     */
    distinct?: MandateScalarFieldEnum | MandateScalarFieldEnum[]
  }

  /**
   * Mandate findMany
   */
  export type MandateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * Filter, which Mandates to fetch.
     */
    where?: MandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mandates to fetch.
     */
    orderBy?: MandateOrderByWithRelationInput | MandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mandates.
     */
    cursor?: MandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mandates.
     */
    skip?: number
    distinct?: MandateScalarFieldEnum | MandateScalarFieldEnum[]
  }

  /**
   * Mandate create
   */
  export type MandateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * The data needed to create a Mandate.
     */
    data: XOR<MandateCreateInput, MandateUncheckedCreateInput>
  }

  /**
   * Mandate createMany
   */
  export type MandateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mandates.
     */
    data: MandateCreateManyInput | MandateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mandate update
   */
  export type MandateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * The data needed to update a Mandate.
     */
    data: XOR<MandateUpdateInput, MandateUncheckedUpdateInput>
    /**
     * Choose, which Mandate to update.
     */
    where: MandateWhereUniqueInput
  }

  /**
   * Mandate updateMany
   */
  export type MandateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mandates.
     */
    data: XOR<MandateUpdateManyMutationInput, MandateUncheckedUpdateManyInput>
    /**
     * Filter which Mandates to update
     */
    where?: MandateWhereInput
    /**
     * Limit how many Mandates to update.
     */
    limit?: number
  }

  /**
   * Mandate upsert
   */
  export type MandateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * The filter to search for the Mandate to update in case it exists.
     */
    where: MandateWhereUniqueInput
    /**
     * In case the Mandate found by the `where` argument doesn't exist, create a new Mandate with this data.
     */
    create: XOR<MandateCreateInput, MandateUncheckedCreateInput>
    /**
     * In case the Mandate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MandateUpdateInput, MandateUncheckedUpdateInput>
  }

  /**
   * Mandate delete
   */
  export type MandateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
    /**
     * Filter which Mandate to delete.
     */
    where: MandateWhereUniqueInput
  }

  /**
   * Mandate deleteMany
   */
  export type MandateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mandates to delete
     */
    where?: MandateWhereInput
    /**
     * Limit how many Mandates to delete.
     */
    limit?: number
  }

  /**
   * Mandate without action
   */
  export type MandateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mandate
     */
    select?: MandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mandate
     */
    omit?: MandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateInclude<ExtArgs> | null
  }


  /**
   * Model ActiveMandate
   */

  export type AggregateActiveMandate = {
    _count: ActiveMandateCountAggregateOutputType | null
    _avg: ActiveMandateAvgAggregateOutputType | null
    _sum: ActiveMandateSumAggregateOutputType | null
    _min: ActiveMandateMinAggregateOutputType | null
    _max: ActiveMandateMaxAggregateOutputType | null
  }

  export type ActiveMandateAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    mandateSeqNo: number | null
    amount: number | null
    notificationRetries: number | null
    retryCount: number | null
  }

  export type ActiveMandateSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    mandateSeqNo: number | null
    amount: number | null
    notificationRetries: number | null
    retryCount: number | null
  }

  export type ActiveMandateMinAggregateOutputType = {
    id: number | null
    organisationId: number | null
    UMN: string | null
    mandateSeqNo: number | null
    amount: number | null
    notificationRetries: number | null
    retryCount: number | null
    status: string | null
    payerVA: string | null
    payerName: string | null
    payerMobile: string | null
    notified: boolean | null
    lastAttemptAt: Date | null
    lastNotificationAttempt: Date | null
  }

  export type ActiveMandateMaxAggregateOutputType = {
    id: number | null
    organisationId: number | null
    UMN: string | null
    mandateSeqNo: number | null
    amount: number | null
    notificationRetries: number | null
    retryCount: number | null
    status: string | null
    payerVA: string | null
    payerName: string | null
    payerMobile: string | null
    notified: boolean | null
    lastAttemptAt: Date | null
    lastNotificationAttempt: Date | null
  }

  export type ActiveMandateCountAggregateOutputType = {
    id: number
    organisationId: number
    UMN: number
    mandateSeqNo: number
    amount: number
    notificationRetries: number
    retryCount: number
    status: number
    payerVA: number
    payerName: number
    payerMobile: number
    notified: number
    lastAttemptAt: number
    lastNotificationAttempt: number
    _all: number
  }


  export type ActiveMandateAvgAggregateInputType = {
    id?: true
    organisationId?: true
    mandateSeqNo?: true
    amount?: true
    notificationRetries?: true
    retryCount?: true
  }

  export type ActiveMandateSumAggregateInputType = {
    id?: true
    organisationId?: true
    mandateSeqNo?: true
    amount?: true
    notificationRetries?: true
    retryCount?: true
  }

  export type ActiveMandateMinAggregateInputType = {
    id?: true
    organisationId?: true
    UMN?: true
    mandateSeqNo?: true
    amount?: true
    notificationRetries?: true
    retryCount?: true
    status?: true
    payerVA?: true
    payerName?: true
    payerMobile?: true
    notified?: true
    lastAttemptAt?: true
    lastNotificationAttempt?: true
  }

  export type ActiveMandateMaxAggregateInputType = {
    id?: true
    organisationId?: true
    UMN?: true
    mandateSeqNo?: true
    amount?: true
    notificationRetries?: true
    retryCount?: true
    status?: true
    payerVA?: true
    payerName?: true
    payerMobile?: true
    notified?: true
    lastAttemptAt?: true
    lastNotificationAttempt?: true
  }

  export type ActiveMandateCountAggregateInputType = {
    id?: true
    organisationId?: true
    UMN?: true
    mandateSeqNo?: true
    amount?: true
    notificationRetries?: true
    retryCount?: true
    status?: true
    payerVA?: true
    payerName?: true
    payerMobile?: true
    notified?: true
    lastAttemptAt?: true
    lastNotificationAttempt?: true
    _all?: true
  }

  export type ActiveMandateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveMandate to aggregate.
     */
    where?: ActiveMandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveMandates to fetch.
     */
    orderBy?: ActiveMandateOrderByWithRelationInput | ActiveMandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActiveMandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveMandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveMandates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActiveMandates
    **/
    _count?: true | ActiveMandateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActiveMandateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActiveMandateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActiveMandateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActiveMandateMaxAggregateInputType
  }

  export type GetActiveMandateAggregateType<T extends ActiveMandateAggregateArgs> = {
        [P in keyof T & keyof AggregateActiveMandate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActiveMandate[P]>
      : GetScalarType<T[P], AggregateActiveMandate[P]>
  }




  export type ActiveMandateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveMandateWhereInput
    orderBy?: ActiveMandateOrderByWithAggregationInput | ActiveMandateOrderByWithAggregationInput[]
    by: ActiveMandateScalarFieldEnum[] | ActiveMandateScalarFieldEnum
    having?: ActiveMandateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActiveMandateCountAggregateInputType | true
    _avg?: ActiveMandateAvgAggregateInputType
    _sum?: ActiveMandateSumAggregateInputType
    _min?: ActiveMandateMinAggregateInputType
    _max?: ActiveMandateMaxAggregateInputType
  }

  export type ActiveMandateGroupByOutputType = {
    id: number
    organisationId: number
    UMN: string | null
    mandateSeqNo: number
    amount: number
    notificationRetries: number
    retryCount: number
    status: string
    payerVA: string
    payerName: string | null
    payerMobile: string | null
    notified: boolean
    lastAttemptAt: Date | null
    lastNotificationAttempt: Date | null
    _count: ActiveMandateCountAggregateOutputType | null
    _avg: ActiveMandateAvgAggregateOutputType | null
    _sum: ActiveMandateSumAggregateOutputType | null
    _min: ActiveMandateMinAggregateOutputType | null
    _max: ActiveMandateMaxAggregateOutputType | null
  }

  type GetActiveMandateGroupByPayload<T extends ActiveMandateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActiveMandateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActiveMandateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActiveMandateGroupByOutputType[P]>
            : GetScalarType<T[P], ActiveMandateGroupByOutputType[P]>
        }
      >
    >


  export type ActiveMandateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organisationId?: boolean
    UMN?: boolean
    mandateSeqNo?: boolean
    amount?: boolean
    notificationRetries?: boolean
    retryCount?: boolean
    status?: boolean
    payerVA?: boolean
    payerName?: boolean
    payerMobile?: boolean
    notified?: boolean
    lastAttemptAt?: boolean
    lastNotificationAttempt?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activeMandate"]>



  export type ActiveMandateSelectScalar = {
    id?: boolean
    organisationId?: boolean
    UMN?: boolean
    mandateSeqNo?: boolean
    amount?: boolean
    notificationRetries?: boolean
    retryCount?: boolean
    status?: boolean
    payerVA?: boolean
    payerName?: boolean
    payerMobile?: boolean
    notified?: boolean
    lastAttemptAt?: boolean
    lastNotificationAttempt?: boolean
  }

  export type ActiveMandateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organisationId" | "UMN" | "mandateSeqNo" | "amount" | "notificationRetries" | "retryCount" | "status" | "payerVA" | "payerName" | "payerMobile" | "notified" | "lastAttemptAt" | "lastNotificationAttempt", ExtArgs["result"]["activeMandate"]>
  export type ActiveMandateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }

  export type $ActiveMandatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActiveMandate"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organisationId: number
      UMN: string | null
      mandateSeqNo: number
      amount: number
      notificationRetries: number
      retryCount: number
      status: string
      payerVA: string
      payerName: string | null
      payerMobile: string | null
      notified: boolean
      lastAttemptAt: Date | null
      lastNotificationAttempt: Date | null
    }, ExtArgs["result"]["activeMandate"]>
    composites: {}
  }

  type ActiveMandateGetPayload<S extends boolean | null | undefined | ActiveMandateDefaultArgs> = $Result.GetResult<Prisma.$ActiveMandatePayload, S>

  type ActiveMandateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActiveMandateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActiveMandateCountAggregateInputType | true
    }

  export interface ActiveMandateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActiveMandate'], meta: { name: 'ActiveMandate' } }
    /**
     * Find zero or one ActiveMandate that matches the filter.
     * @param {ActiveMandateFindUniqueArgs} args - Arguments to find a ActiveMandate
     * @example
     * // Get one ActiveMandate
     * const activeMandate = await prisma.activeMandate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActiveMandateFindUniqueArgs>(args: SelectSubset<T, ActiveMandateFindUniqueArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActiveMandate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActiveMandateFindUniqueOrThrowArgs} args - Arguments to find a ActiveMandate
     * @example
     * // Get one ActiveMandate
     * const activeMandate = await prisma.activeMandate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActiveMandateFindUniqueOrThrowArgs>(args: SelectSubset<T, ActiveMandateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActiveMandate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveMandateFindFirstArgs} args - Arguments to find a ActiveMandate
     * @example
     * // Get one ActiveMandate
     * const activeMandate = await prisma.activeMandate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActiveMandateFindFirstArgs>(args?: SelectSubset<T, ActiveMandateFindFirstArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActiveMandate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveMandateFindFirstOrThrowArgs} args - Arguments to find a ActiveMandate
     * @example
     * // Get one ActiveMandate
     * const activeMandate = await prisma.activeMandate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActiveMandateFindFirstOrThrowArgs>(args?: SelectSubset<T, ActiveMandateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActiveMandates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveMandateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActiveMandates
     * const activeMandates = await prisma.activeMandate.findMany()
     * 
     * // Get first 10 ActiveMandates
     * const activeMandates = await prisma.activeMandate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activeMandateWithIdOnly = await prisma.activeMandate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActiveMandateFindManyArgs>(args?: SelectSubset<T, ActiveMandateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActiveMandate.
     * @param {ActiveMandateCreateArgs} args - Arguments to create a ActiveMandate.
     * @example
     * // Create one ActiveMandate
     * const ActiveMandate = await prisma.activeMandate.create({
     *   data: {
     *     // ... data to create a ActiveMandate
     *   }
     * })
     * 
     */
    create<T extends ActiveMandateCreateArgs>(args: SelectSubset<T, ActiveMandateCreateArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActiveMandates.
     * @param {ActiveMandateCreateManyArgs} args - Arguments to create many ActiveMandates.
     * @example
     * // Create many ActiveMandates
     * const activeMandate = await prisma.activeMandate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActiveMandateCreateManyArgs>(args?: SelectSubset<T, ActiveMandateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActiveMandate.
     * @param {ActiveMandateDeleteArgs} args - Arguments to delete one ActiveMandate.
     * @example
     * // Delete one ActiveMandate
     * const ActiveMandate = await prisma.activeMandate.delete({
     *   where: {
     *     // ... filter to delete one ActiveMandate
     *   }
     * })
     * 
     */
    delete<T extends ActiveMandateDeleteArgs>(args: SelectSubset<T, ActiveMandateDeleteArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActiveMandate.
     * @param {ActiveMandateUpdateArgs} args - Arguments to update one ActiveMandate.
     * @example
     * // Update one ActiveMandate
     * const activeMandate = await prisma.activeMandate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActiveMandateUpdateArgs>(args: SelectSubset<T, ActiveMandateUpdateArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActiveMandates.
     * @param {ActiveMandateDeleteManyArgs} args - Arguments to filter ActiveMandates to delete.
     * @example
     * // Delete a few ActiveMandates
     * const { count } = await prisma.activeMandate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActiveMandateDeleteManyArgs>(args?: SelectSubset<T, ActiveMandateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActiveMandates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveMandateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActiveMandates
     * const activeMandate = await prisma.activeMandate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActiveMandateUpdateManyArgs>(args: SelectSubset<T, ActiveMandateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActiveMandate.
     * @param {ActiveMandateUpsertArgs} args - Arguments to update or create a ActiveMandate.
     * @example
     * // Update or create a ActiveMandate
     * const activeMandate = await prisma.activeMandate.upsert({
     *   create: {
     *     // ... data to create a ActiveMandate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActiveMandate we want to update
     *   }
     * })
     */
    upsert<T extends ActiveMandateUpsertArgs>(args: SelectSubset<T, ActiveMandateUpsertArgs<ExtArgs>>): Prisma__ActiveMandateClient<$Result.GetResult<Prisma.$ActiveMandatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActiveMandates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveMandateCountArgs} args - Arguments to filter ActiveMandates to count.
     * @example
     * // Count the number of ActiveMandates
     * const count = await prisma.activeMandate.count({
     *   where: {
     *     // ... the filter for the ActiveMandates we want to count
     *   }
     * })
    **/
    count<T extends ActiveMandateCountArgs>(
      args?: Subset<T, ActiveMandateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActiveMandateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActiveMandate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveMandateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActiveMandateAggregateArgs>(args: Subset<T, ActiveMandateAggregateArgs>): Prisma.PrismaPromise<GetActiveMandateAggregateType<T>>

    /**
     * Group by ActiveMandate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveMandateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActiveMandateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActiveMandateGroupByArgs['orderBy'] }
        : { orderBy?: ActiveMandateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActiveMandateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActiveMandateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActiveMandate model
   */
  readonly fields: ActiveMandateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActiveMandate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActiveMandateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActiveMandate model
   */
  interface ActiveMandateFieldRefs {
    readonly id: FieldRef<"ActiveMandate", 'Int'>
    readonly organisationId: FieldRef<"ActiveMandate", 'Int'>
    readonly UMN: FieldRef<"ActiveMandate", 'String'>
    readonly mandateSeqNo: FieldRef<"ActiveMandate", 'Int'>
    readonly amount: FieldRef<"ActiveMandate", 'Float'>
    readonly notificationRetries: FieldRef<"ActiveMandate", 'Int'>
    readonly retryCount: FieldRef<"ActiveMandate", 'Int'>
    readonly status: FieldRef<"ActiveMandate", 'String'>
    readonly payerVA: FieldRef<"ActiveMandate", 'String'>
    readonly payerName: FieldRef<"ActiveMandate", 'String'>
    readonly payerMobile: FieldRef<"ActiveMandate", 'String'>
    readonly notified: FieldRef<"ActiveMandate", 'Boolean'>
    readonly lastAttemptAt: FieldRef<"ActiveMandate", 'DateTime'>
    readonly lastNotificationAttempt: FieldRef<"ActiveMandate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActiveMandate findUnique
   */
  export type ActiveMandateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * Filter, which ActiveMandate to fetch.
     */
    where: ActiveMandateWhereUniqueInput
  }

  /**
   * ActiveMandate findUniqueOrThrow
   */
  export type ActiveMandateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * Filter, which ActiveMandate to fetch.
     */
    where: ActiveMandateWhereUniqueInput
  }

  /**
   * ActiveMandate findFirst
   */
  export type ActiveMandateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * Filter, which ActiveMandate to fetch.
     */
    where?: ActiveMandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveMandates to fetch.
     */
    orderBy?: ActiveMandateOrderByWithRelationInput | ActiveMandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveMandates.
     */
    cursor?: ActiveMandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveMandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveMandates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveMandates.
     */
    distinct?: ActiveMandateScalarFieldEnum | ActiveMandateScalarFieldEnum[]
  }

  /**
   * ActiveMandate findFirstOrThrow
   */
  export type ActiveMandateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * Filter, which ActiveMandate to fetch.
     */
    where?: ActiveMandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveMandates to fetch.
     */
    orderBy?: ActiveMandateOrderByWithRelationInput | ActiveMandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveMandates.
     */
    cursor?: ActiveMandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveMandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveMandates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveMandates.
     */
    distinct?: ActiveMandateScalarFieldEnum | ActiveMandateScalarFieldEnum[]
  }

  /**
   * ActiveMandate findMany
   */
  export type ActiveMandateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * Filter, which ActiveMandates to fetch.
     */
    where?: ActiveMandateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveMandates to fetch.
     */
    orderBy?: ActiveMandateOrderByWithRelationInput | ActiveMandateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActiveMandates.
     */
    cursor?: ActiveMandateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveMandates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveMandates.
     */
    skip?: number
    distinct?: ActiveMandateScalarFieldEnum | ActiveMandateScalarFieldEnum[]
  }

  /**
   * ActiveMandate create
   */
  export type ActiveMandateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * The data needed to create a ActiveMandate.
     */
    data: XOR<ActiveMandateCreateInput, ActiveMandateUncheckedCreateInput>
  }

  /**
   * ActiveMandate createMany
   */
  export type ActiveMandateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActiveMandates.
     */
    data: ActiveMandateCreateManyInput | ActiveMandateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActiveMandate update
   */
  export type ActiveMandateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * The data needed to update a ActiveMandate.
     */
    data: XOR<ActiveMandateUpdateInput, ActiveMandateUncheckedUpdateInput>
    /**
     * Choose, which ActiveMandate to update.
     */
    where: ActiveMandateWhereUniqueInput
  }

  /**
   * ActiveMandate updateMany
   */
  export type ActiveMandateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActiveMandates.
     */
    data: XOR<ActiveMandateUpdateManyMutationInput, ActiveMandateUncheckedUpdateManyInput>
    /**
     * Filter which ActiveMandates to update
     */
    where?: ActiveMandateWhereInput
    /**
     * Limit how many ActiveMandates to update.
     */
    limit?: number
  }

  /**
   * ActiveMandate upsert
   */
  export type ActiveMandateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * The filter to search for the ActiveMandate to update in case it exists.
     */
    where: ActiveMandateWhereUniqueInput
    /**
     * In case the ActiveMandate found by the `where` argument doesn't exist, create a new ActiveMandate with this data.
     */
    create: XOR<ActiveMandateCreateInput, ActiveMandateUncheckedCreateInput>
    /**
     * In case the ActiveMandate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActiveMandateUpdateInput, ActiveMandateUncheckedUpdateInput>
  }

  /**
   * ActiveMandate delete
   */
  export type ActiveMandateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
    /**
     * Filter which ActiveMandate to delete.
     */
    where: ActiveMandateWhereUniqueInput
  }

  /**
   * ActiveMandate deleteMany
   */
  export type ActiveMandateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveMandates to delete
     */
    where?: ActiveMandateWhereInput
    /**
     * Limit how many ActiveMandates to delete.
     */
    limit?: number
  }

  /**
   * ActiveMandate without action
   */
  export type ActiveMandateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveMandate
     */
    select?: ActiveMandateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveMandate
     */
    omit?: ActiveMandateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveMandateInclude<ExtArgs> | null
  }


  /**
   * Model MandateNotification
   */

  export type AggregateMandateNotification = {
    _count: MandateNotificationCountAggregateOutputType | null
    _avg: MandateNotificationAvgAggregateOutputType | null
    _sum: MandateNotificationSumAggregateOutputType | null
    _min: MandateNotificationMinAggregateOutputType | null
    _max: MandateNotificationMaxAggregateOutputType | null
  }

  export type MandateNotificationAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type MandateNotificationSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type MandateNotificationMinAggregateOutputType = {
    id: number | null
    organisationId: number | null
    type: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MandateNotificationMaxAggregateOutputType = {
    id: number | null
    organisationId: number | null
    type: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MandateNotificationCountAggregateOutputType = {
    id: number
    organisationId: number
    type: number
    message: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type MandateNotificationAvgAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type MandateNotificationSumAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type MandateNotificationMinAggregateInputType = {
    id?: true
    organisationId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type MandateNotificationMaxAggregateInputType = {
    id?: true
    organisationId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type MandateNotificationCountAggregateInputType = {
    id?: true
    organisationId?: true
    type?: true
    message?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type MandateNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MandateNotification to aggregate.
     */
    where?: MandateNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandateNotifications to fetch.
     */
    orderBy?: MandateNotificationOrderByWithRelationInput | MandateNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MandateNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandateNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandateNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MandateNotifications
    **/
    _count?: true | MandateNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MandateNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MandateNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MandateNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MandateNotificationMaxAggregateInputType
  }

  export type GetMandateNotificationAggregateType<T extends MandateNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateMandateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMandateNotification[P]>
      : GetScalarType<T[P], AggregateMandateNotification[P]>
  }




  export type MandateNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MandateNotificationWhereInput
    orderBy?: MandateNotificationOrderByWithAggregationInput | MandateNotificationOrderByWithAggregationInput[]
    by: MandateNotificationScalarFieldEnum[] | MandateNotificationScalarFieldEnum
    having?: MandateNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MandateNotificationCountAggregateInputType | true
    _avg?: MandateNotificationAvgAggregateInputType
    _sum?: MandateNotificationSumAggregateInputType
    _min?: MandateNotificationMinAggregateInputType
    _max?: MandateNotificationMaxAggregateInputType
  }

  export type MandateNotificationGroupByOutputType = {
    id: number
    organisationId: number
    type: string
    message: string
    isRead: boolean
    createdAt: Date
    _count: MandateNotificationCountAggregateOutputType | null
    _avg: MandateNotificationAvgAggregateOutputType | null
    _sum: MandateNotificationSumAggregateOutputType | null
    _min: MandateNotificationMinAggregateOutputType | null
    _max: MandateNotificationMaxAggregateOutputType | null
  }

  type GetMandateNotificationGroupByPayload<T extends MandateNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MandateNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MandateNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MandateNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], MandateNotificationGroupByOutputType[P]>
        }
      >
    >


  export type MandateNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organisationId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mandateNotification"]>



  export type MandateNotificationSelectScalar = {
    id?: boolean
    organisationId?: boolean
    type?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type MandateNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organisationId" | "type" | "message" | "isRead" | "createdAt", ExtArgs["result"]["mandateNotification"]>
  export type MandateNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
  }

  export type $MandateNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MandateNotification"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organisationId: number
      type: string
      message: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["mandateNotification"]>
    composites: {}
  }

  type MandateNotificationGetPayload<S extends boolean | null | undefined | MandateNotificationDefaultArgs> = $Result.GetResult<Prisma.$MandateNotificationPayload, S>

  type MandateNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MandateNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MandateNotificationCountAggregateInputType | true
    }

  export interface MandateNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MandateNotification'], meta: { name: 'MandateNotification' } }
    /**
     * Find zero or one MandateNotification that matches the filter.
     * @param {MandateNotificationFindUniqueArgs} args - Arguments to find a MandateNotification
     * @example
     * // Get one MandateNotification
     * const mandateNotification = await prisma.mandateNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MandateNotificationFindUniqueArgs>(args: SelectSubset<T, MandateNotificationFindUniqueArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MandateNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MandateNotificationFindUniqueOrThrowArgs} args - Arguments to find a MandateNotification
     * @example
     * // Get one MandateNotification
     * const mandateNotification = await prisma.mandateNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MandateNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, MandateNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MandateNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateNotificationFindFirstArgs} args - Arguments to find a MandateNotification
     * @example
     * // Get one MandateNotification
     * const mandateNotification = await prisma.mandateNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MandateNotificationFindFirstArgs>(args?: SelectSubset<T, MandateNotificationFindFirstArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MandateNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateNotificationFindFirstOrThrowArgs} args - Arguments to find a MandateNotification
     * @example
     * // Get one MandateNotification
     * const mandateNotification = await prisma.mandateNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MandateNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, MandateNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MandateNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MandateNotifications
     * const mandateNotifications = await prisma.mandateNotification.findMany()
     * 
     * // Get first 10 MandateNotifications
     * const mandateNotifications = await prisma.mandateNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mandateNotificationWithIdOnly = await prisma.mandateNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MandateNotificationFindManyArgs>(args?: SelectSubset<T, MandateNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MandateNotification.
     * @param {MandateNotificationCreateArgs} args - Arguments to create a MandateNotification.
     * @example
     * // Create one MandateNotification
     * const MandateNotification = await prisma.mandateNotification.create({
     *   data: {
     *     // ... data to create a MandateNotification
     *   }
     * })
     * 
     */
    create<T extends MandateNotificationCreateArgs>(args: SelectSubset<T, MandateNotificationCreateArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MandateNotifications.
     * @param {MandateNotificationCreateManyArgs} args - Arguments to create many MandateNotifications.
     * @example
     * // Create many MandateNotifications
     * const mandateNotification = await prisma.mandateNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MandateNotificationCreateManyArgs>(args?: SelectSubset<T, MandateNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MandateNotification.
     * @param {MandateNotificationDeleteArgs} args - Arguments to delete one MandateNotification.
     * @example
     * // Delete one MandateNotification
     * const MandateNotification = await prisma.mandateNotification.delete({
     *   where: {
     *     // ... filter to delete one MandateNotification
     *   }
     * })
     * 
     */
    delete<T extends MandateNotificationDeleteArgs>(args: SelectSubset<T, MandateNotificationDeleteArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MandateNotification.
     * @param {MandateNotificationUpdateArgs} args - Arguments to update one MandateNotification.
     * @example
     * // Update one MandateNotification
     * const mandateNotification = await prisma.mandateNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MandateNotificationUpdateArgs>(args: SelectSubset<T, MandateNotificationUpdateArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MandateNotifications.
     * @param {MandateNotificationDeleteManyArgs} args - Arguments to filter MandateNotifications to delete.
     * @example
     * // Delete a few MandateNotifications
     * const { count } = await prisma.mandateNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MandateNotificationDeleteManyArgs>(args?: SelectSubset<T, MandateNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MandateNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MandateNotifications
     * const mandateNotification = await prisma.mandateNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MandateNotificationUpdateManyArgs>(args: SelectSubset<T, MandateNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MandateNotification.
     * @param {MandateNotificationUpsertArgs} args - Arguments to update or create a MandateNotification.
     * @example
     * // Update or create a MandateNotification
     * const mandateNotification = await prisma.mandateNotification.upsert({
     *   create: {
     *     // ... data to create a MandateNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MandateNotification we want to update
     *   }
     * })
     */
    upsert<T extends MandateNotificationUpsertArgs>(args: SelectSubset<T, MandateNotificationUpsertArgs<ExtArgs>>): Prisma__MandateNotificationClient<$Result.GetResult<Prisma.$MandateNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MandateNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateNotificationCountArgs} args - Arguments to filter MandateNotifications to count.
     * @example
     * // Count the number of MandateNotifications
     * const count = await prisma.mandateNotification.count({
     *   where: {
     *     // ... the filter for the MandateNotifications we want to count
     *   }
     * })
    **/
    count<T extends MandateNotificationCountArgs>(
      args?: Subset<T, MandateNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MandateNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MandateNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MandateNotificationAggregateArgs>(args: Subset<T, MandateNotificationAggregateArgs>): Prisma.PrismaPromise<GetMandateNotificationAggregateType<T>>

    /**
     * Group by MandateNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MandateNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MandateNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MandateNotificationGroupByArgs['orderBy'] }
        : { orderBy?: MandateNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MandateNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMandateNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MandateNotification model
   */
  readonly fields: MandateNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MandateNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MandateNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MandateNotification model
   */
  interface MandateNotificationFieldRefs {
    readonly id: FieldRef<"MandateNotification", 'Int'>
    readonly organisationId: FieldRef<"MandateNotification", 'Int'>
    readonly type: FieldRef<"MandateNotification", 'String'>
    readonly message: FieldRef<"MandateNotification", 'String'>
    readonly isRead: FieldRef<"MandateNotification", 'Boolean'>
    readonly createdAt: FieldRef<"MandateNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MandateNotification findUnique
   */
  export type MandateNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MandateNotification to fetch.
     */
    where: MandateNotificationWhereUniqueInput
  }

  /**
   * MandateNotification findUniqueOrThrow
   */
  export type MandateNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MandateNotification to fetch.
     */
    where: MandateNotificationWhereUniqueInput
  }

  /**
   * MandateNotification findFirst
   */
  export type MandateNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MandateNotification to fetch.
     */
    where?: MandateNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandateNotifications to fetch.
     */
    orderBy?: MandateNotificationOrderByWithRelationInput | MandateNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MandateNotifications.
     */
    cursor?: MandateNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandateNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandateNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MandateNotifications.
     */
    distinct?: MandateNotificationScalarFieldEnum | MandateNotificationScalarFieldEnum[]
  }

  /**
   * MandateNotification findFirstOrThrow
   */
  export type MandateNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MandateNotification to fetch.
     */
    where?: MandateNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandateNotifications to fetch.
     */
    orderBy?: MandateNotificationOrderByWithRelationInput | MandateNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MandateNotifications.
     */
    cursor?: MandateNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandateNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandateNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MandateNotifications.
     */
    distinct?: MandateNotificationScalarFieldEnum | MandateNotificationScalarFieldEnum[]
  }

  /**
   * MandateNotification findMany
   */
  export type MandateNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * Filter, which MandateNotifications to fetch.
     */
    where?: MandateNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MandateNotifications to fetch.
     */
    orderBy?: MandateNotificationOrderByWithRelationInput | MandateNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MandateNotifications.
     */
    cursor?: MandateNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MandateNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MandateNotifications.
     */
    skip?: number
    distinct?: MandateNotificationScalarFieldEnum | MandateNotificationScalarFieldEnum[]
  }

  /**
   * MandateNotification create
   */
  export type MandateNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a MandateNotification.
     */
    data: XOR<MandateNotificationCreateInput, MandateNotificationUncheckedCreateInput>
  }

  /**
   * MandateNotification createMany
   */
  export type MandateNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MandateNotifications.
     */
    data: MandateNotificationCreateManyInput | MandateNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MandateNotification update
   */
  export type MandateNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a MandateNotification.
     */
    data: XOR<MandateNotificationUpdateInput, MandateNotificationUncheckedUpdateInput>
    /**
     * Choose, which MandateNotification to update.
     */
    where: MandateNotificationWhereUniqueInput
  }

  /**
   * MandateNotification updateMany
   */
  export type MandateNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MandateNotifications.
     */
    data: XOR<MandateNotificationUpdateManyMutationInput, MandateNotificationUncheckedUpdateManyInput>
    /**
     * Filter which MandateNotifications to update
     */
    where?: MandateNotificationWhereInput
    /**
     * Limit how many MandateNotifications to update.
     */
    limit?: number
  }

  /**
   * MandateNotification upsert
   */
  export type MandateNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the MandateNotification to update in case it exists.
     */
    where: MandateNotificationWhereUniqueInput
    /**
     * In case the MandateNotification found by the `where` argument doesn't exist, create a new MandateNotification with this data.
     */
    create: XOR<MandateNotificationCreateInput, MandateNotificationUncheckedCreateInput>
    /**
     * In case the MandateNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MandateNotificationUpdateInput, MandateNotificationUncheckedUpdateInput>
  }

  /**
   * MandateNotification delete
   */
  export type MandateNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
    /**
     * Filter which MandateNotification to delete.
     */
    where: MandateNotificationWhereUniqueInput
  }

  /**
   * MandateNotification deleteMany
   */
  export type MandateNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MandateNotifications to delete
     */
    where?: MandateNotificationWhereInput
    /**
     * Limit how many MandateNotifications to delete.
     */
    limit?: number
  }

  /**
   * MandateNotification without action
   */
  export type MandateNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MandateNotification
     */
    select?: MandateNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MandateNotification
     */
    omit?: MandateNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MandateNotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganisationScalarFieldEnum: {
    id: 'id',
    password: 'password',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    email: 'email',
    phone: 'phone',
    name: 'name',
    companySize: 'companySize',
    shopName: 'shopName',
    flatNo: 'flatNo',
    street: 'street',
    district: 'district',
    city: 'city',
    state: 'state',
    smsCount: 'smsCount',
    smsCost: 'smsCost',
    country: 'country',
    pincode: 'pincode',
    mobileNumber: 'mobileNumber',
    landlineNumber: 'landlineNumber',
    websiteAddress: 'websiteAddress',
    gstNumber: 'gstNumber',
    subscriptionType: 'subscriptionType',
    endDate: 'endDate',
    whatsappNumber: 'whatsappNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    razorpayAccessToken: 'razorpayAccessToken',
    razorpayRefreshToken: 'razorpayRefreshToken',
    razorpayTokenExpiresAt: 'razorpayTokenExpiresAt',
    razorpayAccountId: 'razorpayAccountId',
    razorpayState: 'razorpayState',
    razorpayStateExpiresAt: 'razorpayStateExpiresAt',
    monthlyUsage: 'monthlyUsage'
  };

  export type OrganisationScalarFieldEnum = (typeof OrganisationScalarFieldEnum)[keyof typeof OrganisationScalarFieldEnum]


  export const CustomerSubmissionScalarFieldEnum: {
    id: 'id',
    token: 'token',
    organisationId: 'organisationId',
    customerId: 'customerId',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerSubmissionScalarFieldEnum = (typeof CustomerSubmissionScalarFieldEnum)[keyof typeof CustomerSubmissionScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    organisationId: 'organisationId'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    SKU: 'SKU',
    netPrice: 'netPrice',
    sellingPrice: 'sellingPrice',
    quantity: 'quantity',
    seller: 'seller',
    organisationId: 'organisationId',
    categoryId: 'categoryId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SellerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    type: 'type',
    organisationId: 'organisationId'
  };

  export type SellerScalarFieldEnum = (typeof SellerScalarFieldEnum)[keyof typeof SellerScalarFieldEnum]


  export const TransactionRecordScalarFieldEnum: {
    id: 'id',
    billNo: 'billNo',
    totalPrice: 'totalPrice',
    paymentMethod: 'paymentMethod',
    amountPaid: 'amountPaid',
    balance: 'balance',
    billingMode: 'billingMode',
    organisationId: 'organisationId',
    date: 'date',
    time: 'time',
    trackingNumber: 'trackingNumber',
    weight: 'weight',
    customerId: 'customerId',
    status: 'status',
    notes: 'notes',
    paymentId: 'paymentId',
    paymentStatus: 'paymentStatus',
    isEdited: 'isEdited'
  };

  export type TransactionRecordScalarFieldEnum = (typeof TransactionRecordScalarFieldEnum)[keyof typeof TransactionRecordScalarFieldEnum]


  export const TransactionItemScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    productId: 'productId',
    quantity: 'quantity',
    totalPrice: 'totalPrice'
  };

  export type TransactionItemScalarFieldEnum = (typeof TransactionItemScalarFieldEnum)[keyof typeof TransactionItemScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    district: 'district',
    state: 'state',
    pincode: 'pincode',
    email: 'email',
    flatNo: 'flatNo',
    street: 'street',
    organisationId: 'organisationId'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    categoryId: 'categoryId',
    organisationId: 'organisationId',
    quantity: 'quantity'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const SubscriptionDetailsScalarFieldEnum: {
    id: 'id',
    organisationId: 'organisationId',
    date: 'date',
    month: 'month',
    year: 'year',
    smsCount: 'smsCount',
    shopName: 'shopName',
    mobileNumber: 'mobileNumber'
  };

  export type SubscriptionDetailsScalarFieldEnum = (typeof SubscriptionDetailsScalarFieldEnum)[keyof typeof SubscriptionDetailsScalarFieldEnum]


  export const ShippingMethodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    minAmount: 'minAmount',
    useWeight: 'useWeight',
    ratePerKg: 'ratePerKg',
    fixedRate: 'fixedRate',
    isActive: 'isActive',
    organisationId: 'organisationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShippingMethodScalarFieldEnum = (typeof ShippingMethodScalarFieldEnum)[keyof typeof ShippingMethodScalarFieldEnum]


  export const TransactionShippingScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    methodName: 'methodName',
    methodType: 'methodType',
    baseRate: 'baseRate',
    weightCharge: 'weightCharge',
    totalWeight: 'totalWeight',
    totalCost: 'totalCost'
  };

  export type TransactionShippingScalarFieldEnum = (typeof TransactionShippingScalarFieldEnum)[keyof typeof TransactionShippingScalarFieldEnum]


  export const MandateScalarFieldEnum: {
    id: 'id',
    organisationId: 'organisationId',
    merchantTranId: 'merchantTranId',
    bankRRN: 'bankRRN',
    UMN: 'UMN',
    amount: 'amount',
    status: 'status',
    payerVA: 'payerVA',
    payerName: 'payerName',
    payerMobile: 'payerMobile',
    txnInitDate: 'txnInitDate',
    txnCompletionDate: 'txnCompletionDate',
    responseCode: 'responseCode',
    respCodeDescription: 'respCodeDescription'
  };

  export type MandateScalarFieldEnum = (typeof MandateScalarFieldEnum)[keyof typeof MandateScalarFieldEnum]


  export const ActiveMandateScalarFieldEnum: {
    id: 'id',
    organisationId: 'organisationId',
    UMN: 'UMN',
    mandateSeqNo: 'mandateSeqNo',
    amount: 'amount',
    notificationRetries: 'notificationRetries',
    retryCount: 'retryCount',
    status: 'status',
    payerVA: 'payerVA',
    payerName: 'payerName',
    payerMobile: 'payerMobile',
    notified: 'notified',
    lastAttemptAt: 'lastAttemptAt',
    lastNotificationAttempt: 'lastNotificationAttempt'
  };

  export type ActiveMandateScalarFieldEnum = (typeof ActiveMandateScalarFieldEnum)[keyof typeof ActiveMandateScalarFieldEnum]


  export const MandateNotificationScalarFieldEnum: {
    id: 'id',
    organisationId: 'organisationId',
    type: 'type',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type MandateNotificationScalarFieldEnum = (typeof MandateNotificationScalarFieldEnum)[keyof typeof MandateNotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const OrganisationOrderByRelevanceFieldEnum: {
    password: 'password',
    resetToken: 'resetToken',
    email: 'email',
    phone: 'phone',
    name: 'name',
    companySize: 'companySize',
    shopName: 'shopName',
    flatNo: 'flatNo',
    street: 'street',
    district: 'district',
    city: 'city',
    state: 'state',
    country: 'country',
    pincode: 'pincode',
    mobileNumber: 'mobileNumber',
    landlineNumber: 'landlineNumber',
    websiteAddress: 'websiteAddress',
    gstNumber: 'gstNumber',
    subscriptionType: 'subscriptionType',
    whatsappNumber: 'whatsappNumber',
    razorpayAccessToken: 'razorpayAccessToken',
    razorpayRefreshToken: 'razorpayRefreshToken',
    razorpayAccountId: 'razorpayAccountId',
    razorpayState: 'razorpayState'
  };

  export type OrganisationOrderByRelevanceFieldEnum = (typeof OrganisationOrderByRelevanceFieldEnum)[keyof typeof OrganisationOrderByRelevanceFieldEnum]


  export const CustomerSubmissionOrderByRelevanceFieldEnum: {
    token: 'token',
    notes: 'notes',
    status: 'status'
  };

  export type CustomerSubmissionOrderByRelevanceFieldEnum = (typeof CustomerSubmissionOrderByRelevanceFieldEnum)[keyof typeof CustomerSubmissionOrderByRelevanceFieldEnum]


  export const ProductCategoryOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type ProductCategoryOrderByRelevanceFieldEnum = (typeof ProductCategoryOrderByRelevanceFieldEnum)[keyof typeof ProductCategoryOrderByRelevanceFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    name: 'name',
    SKU: 'SKU',
    seller: 'seller'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const SellerOrderByRelevanceFieldEnum: {
    name: 'name',
    contact: 'contact',
    type: 'type'
  };

  export type SellerOrderByRelevanceFieldEnum = (typeof SellerOrderByRelevanceFieldEnum)[keyof typeof SellerOrderByRelevanceFieldEnum]


  export const TransactionRecordOrderByRelevanceFieldEnum: {
    paymentMethod: 'paymentMethod',
    billingMode: 'billingMode',
    trackingNumber: 'trackingNumber',
    status: 'status',
    notes: 'notes',
    paymentId: 'paymentId'
  };

  export type TransactionRecordOrderByRelevanceFieldEnum = (typeof TransactionRecordOrderByRelevanceFieldEnum)[keyof typeof TransactionRecordOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    district: 'district',
    state: 'state',
    pincode: 'pincode',
    email: 'email',
    flatNo: 'flatNo',
    street: 'street'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const SubscriptionDetailsOrderByRelevanceFieldEnum: {
    shopName: 'shopName',
    mobileNumber: 'mobileNumber'
  };

  export type SubscriptionDetailsOrderByRelevanceFieldEnum = (typeof SubscriptionDetailsOrderByRelevanceFieldEnum)[keyof typeof SubscriptionDetailsOrderByRelevanceFieldEnum]


  export const ShippingMethodOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type ShippingMethodOrderByRelevanceFieldEnum = (typeof ShippingMethodOrderByRelevanceFieldEnum)[keyof typeof ShippingMethodOrderByRelevanceFieldEnum]


  export const TransactionShippingOrderByRelevanceFieldEnum: {
    methodName: 'methodName'
  };

  export type TransactionShippingOrderByRelevanceFieldEnum = (typeof TransactionShippingOrderByRelevanceFieldEnum)[keyof typeof TransactionShippingOrderByRelevanceFieldEnum]


  export const MandateOrderByRelevanceFieldEnum: {
    merchantTranId: 'merchantTranId',
    bankRRN: 'bankRRN',
    UMN: 'UMN',
    status: 'status',
    payerVA: 'payerVA',
    payerName: 'payerName',
    payerMobile: 'payerMobile',
    responseCode: 'responseCode',
    respCodeDescription: 'respCodeDescription'
  };

  export type MandateOrderByRelevanceFieldEnum = (typeof MandateOrderByRelevanceFieldEnum)[keyof typeof MandateOrderByRelevanceFieldEnum]


  export const ActiveMandateOrderByRelevanceFieldEnum: {
    UMN: 'UMN',
    status: 'status',
    payerVA: 'payerVA',
    payerName: 'payerName',
    payerMobile: 'payerMobile'
  };

  export type ActiveMandateOrderByRelevanceFieldEnum = (typeof ActiveMandateOrderByRelevanceFieldEnum)[keyof typeof ActiveMandateOrderByRelevanceFieldEnum]


  export const MandateNotificationOrderByRelevanceFieldEnum: {
    type: 'type',
    message: 'message'
  };

  export type MandateNotificationOrderByRelevanceFieldEnum = (typeof MandateNotificationOrderByRelevanceFieldEnum)[keyof typeof MandateNotificationOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ShippingMethodType'
   */
  export type EnumShippingMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingMethodType'>
    
  /**
   * Deep Input Types
   */


  export type OrganisationWhereInput = {
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    id?: IntFilter<"Organisation"> | number
    password?: StringFilter<"Organisation"> | string
    resetToken?: StringNullableFilter<"Organisation"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    email?: StringFilter<"Organisation"> | string
    phone?: StringFilter<"Organisation"> | string
    name?: StringFilter<"Organisation"> | string
    companySize?: StringFilter<"Organisation"> | string
    shopName?: StringFilter<"Organisation"> | string
    flatNo?: StringFilter<"Organisation"> | string
    street?: StringFilter<"Organisation"> | string
    district?: StringFilter<"Organisation"> | string
    city?: StringNullableFilter<"Organisation"> | string | null
    state?: StringFilter<"Organisation"> | string
    smsCount?: IntFilter<"Organisation"> | number
    smsCost?: FloatFilter<"Organisation"> | number
    country?: StringFilter<"Organisation"> | string
    pincode?: StringFilter<"Organisation"> | string
    mobileNumber?: StringFilter<"Organisation"> | string
    landlineNumber?: StringNullableFilter<"Organisation"> | string | null
    websiteAddress?: StringNullableFilter<"Organisation"> | string | null
    gstNumber?: StringNullableFilter<"Organisation"> | string | null
    subscriptionType?: StringFilter<"Organisation"> | string
    endDate?: DateTimeFilter<"Organisation"> | Date | string
    whatsappNumber?: StringNullableFilter<"Organisation"> | string | null
    createdAt?: DateTimeFilter<"Organisation"> | Date | string
    updatedAt?: DateTimeFilter<"Organisation"> | Date | string
    razorpayAccessToken?: StringNullableFilter<"Organisation"> | string | null
    razorpayRefreshToken?: StringNullableFilter<"Organisation"> | string | null
    razorpayTokenExpiresAt?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    razorpayAccountId?: StringNullableFilter<"Organisation"> | string | null
    razorpayState?: StringNullableFilter<"Organisation"> | string | null
    razorpayStateExpiresAt?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    monthlyUsage?: IntFilter<"Organisation"> | number
    productCategories?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    sellers?: SellerListRelationFilter
    transactions?: TransactionRecordListRelationFilter
    customers?: CustomerListRelationFilter
    inventory?: InventoryListRelationFilter
    CustomerSubmission?: CustomerSubmissionListRelationFilter
    ShippingMethod?: ShippingMethodListRelationFilter
    Mandate?: MandateListRelationFilter
    activeMandates?: XOR<ActiveMandateNullableScalarRelationFilter, ActiveMandateWhereInput> | null
    MandateNotification?: MandateNotificationListRelationFilter
  }

  export type OrganisationOrderByWithRelationInput = {
    id?: SortOrder
    password?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    companySize?: SortOrder
    shopName?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    district?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrder
    smsCount?: SortOrder
    smsCost?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobileNumber?: SortOrder
    landlineNumber?: SortOrderInput | SortOrder
    websiteAddress?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    subscriptionType?: SortOrder
    endDate?: SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    razorpayAccessToken?: SortOrderInput | SortOrder
    razorpayRefreshToken?: SortOrderInput | SortOrder
    razorpayTokenExpiresAt?: SortOrderInput | SortOrder
    razorpayAccountId?: SortOrderInput | SortOrder
    razorpayState?: SortOrderInput | SortOrder
    razorpayStateExpiresAt?: SortOrderInput | SortOrder
    monthlyUsage?: SortOrder
    productCategories?: ProductCategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    sellers?: SellerOrderByRelationAggregateInput
    transactions?: TransactionRecordOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    CustomerSubmission?: CustomerSubmissionOrderByRelationAggregateInput
    ShippingMethod?: ShippingMethodOrderByRelationAggregateInput
    Mandate?: MandateOrderByRelationAggregateInput
    activeMandates?: ActiveMandateOrderByWithRelationInput
    MandateNotification?: MandateNotificationOrderByRelationAggregateInput
    _relevance?: OrganisationOrderByRelevanceInput
  }

  export type OrganisationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    password?: StringFilter<"Organisation"> | string
    resetToken?: StringNullableFilter<"Organisation"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    phone?: StringFilter<"Organisation"> | string
    name?: StringFilter<"Organisation"> | string
    companySize?: StringFilter<"Organisation"> | string
    shopName?: StringFilter<"Organisation"> | string
    flatNo?: StringFilter<"Organisation"> | string
    street?: StringFilter<"Organisation"> | string
    district?: StringFilter<"Organisation"> | string
    city?: StringNullableFilter<"Organisation"> | string | null
    state?: StringFilter<"Organisation"> | string
    smsCount?: IntFilter<"Organisation"> | number
    smsCost?: FloatFilter<"Organisation"> | number
    country?: StringFilter<"Organisation"> | string
    pincode?: StringFilter<"Organisation"> | string
    mobileNumber?: StringFilter<"Organisation"> | string
    landlineNumber?: StringNullableFilter<"Organisation"> | string | null
    websiteAddress?: StringNullableFilter<"Organisation"> | string | null
    gstNumber?: StringNullableFilter<"Organisation"> | string | null
    subscriptionType?: StringFilter<"Organisation"> | string
    endDate?: DateTimeFilter<"Organisation"> | Date | string
    whatsappNumber?: StringNullableFilter<"Organisation"> | string | null
    createdAt?: DateTimeFilter<"Organisation"> | Date | string
    updatedAt?: DateTimeFilter<"Organisation"> | Date | string
    razorpayAccessToken?: StringNullableFilter<"Organisation"> | string | null
    razorpayRefreshToken?: StringNullableFilter<"Organisation"> | string | null
    razorpayTokenExpiresAt?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    razorpayAccountId?: StringNullableFilter<"Organisation"> | string | null
    razorpayState?: StringNullableFilter<"Organisation"> | string | null
    razorpayStateExpiresAt?: DateTimeNullableFilter<"Organisation"> | Date | string | null
    monthlyUsage?: IntFilter<"Organisation"> | number
    productCategories?: ProductCategoryListRelationFilter
    products?: ProductListRelationFilter
    sellers?: SellerListRelationFilter
    transactions?: TransactionRecordListRelationFilter
    customers?: CustomerListRelationFilter
    inventory?: InventoryListRelationFilter
    CustomerSubmission?: CustomerSubmissionListRelationFilter
    ShippingMethod?: ShippingMethodListRelationFilter
    Mandate?: MandateListRelationFilter
    activeMandates?: XOR<ActiveMandateNullableScalarRelationFilter, ActiveMandateWhereInput> | null
    MandateNotification?: MandateNotificationListRelationFilter
  }, "id" | "email">

  export type OrganisationOrderByWithAggregationInput = {
    id?: SortOrder
    password?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    companySize?: SortOrder
    shopName?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    district?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrder
    smsCount?: SortOrder
    smsCost?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobileNumber?: SortOrder
    landlineNumber?: SortOrderInput | SortOrder
    websiteAddress?: SortOrderInput | SortOrder
    gstNumber?: SortOrderInput | SortOrder
    subscriptionType?: SortOrder
    endDate?: SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    razorpayAccessToken?: SortOrderInput | SortOrder
    razorpayRefreshToken?: SortOrderInput | SortOrder
    razorpayTokenExpiresAt?: SortOrderInput | SortOrder
    razorpayAccountId?: SortOrderInput | SortOrder
    razorpayState?: SortOrderInput | SortOrder
    razorpayStateExpiresAt?: SortOrderInput | SortOrder
    monthlyUsage?: SortOrder
    _count?: OrganisationCountOrderByAggregateInput
    _avg?: OrganisationAvgOrderByAggregateInput
    _max?: OrganisationMaxOrderByAggregateInput
    _min?: OrganisationMinOrderByAggregateInput
    _sum?: OrganisationSumOrderByAggregateInput
  }

  export type OrganisationScalarWhereWithAggregatesInput = {
    AND?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    OR?: OrganisationScalarWhereWithAggregatesInput[]
    NOT?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organisation"> | number
    password?: StringWithAggregatesFilter<"Organisation"> | string
    resetToken?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"Organisation"> | Date | string | null
    email?: StringWithAggregatesFilter<"Organisation"> | string
    phone?: StringWithAggregatesFilter<"Organisation"> | string
    name?: StringWithAggregatesFilter<"Organisation"> | string
    companySize?: StringWithAggregatesFilter<"Organisation"> | string
    shopName?: StringWithAggregatesFilter<"Organisation"> | string
    flatNo?: StringWithAggregatesFilter<"Organisation"> | string
    street?: StringWithAggregatesFilter<"Organisation"> | string
    district?: StringWithAggregatesFilter<"Organisation"> | string
    city?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    state?: StringWithAggregatesFilter<"Organisation"> | string
    smsCount?: IntWithAggregatesFilter<"Organisation"> | number
    smsCost?: FloatWithAggregatesFilter<"Organisation"> | number
    country?: StringWithAggregatesFilter<"Organisation"> | string
    pincode?: StringWithAggregatesFilter<"Organisation"> | string
    mobileNumber?: StringWithAggregatesFilter<"Organisation"> | string
    landlineNumber?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    websiteAddress?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    gstNumber?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    subscriptionType?: StringWithAggregatesFilter<"Organisation"> | string
    endDate?: DateTimeWithAggregatesFilter<"Organisation"> | Date | string
    whatsappNumber?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organisation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organisation"> | Date | string
    razorpayAccessToken?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    razorpayRefreshToken?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    razorpayTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Organisation"> | Date | string | null
    razorpayAccountId?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    razorpayState?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    razorpayStateExpiresAt?: DateTimeNullableWithAggregatesFilter<"Organisation"> | Date | string | null
    monthlyUsage?: IntWithAggregatesFilter<"Organisation"> | number
  }

  export type CustomerSubmissionWhereInput = {
    AND?: CustomerSubmissionWhereInput | CustomerSubmissionWhereInput[]
    OR?: CustomerSubmissionWhereInput[]
    NOT?: CustomerSubmissionWhereInput | CustomerSubmissionWhereInput[]
    id?: IntFilter<"CustomerSubmission"> | number
    token?: StringFilter<"CustomerSubmission"> | string
    organisationId?: IntFilter<"CustomerSubmission"> | number
    customerId?: IntNullableFilter<"CustomerSubmission"> | number | null
    notes?: StringNullableFilter<"CustomerSubmission"> | string | null
    status?: StringFilter<"CustomerSubmission"> | string
    createdAt?: DateTimeFilter<"CustomerSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSubmission"> | Date | string
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    customers?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type CustomerSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    organisationId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    customers?: CustomerOrderByWithRelationInput
    _relevance?: CustomerSubmissionOrderByRelevanceInput
  }

  export type CustomerSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: CustomerSubmissionWhereInput | CustomerSubmissionWhereInput[]
    OR?: CustomerSubmissionWhereInput[]
    NOT?: CustomerSubmissionWhereInput | CustomerSubmissionWhereInput[]
    organisationId?: IntFilter<"CustomerSubmission"> | number
    customerId?: IntNullableFilter<"CustomerSubmission"> | number | null
    notes?: StringNullableFilter<"CustomerSubmission"> | string | null
    status?: StringFilter<"CustomerSubmission"> | string
    createdAt?: DateTimeFilter<"CustomerSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSubmission"> | Date | string
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    customers?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id" | "token">

  export type CustomerSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    organisationId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerSubmissionCountOrderByAggregateInput
    _avg?: CustomerSubmissionAvgOrderByAggregateInput
    _max?: CustomerSubmissionMaxOrderByAggregateInput
    _min?: CustomerSubmissionMinOrderByAggregateInput
    _sum?: CustomerSubmissionSumOrderByAggregateInput
  }

  export type CustomerSubmissionScalarWhereWithAggregatesInput = {
    AND?: CustomerSubmissionScalarWhereWithAggregatesInput | CustomerSubmissionScalarWhereWithAggregatesInput[]
    OR?: CustomerSubmissionScalarWhereWithAggregatesInput[]
    NOT?: CustomerSubmissionScalarWhereWithAggregatesInput | CustomerSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerSubmission"> | number
    token?: StringWithAggregatesFilter<"CustomerSubmission"> | string
    organisationId?: IntWithAggregatesFilter<"CustomerSubmission"> | number
    customerId?: IntNullableWithAggregatesFilter<"CustomerSubmission"> | number | null
    notes?: StringNullableWithAggregatesFilter<"CustomerSubmission"> | string | null
    status?: StringWithAggregatesFilter<"CustomerSubmission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerSubmission"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    organisationId?: IntFilter<"ProductCategory"> | number
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    products?: ProductListRelationFilter
    inventory?: InventoryListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    organisationId?: SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    _relevance?: ProductCategoryOrderByRelevanceInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringFilter<"ProductCategory"> | string
    organisationId?: IntFilter<"ProductCategory"> | number
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    products?: ProductListRelationFilter
    inventory?: InventoryListRelationFilter
  }, "id">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    organisationId?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductCategory"> | number
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    organisationId?: IntWithAggregatesFilter<"ProductCategory"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    SKU?: StringFilter<"Product"> | string
    netPrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    seller?: StringFilter<"Product"> | string
    organisationId?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    inventory?: InventoryListRelationFilter
    transactionItems?: TransactionItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    netPrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    seller?: SortOrder
    organisationId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    inventory?: InventoryOrderByRelationAggregateInput
    transactionItems?: TransactionItemOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    SKU?: StringFilter<"Product"> | string
    netPrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    seller?: StringFilter<"Product"> | string
    organisationId?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    inventory?: InventoryListRelationFilter
    transactionItems?: TransactionItemListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    netPrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    seller?: SortOrder
    organisationId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    SKU?: StringWithAggregatesFilter<"Product"> | string
    netPrice?: FloatWithAggregatesFilter<"Product"> | number
    sellingPrice?: FloatWithAggregatesFilter<"Product"> | number
    quantity?: IntWithAggregatesFilter<"Product"> | number
    seller?: StringWithAggregatesFilter<"Product"> | string
    organisationId?: IntWithAggregatesFilter<"Product"> | number
    categoryId?: IntNullableWithAggregatesFilter<"Product"> | number | null
  }

  export type SellerWhereInput = {
    AND?: SellerWhereInput | SellerWhereInput[]
    OR?: SellerWhereInput[]
    NOT?: SellerWhereInput | SellerWhereInput[]
    id?: IntFilter<"Seller"> | number
    name?: StringFilter<"Seller"> | string
    contact?: StringFilter<"Seller"> | string
    type?: StringFilter<"Seller"> | string
    organisationId?: IntFilter<"Seller"> | number
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }

  export type SellerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    type?: SortOrder
    organisationId?: SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    _relevance?: SellerOrderByRelevanceInput
  }

  export type SellerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SellerWhereInput | SellerWhereInput[]
    OR?: SellerWhereInput[]
    NOT?: SellerWhereInput | SellerWhereInput[]
    name?: StringFilter<"Seller"> | string
    contact?: StringFilter<"Seller"> | string
    type?: StringFilter<"Seller"> | string
    organisationId?: IntFilter<"Seller"> | number
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }, "id">

  export type SellerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    type?: SortOrder
    organisationId?: SortOrder
    _count?: SellerCountOrderByAggregateInput
    _avg?: SellerAvgOrderByAggregateInput
    _max?: SellerMaxOrderByAggregateInput
    _min?: SellerMinOrderByAggregateInput
    _sum?: SellerSumOrderByAggregateInput
  }

  export type SellerScalarWhereWithAggregatesInput = {
    AND?: SellerScalarWhereWithAggregatesInput | SellerScalarWhereWithAggregatesInput[]
    OR?: SellerScalarWhereWithAggregatesInput[]
    NOT?: SellerScalarWhereWithAggregatesInput | SellerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Seller"> | number
    name?: StringWithAggregatesFilter<"Seller"> | string
    contact?: StringWithAggregatesFilter<"Seller"> | string
    type?: StringWithAggregatesFilter<"Seller"> | string
    organisationId?: IntWithAggregatesFilter<"Seller"> | number
  }

  export type TransactionRecordWhereInput = {
    AND?: TransactionRecordWhereInput | TransactionRecordWhereInput[]
    OR?: TransactionRecordWhereInput[]
    NOT?: TransactionRecordWhereInput | TransactionRecordWhereInput[]
    id?: IntFilter<"TransactionRecord"> | number
    billNo?: IntFilter<"TransactionRecord"> | number
    totalPrice?: FloatFilter<"TransactionRecord"> | number
    paymentMethod?: StringFilter<"TransactionRecord"> | string
    amountPaid?: FloatFilter<"TransactionRecord"> | number
    balance?: FloatFilter<"TransactionRecord"> | number
    billingMode?: StringFilter<"TransactionRecord"> | string
    organisationId?: IntFilter<"TransactionRecord"> | number
    date?: DateTimeFilter<"TransactionRecord"> | Date | string
    time?: DateTimeFilter<"TransactionRecord"> | Date | string
    trackingNumber?: StringNullableFilter<"TransactionRecord"> | string | null
    weight?: FloatNullableFilter<"TransactionRecord"> | number | null
    customerId?: IntNullableFilter<"TransactionRecord"> | number | null
    status?: StringFilter<"TransactionRecord"> | string
    notes?: StringNullableFilter<"TransactionRecord"> | string | null
    paymentId?: StringNullableFilter<"TransactionRecord"> | string | null
    paymentStatus?: EnumPaymentStatusFilter<"TransactionRecord"> | $Enums.PaymentStatus
    isEdited?: BoolFilter<"TransactionRecord"> | boolean
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: TransactionItemListRelationFilter
    TransactionShipping?: TransactionShippingListRelationFilter
  }

  export type TransactionRecordOrderByWithRelationInput = {
    id?: SortOrder
    billNo?: SortOrder
    totalPrice?: SortOrder
    paymentMethod?: SortOrder
    amountPaid?: SortOrder
    balance?: SortOrder
    billingMode?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    isEdited?: SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    items?: TransactionItemOrderByRelationAggregateInput
    TransactionShipping?: TransactionShippingOrderByRelationAggregateInput
    _relevance?: TransactionRecordOrderByRelevanceInput
  }

  export type TransactionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    billNo?: number
    AND?: TransactionRecordWhereInput | TransactionRecordWhereInput[]
    OR?: TransactionRecordWhereInput[]
    NOT?: TransactionRecordWhereInput | TransactionRecordWhereInput[]
    totalPrice?: FloatFilter<"TransactionRecord"> | number
    paymentMethod?: StringFilter<"TransactionRecord"> | string
    amountPaid?: FloatFilter<"TransactionRecord"> | number
    balance?: FloatFilter<"TransactionRecord"> | number
    billingMode?: StringFilter<"TransactionRecord"> | string
    organisationId?: IntFilter<"TransactionRecord"> | number
    date?: DateTimeFilter<"TransactionRecord"> | Date | string
    time?: DateTimeFilter<"TransactionRecord"> | Date | string
    trackingNumber?: StringNullableFilter<"TransactionRecord"> | string | null
    weight?: FloatNullableFilter<"TransactionRecord"> | number | null
    customerId?: IntNullableFilter<"TransactionRecord"> | number | null
    status?: StringFilter<"TransactionRecord"> | string
    notes?: StringNullableFilter<"TransactionRecord"> | string | null
    paymentId?: StringNullableFilter<"TransactionRecord"> | string | null
    paymentStatus?: EnumPaymentStatusFilter<"TransactionRecord"> | $Enums.PaymentStatus
    isEdited?: BoolFilter<"TransactionRecord"> | boolean
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: TransactionItemListRelationFilter
    TransactionShipping?: TransactionShippingListRelationFilter
  }, "id" | "billNo">

  export type TransactionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    billNo?: SortOrder
    totalPrice?: SortOrder
    paymentMethod?: SortOrder
    amountPaid?: SortOrder
    balance?: SortOrder
    billingMode?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    isEdited?: SortOrder
    _count?: TransactionRecordCountOrderByAggregateInput
    _avg?: TransactionRecordAvgOrderByAggregateInput
    _max?: TransactionRecordMaxOrderByAggregateInput
    _min?: TransactionRecordMinOrderByAggregateInput
    _sum?: TransactionRecordSumOrderByAggregateInput
  }

  export type TransactionRecordScalarWhereWithAggregatesInput = {
    AND?: TransactionRecordScalarWhereWithAggregatesInput | TransactionRecordScalarWhereWithAggregatesInput[]
    OR?: TransactionRecordScalarWhereWithAggregatesInput[]
    NOT?: TransactionRecordScalarWhereWithAggregatesInput | TransactionRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransactionRecord"> | number
    billNo?: IntWithAggregatesFilter<"TransactionRecord"> | number
    totalPrice?: FloatWithAggregatesFilter<"TransactionRecord"> | number
    paymentMethod?: StringWithAggregatesFilter<"TransactionRecord"> | string
    amountPaid?: FloatWithAggregatesFilter<"TransactionRecord"> | number
    balance?: FloatWithAggregatesFilter<"TransactionRecord"> | number
    billingMode?: StringWithAggregatesFilter<"TransactionRecord"> | string
    organisationId?: IntWithAggregatesFilter<"TransactionRecord"> | number
    date?: DateTimeWithAggregatesFilter<"TransactionRecord"> | Date | string
    time?: DateTimeWithAggregatesFilter<"TransactionRecord"> | Date | string
    trackingNumber?: StringNullableWithAggregatesFilter<"TransactionRecord"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"TransactionRecord"> | number | null
    customerId?: IntNullableWithAggregatesFilter<"TransactionRecord"> | number | null
    status?: StringWithAggregatesFilter<"TransactionRecord"> | string
    notes?: StringNullableWithAggregatesFilter<"TransactionRecord"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"TransactionRecord"> | string | null
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"TransactionRecord"> | $Enums.PaymentStatus
    isEdited?: BoolWithAggregatesFilter<"TransactionRecord"> | boolean
  }

  export type TransactionItemWhereInput = {
    AND?: TransactionItemWhereInput | TransactionItemWhereInput[]
    OR?: TransactionItemWhereInput[]
    NOT?: TransactionItemWhereInput | TransactionItemWhereInput[]
    id?: IntFilter<"TransactionItem"> | number
    transactionId?: IntFilter<"TransactionItem"> | number
    productId?: IntFilter<"TransactionItem"> | number
    quantity?: IntFilter<"TransactionItem"> | number
    totalPrice?: FloatFilter<"TransactionItem"> | number
    transaction?: XOR<TransactionRecordScalarRelationFilter, TransactionRecordWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type TransactionItemOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    transaction?: TransactionRecordOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type TransactionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionItemWhereInput | TransactionItemWhereInput[]
    OR?: TransactionItemWhereInput[]
    NOT?: TransactionItemWhereInput | TransactionItemWhereInput[]
    transactionId?: IntFilter<"TransactionItem"> | number
    productId?: IntFilter<"TransactionItem"> | number
    quantity?: IntFilter<"TransactionItem"> | number
    totalPrice?: FloatFilter<"TransactionItem"> | number
    transaction?: XOR<TransactionRecordScalarRelationFilter, TransactionRecordWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type TransactionItemOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    _count?: TransactionItemCountOrderByAggregateInput
    _avg?: TransactionItemAvgOrderByAggregateInput
    _max?: TransactionItemMaxOrderByAggregateInput
    _min?: TransactionItemMinOrderByAggregateInput
    _sum?: TransactionItemSumOrderByAggregateInput
  }

  export type TransactionItemScalarWhereWithAggregatesInput = {
    AND?: TransactionItemScalarWhereWithAggregatesInput | TransactionItemScalarWhereWithAggregatesInput[]
    OR?: TransactionItemScalarWhereWithAggregatesInput[]
    NOT?: TransactionItemScalarWhereWithAggregatesInput | TransactionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransactionItem"> | number
    transactionId?: IntWithAggregatesFilter<"TransactionItem"> | number
    productId?: IntWithAggregatesFilter<"TransactionItem"> | number
    quantity?: IntWithAggregatesFilter<"TransactionItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"TransactionItem"> | number
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    district?: StringNullableFilter<"Customer"> | string | null
    state?: StringNullableFilter<"Customer"> | string | null
    pincode?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    flatNo?: StringNullableFilter<"Customer"> | string | null
    street?: StringNullableFilter<"Customer"> | string | null
    organisationId?: IntFilter<"Customer"> | number
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    transactions?: TransactionRecordListRelationFilter
    CustomerSubmission?: CustomerSubmissionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    district?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    flatNo?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    transactions?: TransactionRecordOrderByRelationAggregateInput
    CustomerSubmission?: CustomerSubmissionOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    district?: StringNullableFilter<"Customer"> | string | null
    state?: StringNullableFilter<"Customer"> | string | null
    pincode?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    flatNo?: StringNullableFilter<"Customer"> | string | null
    street?: StringNullableFilter<"Customer"> | string | null
    organisationId?: IntFilter<"Customer"> | number
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
    transactions?: TransactionRecordListRelationFilter
    CustomerSubmission?: CustomerSubmissionListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    district?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    flatNo?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    district?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    state?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    flatNo?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    street?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    organisationId?: IntWithAggregatesFilter<"Customer"> | number
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: IntFilter<"Inventory"> | number
    productId?: IntFilter<"Inventory"> | number
    categoryId?: IntNullableFilter<"Inventory"> | number | null
    organisationId?: IntFilter<"Inventory"> | number
    quantity?: IntFilter<"Inventory"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    quantity?: SortOrder
    product?: ProductOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    organisation?: OrganisationOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId_organisationId?: InventoryProductIdOrganisationIdCompoundUniqueInput
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    productId?: IntFilter<"Inventory"> | number
    categoryId?: IntNullableFilter<"Inventory"> | number | null
    organisationId?: IntFilter<"Inventory"> | number
    quantity?: IntFilter<"Inventory"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<ProductCategoryNullableScalarRelationFilter, ProductCategoryWhereInput> | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }, "id" | "productId_organisationId">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    quantity?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventory"> | number
    productId?: IntWithAggregatesFilter<"Inventory"> | number
    categoryId?: IntNullableWithAggregatesFilter<"Inventory"> | number | null
    organisationId?: IntWithAggregatesFilter<"Inventory"> | number
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
  }

  export type SubscriptionDetailsWhereInput = {
    AND?: SubscriptionDetailsWhereInput | SubscriptionDetailsWhereInput[]
    OR?: SubscriptionDetailsWhereInput[]
    NOT?: SubscriptionDetailsWhereInput | SubscriptionDetailsWhereInput[]
    id?: IntFilter<"SubscriptionDetails"> | number
    organisationId?: IntFilter<"SubscriptionDetails"> | number
    date?: DateTimeFilter<"SubscriptionDetails"> | Date | string
    month?: IntFilter<"SubscriptionDetails"> | number
    year?: IntFilter<"SubscriptionDetails"> | number
    smsCount?: IntFilter<"SubscriptionDetails"> | number
    shopName?: StringFilter<"SubscriptionDetails"> | string
    mobileNumber?: StringFilter<"SubscriptionDetails"> | string
  }

  export type SubscriptionDetailsOrderByWithRelationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    month?: SortOrder
    year?: SortOrder
    smsCount?: SortOrder
    shopName?: SortOrder
    mobileNumber?: SortOrder
    _relevance?: SubscriptionDetailsOrderByRelevanceInput
  }

  export type SubscriptionDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubscriptionDetailsWhereInput | SubscriptionDetailsWhereInput[]
    OR?: SubscriptionDetailsWhereInput[]
    NOT?: SubscriptionDetailsWhereInput | SubscriptionDetailsWhereInput[]
    organisationId?: IntFilter<"SubscriptionDetails"> | number
    date?: DateTimeFilter<"SubscriptionDetails"> | Date | string
    month?: IntFilter<"SubscriptionDetails"> | number
    year?: IntFilter<"SubscriptionDetails"> | number
    smsCount?: IntFilter<"SubscriptionDetails"> | number
    shopName?: StringFilter<"SubscriptionDetails"> | string
    mobileNumber?: StringFilter<"SubscriptionDetails"> | string
  }, "id">

  export type SubscriptionDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    month?: SortOrder
    year?: SortOrder
    smsCount?: SortOrder
    shopName?: SortOrder
    mobileNumber?: SortOrder
    _count?: SubscriptionDetailsCountOrderByAggregateInput
    _avg?: SubscriptionDetailsAvgOrderByAggregateInput
    _max?: SubscriptionDetailsMaxOrderByAggregateInput
    _min?: SubscriptionDetailsMinOrderByAggregateInput
    _sum?: SubscriptionDetailsSumOrderByAggregateInput
  }

  export type SubscriptionDetailsScalarWhereWithAggregatesInput = {
    AND?: SubscriptionDetailsScalarWhereWithAggregatesInput | SubscriptionDetailsScalarWhereWithAggregatesInput[]
    OR?: SubscriptionDetailsScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionDetailsScalarWhereWithAggregatesInput | SubscriptionDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SubscriptionDetails"> | number
    organisationId?: IntWithAggregatesFilter<"SubscriptionDetails"> | number
    date?: DateTimeWithAggregatesFilter<"SubscriptionDetails"> | Date | string
    month?: IntWithAggregatesFilter<"SubscriptionDetails"> | number
    year?: IntWithAggregatesFilter<"SubscriptionDetails"> | number
    smsCount?: IntWithAggregatesFilter<"SubscriptionDetails"> | number
    shopName?: StringWithAggregatesFilter<"SubscriptionDetails"> | string
    mobileNumber?: StringWithAggregatesFilter<"SubscriptionDetails"> | string
  }

  export type ShippingMethodWhereInput = {
    AND?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    OR?: ShippingMethodWhereInput[]
    NOT?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    id?: IntFilter<"ShippingMethod"> | number
    name?: StringFilter<"ShippingMethod"> | string
    type?: EnumShippingMethodTypeFilter<"ShippingMethod"> | $Enums.ShippingMethodType
    minAmount?: FloatNullableFilter<"ShippingMethod"> | number | null
    useWeight?: BoolFilter<"ShippingMethod"> | boolean
    ratePerKg?: FloatNullableFilter<"ShippingMethod"> | number | null
    fixedRate?: FloatNullableFilter<"ShippingMethod"> | number | null
    isActive?: BoolFilter<"ShippingMethod"> | boolean
    organisationId?: IntFilter<"ShippingMethod"> | number
    createdAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }

  export type ShippingMethodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    useWeight?: SortOrder
    ratePerKg?: SortOrderInput | SortOrder
    fixedRate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    _relevance?: ShippingMethodOrderByRelevanceInput
  }

  export type ShippingMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    OR?: ShippingMethodWhereInput[]
    NOT?: ShippingMethodWhereInput | ShippingMethodWhereInput[]
    name?: StringFilter<"ShippingMethod"> | string
    type?: EnumShippingMethodTypeFilter<"ShippingMethod"> | $Enums.ShippingMethodType
    minAmount?: FloatNullableFilter<"ShippingMethod"> | number | null
    useWeight?: BoolFilter<"ShippingMethod"> | boolean
    ratePerKg?: FloatNullableFilter<"ShippingMethod"> | number | null
    fixedRate?: FloatNullableFilter<"ShippingMethod"> | number | null
    isActive?: BoolFilter<"ShippingMethod"> | boolean
    organisationId?: IntFilter<"ShippingMethod"> | number
    createdAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }, "id">

  export type ShippingMethodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    useWeight?: SortOrder
    ratePerKg?: SortOrderInput | SortOrder
    fixedRate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShippingMethodCountOrderByAggregateInput
    _avg?: ShippingMethodAvgOrderByAggregateInput
    _max?: ShippingMethodMaxOrderByAggregateInput
    _min?: ShippingMethodMinOrderByAggregateInput
    _sum?: ShippingMethodSumOrderByAggregateInput
  }

  export type ShippingMethodScalarWhereWithAggregatesInput = {
    AND?: ShippingMethodScalarWhereWithAggregatesInput | ShippingMethodScalarWhereWithAggregatesInput[]
    OR?: ShippingMethodScalarWhereWithAggregatesInput[]
    NOT?: ShippingMethodScalarWhereWithAggregatesInput | ShippingMethodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShippingMethod"> | number
    name?: StringWithAggregatesFilter<"ShippingMethod"> | string
    type?: EnumShippingMethodTypeWithAggregatesFilter<"ShippingMethod"> | $Enums.ShippingMethodType
    minAmount?: FloatNullableWithAggregatesFilter<"ShippingMethod"> | number | null
    useWeight?: BoolWithAggregatesFilter<"ShippingMethod"> | boolean
    ratePerKg?: FloatNullableWithAggregatesFilter<"ShippingMethod"> | number | null
    fixedRate?: FloatNullableWithAggregatesFilter<"ShippingMethod"> | number | null
    isActive?: BoolWithAggregatesFilter<"ShippingMethod"> | boolean
    organisationId?: IntWithAggregatesFilter<"ShippingMethod"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShippingMethod"> | Date | string
  }

  export type TransactionShippingWhereInput = {
    AND?: TransactionShippingWhereInput | TransactionShippingWhereInput[]
    OR?: TransactionShippingWhereInput[]
    NOT?: TransactionShippingWhereInput | TransactionShippingWhereInput[]
    id?: IntFilter<"TransactionShipping"> | number
    transactionId?: IntFilter<"TransactionShipping"> | number
    methodName?: StringFilter<"TransactionShipping"> | string
    methodType?: EnumShippingMethodTypeFilter<"TransactionShipping"> | $Enums.ShippingMethodType
    baseRate?: FloatNullableFilter<"TransactionShipping"> | number | null
    weightCharge?: FloatNullableFilter<"TransactionShipping"> | number | null
    totalWeight?: FloatNullableFilter<"TransactionShipping"> | number | null
    totalCost?: FloatFilter<"TransactionShipping"> | number
    transaction?: XOR<TransactionRecordScalarRelationFilter, TransactionRecordWhereInput>
  }

  export type TransactionShippingOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    methodName?: SortOrder
    methodType?: SortOrder
    baseRate?: SortOrderInput | SortOrder
    weightCharge?: SortOrderInput | SortOrder
    totalWeight?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    transaction?: TransactionRecordOrderByWithRelationInput
    _relevance?: TransactionShippingOrderByRelevanceInput
  }

  export type TransactionShippingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionShippingWhereInput | TransactionShippingWhereInput[]
    OR?: TransactionShippingWhereInput[]
    NOT?: TransactionShippingWhereInput | TransactionShippingWhereInput[]
    transactionId?: IntFilter<"TransactionShipping"> | number
    methodName?: StringFilter<"TransactionShipping"> | string
    methodType?: EnumShippingMethodTypeFilter<"TransactionShipping"> | $Enums.ShippingMethodType
    baseRate?: FloatNullableFilter<"TransactionShipping"> | number | null
    weightCharge?: FloatNullableFilter<"TransactionShipping"> | number | null
    totalWeight?: FloatNullableFilter<"TransactionShipping"> | number | null
    totalCost?: FloatFilter<"TransactionShipping"> | number
    transaction?: XOR<TransactionRecordScalarRelationFilter, TransactionRecordWhereInput>
  }, "id">

  export type TransactionShippingOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    methodName?: SortOrder
    methodType?: SortOrder
    baseRate?: SortOrderInput | SortOrder
    weightCharge?: SortOrderInput | SortOrder
    totalWeight?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    _count?: TransactionShippingCountOrderByAggregateInput
    _avg?: TransactionShippingAvgOrderByAggregateInput
    _max?: TransactionShippingMaxOrderByAggregateInput
    _min?: TransactionShippingMinOrderByAggregateInput
    _sum?: TransactionShippingSumOrderByAggregateInput
  }

  export type TransactionShippingScalarWhereWithAggregatesInput = {
    AND?: TransactionShippingScalarWhereWithAggregatesInput | TransactionShippingScalarWhereWithAggregatesInput[]
    OR?: TransactionShippingScalarWhereWithAggregatesInput[]
    NOT?: TransactionShippingScalarWhereWithAggregatesInput | TransactionShippingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransactionShipping"> | number
    transactionId?: IntWithAggregatesFilter<"TransactionShipping"> | number
    methodName?: StringWithAggregatesFilter<"TransactionShipping"> | string
    methodType?: EnumShippingMethodTypeWithAggregatesFilter<"TransactionShipping"> | $Enums.ShippingMethodType
    baseRate?: FloatNullableWithAggregatesFilter<"TransactionShipping"> | number | null
    weightCharge?: FloatNullableWithAggregatesFilter<"TransactionShipping"> | number | null
    totalWeight?: FloatNullableWithAggregatesFilter<"TransactionShipping"> | number | null
    totalCost?: FloatWithAggregatesFilter<"TransactionShipping"> | number
  }

  export type MandateWhereInput = {
    AND?: MandateWhereInput | MandateWhereInput[]
    OR?: MandateWhereInput[]
    NOT?: MandateWhereInput | MandateWhereInput[]
    id?: IntFilter<"Mandate"> | number
    organisationId?: IntFilter<"Mandate"> | number
    merchantTranId?: StringFilter<"Mandate"> | string
    bankRRN?: StringNullableFilter<"Mandate"> | string | null
    UMN?: StringNullableFilter<"Mandate"> | string | null
    amount?: FloatFilter<"Mandate"> | number
    status?: StringFilter<"Mandate"> | string
    payerVA?: StringFilter<"Mandate"> | string
    payerName?: StringNullableFilter<"Mandate"> | string | null
    payerMobile?: StringNullableFilter<"Mandate"> | string | null
    txnInitDate?: DateTimeNullableFilter<"Mandate"> | Date | string | null
    txnCompletionDate?: DateTimeNullableFilter<"Mandate"> | Date | string | null
    responseCode?: StringNullableFilter<"Mandate"> | string | null
    respCodeDescription?: StringNullableFilter<"Mandate"> | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }

  export type MandateOrderByWithRelationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    merchantTranId?: SortOrder
    bankRRN?: SortOrderInput | SortOrder
    UMN?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrderInput | SortOrder
    payerMobile?: SortOrderInput | SortOrder
    txnInitDate?: SortOrderInput | SortOrder
    txnCompletionDate?: SortOrderInput | SortOrder
    responseCode?: SortOrderInput | SortOrder
    respCodeDescription?: SortOrderInput | SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    _relevance?: MandateOrderByRelevanceInput
  }

  export type MandateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    merchantTranId?: string
    AND?: MandateWhereInput | MandateWhereInput[]
    OR?: MandateWhereInput[]
    NOT?: MandateWhereInput | MandateWhereInput[]
    organisationId?: IntFilter<"Mandate"> | number
    bankRRN?: StringNullableFilter<"Mandate"> | string | null
    UMN?: StringNullableFilter<"Mandate"> | string | null
    amount?: FloatFilter<"Mandate"> | number
    status?: StringFilter<"Mandate"> | string
    payerVA?: StringFilter<"Mandate"> | string
    payerName?: StringNullableFilter<"Mandate"> | string | null
    payerMobile?: StringNullableFilter<"Mandate"> | string | null
    txnInitDate?: DateTimeNullableFilter<"Mandate"> | Date | string | null
    txnCompletionDate?: DateTimeNullableFilter<"Mandate"> | Date | string | null
    responseCode?: StringNullableFilter<"Mandate"> | string | null
    respCodeDescription?: StringNullableFilter<"Mandate"> | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }, "id" | "merchantTranId">

  export type MandateOrderByWithAggregationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    merchantTranId?: SortOrder
    bankRRN?: SortOrderInput | SortOrder
    UMN?: SortOrderInput | SortOrder
    amount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrderInput | SortOrder
    payerMobile?: SortOrderInput | SortOrder
    txnInitDate?: SortOrderInput | SortOrder
    txnCompletionDate?: SortOrderInput | SortOrder
    responseCode?: SortOrderInput | SortOrder
    respCodeDescription?: SortOrderInput | SortOrder
    _count?: MandateCountOrderByAggregateInput
    _avg?: MandateAvgOrderByAggregateInput
    _max?: MandateMaxOrderByAggregateInput
    _min?: MandateMinOrderByAggregateInput
    _sum?: MandateSumOrderByAggregateInput
  }

  export type MandateScalarWhereWithAggregatesInput = {
    AND?: MandateScalarWhereWithAggregatesInput | MandateScalarWhereWithAggregatesInput[]
    OR?: MandateScalarWhereWithAggregatesInput[]
    NOT?: MandateScalarWhereWithAggregatesInput | MandateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mandate"> | number
    organisationId?: IntWithAggregatesFilter<"Mandate"> | number
    merchantTranId?: StringWithAggregatesFilter<"Mandate"> | string
    bankRRN?: StringNullableWithAggregatesFilter<"Mandate"> | string | null
    UMN?: StringNullableWithAggregatesFilter<"Mandate"> | string | null
    amount?: FloatWithAggregatesFilter<"Mandate"> | number
    status?: StringWithAggregatesFilter<"Mandate"> | string
    payerVA?: StringWithAggregatesFilter<"Mandate"> | string
    payerName?: StringNullableWithAggregatesFilter<"Mandate"> | string | null
    payerMobile?: StringNullableWithAggregatesFilter<"Mandate"> | string | null
    txnInitDate?: DateTimeNullableWithAggregatesFilter<"Mandate"> | Date | string | null
    txnCompletionDate?: DateTimeNullableWithAggregatesFilter<"Mandate"> | Date | string | null
    responseCode?: StringNullableWithAggregatesFilter<"Mandate"> | string | null
    respCodeDescription?: StringNullableWithAggregatesFilter<"Mandate"> | string | null
  }

  export type ActiveMandateWhereInput = {
    AND?: ActiveMandateWhereInput | ActiveMandateWhereInput[]
    OR?: ActiveMandateWhereInput[]
    NOT?: ActiveMandateWhereInput | ActiveMandateWhereInput[]
    id?: IntFilter<"ActiveMandate"> | number
    organisationId?: IntFilter<"ActiveMandate"> | number
    UMN?: StringNullableFilter<"ActiveMandate"> | string | null
    mandateSeqNo?: IntFilter<"ActiveMandate"> | number
    amount?: FloatFilter<"ActiveMandate"> | number
    notificationRetries?: IntFilter<"ActiveMandate"> | number
    retryCount?: IntFilter<"ActiveMandate"> | number
    status?: StringFilter<"ActiveMandate"> | string
    payerVA?: StringFilter<"ActiveMandate"> | string
    payerName?: StringNullableFilter<"ActiveMandate"> | string | null
    payerMobile?: StringNullableFilter<"ActiveMandate"> | string | null
    notified?: BoolFilter<"ActiveMandate"> | boolean
    lastAttemptAt?: DateTimeNullableFilter<"ActiveMandate"> | Date | string | null
    lastNotificationAttempt?: DateTimeNullableFilter<"ActiveMandate"> | Date | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }

  export type ActiveMandateOrderByWithRelationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    UMN?: SortOrderInput | SortOrder
    mandateSeqNo?: SortOrder
    amount?: SortOrder
    notificationRetries?: SortOrder
    retryCount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrderInput | SortOrder
    payerMobile?: SortOrderInput | SortOrder
    notified?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    lastNotificationAttempt?: SortOrderInput | SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    _relevance?: ActiveMandateOrderByRelevanceInput
  }

  export type ActiveMandateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    organisationId?: number
    AND?: ActiveMandateWhereInput | ActiveMandateWhereInput[]
    OR?: ActiveMandateWhereInput[]
    NOT?: ActiveMandateWhereInput | ActiveMandateWhereInput[]
    UMN?: StringNullableFilter<"ActiveMandate"> | string | null
    mandateSeqNo?: IntFilter<"ActiveMandate"> | number
    amount?: FloatFilter<"ActiveMandate"> | number
    notificationRetries?: IntFilter<"ActiveMandate"> | number
    retryCount?: IntFilter<"ActiveMandate"> | number
    status?: StringFilter<"ActiveMandate"> | string
    payerVA?: StringFilter<"ActiveMandate"> | string
    payerName?: StringNullableFilter<"ActiveMandate"> | string | null
    payerMobile?: StringNullableFilter<"ActiveMandate"> | string | null
    notified?: BoolFilter<"ActiveMandate"> | boolean
    lastAttemptAt?: DateTimeNullableFilter<"ActiveMandate"> | Date | string | null
    lastNotificationAttempt?: DateTimeNullableFilter<"ActiveMandate"> | Date | string | null
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }, "id" | "organisationId">

  export type ActiveMandateOrderByWithAggregationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    UMN?: SortOrderInput | SortOrder
    mandateSeqNo?: SortOrder
    amount?: SortOrder
    notificationRetries?: SortOrder
    retryCount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrderInput | SortOrder
    payerMobile?: SortOrderInput | SortOrder
    notified?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    lastNotificationAttempt?: SortOrderInput | SortOrder
    _count?: ActiveMandateCountOrderByAggregateInput
    _avg?: ActiveMandateAvgOrderByAggregateInput
    _max?: ActiveMandateMaxOrderByAggregateInput
    _min?: ActiveMandateMinOrderByAggregateInput
    _sum?: ActiveMandateSumOrderByAggregateInput
  }

  export type ActiveMandateScalarWhereWithAggregatesInput = {
    AND?: ActiveMandateScalarWhereWithAggregatesInput | ActiveMandateScalarWhereWithAggregatesInput[]
    OR?: ActiveMandateScalarWhereWithAggregatesInput[]
    NOT?: ActiveMandateScalarWhereWithAggregatesInput | ActiveMandateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActiveMandate"> | number
    organisationId?: IntWithAggregatesFilter<"ActiveMandate"> | number
    UMN?: StringNullableWithAggregatesFilter<"ActiveMandate"> | string | null
    mandateSeqNo?: IntWithAggregatesFilter<"ActiveMandate"> | number
    amount?: FloatWithAggregatesFilter<"ActiveMandate"> | number
    notificationRetries?: IntWithAggregatesFilter<"ActiveMandate"> | number
    retryCount?: IntWithAggregatesFilter<"ActiveMandate"> | number
    status?: StringWithAggregatesFilter<"ActiveMandate"> | string
    payerVA?: StringWithAggregatesFilter<"ActiveMandate"> | string
    payerName?: StringNullableWithAggregatesFilter<"ActiveMandate"> | string | null
    payerMobile?: StringNullableWithAggregatesFilter<"ActiveMandate"> | string | null
    notified?: BoolWithAggregatesFilter<"ActiveMandate"> | boolean
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"ActiveMandate"> | Date | string | null
    lastNotificationAttempt?: DateTimeNullableWithAggregatesFilter<"ActiveMandate"> | Date | string | null
  }

  export type MandateNotificationWhereInput = {
    AND?: MandateNotificationWhereInput | MandateNotificationWhereInput[]
    OR?: MandateNotificationWhereInput[]
    NOT?: MandateNotificationWhereInput | MandateNotificationWhereInput[]
    id?: IntFilter<"MandateNotification"> | number
    organisationId?: IntFilter<"MandateNotification"> | number
    type?: StringFilter<"MandateNotification"> | string
    message?: StringFilter<"MandateNotification"> | string
    isRead?: BoolFilter<"MandateNotification"> | boolean
    createdAt?: DateTimeFilter<"MandateNotification"> | Date | string
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }

  export type MandateNotificationOrderByWithRelationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    _relevance?: MandateNotificationOrderByRelevanceInput
  }

  export type MandateNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MandateNotificationWhereInput | MandateNotificationWhereInput[]
    OR?: MandateNotificationWhereInput[]
    NOT?: MandateNotificationWhereInput | MandateNotificationWhereInput[]
    organisationId?: IntFilter<"MandateNotification"> | number
    type?: StringFilter<"MandateNotification"> | string
    message?: StringFilter<"MandateNotification"> | string
    isRead?: BoolFilter<"MandateNotification"> | boolean
    createdAt?: DateTimeFilter<"MandateNotification"> | Date | string
    organisation?: XOR<OrganisationScalarRelationFilter, OrganisationWhereInput>
  }, "id">

  export type MandateNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: MandateNotificationCountOrderByAggregateInput
    _avg?: MandateNotificationAvgOrderByAggregateInput
    _max?: MandateNotificationMaxOrderByAggregateInput
    _min?: MandateNotificationMinOrderByAggregateInput
    _sum?: MandateNotificationSumOrderByAggregateInput
  }

  export type MandateNotificationScalarWhereWithAggregatesInput = {
    AND?: MandateNotificationScalarWhereWithAggregatesInput | MandateNotificationScalarWhereWithAggregatesInput[]
    OR?: MandateNotificationScalarWhereWithAggregatesInput[]
    NOT?: MandateNotificationScalarWhereWithAggregatesInput | MandateNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MandateNotification"> | number
    organisationId?: IntWithAggregatesFilter<"MandateNotification"> | number
    type?: StringWithAggregatesFilter<"MandateNotification"> | string
    message?: StringWithAggregatesFilter<"MandateNotification"> | string
    isRead?: BoolWithAggregatesFilter<"MandateNotification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MandateNotification"> | Date | string
  }

  export type OrganisationCreateInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateManyInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
  }

  export type OrganisationUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
  }

  export type OrganisationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerSubmissionCreateInput = {
    token: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organisation: OrganisationCreateNestedOneWithoutCustomerSubmissionInput
    customers?: CustomerCreateNestedOneWithoutCustomerSubmissionInput
  }

  export type CustomerSubmissionUncheckedCreateInput = {
    id?: number
    token: string
    organisationId: number
    customerId?: number | null
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubmissionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisation?: OrganisationUpdateOneRequiredWithoutCustomerSubmissionNestedInput
    customers?: CustomerUpdateOneWithoutCustomerSubmissionNestedInput
  }

  export type CustomerSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubmissionCreateManyInput = {
    id?: number
    token: string
    organisationId: number
    customerId?: number | null
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubmissionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    name: string
    organisation: OrganisationCreateNestedOneWithoutProductCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoryInput
    inventory?: InventoryCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    name: string
    organisationId: number
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutProductCategoriesNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
    inventory?: InventoryUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    name: string
    organisationId: number
  }

  export type ProductCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisation: OrganisationCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    transactionItems?: TransactionItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisationId: number
    categoryId?: number | null
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    transactionItems?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    transactionItems?: TransactionItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    transactionItems?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisationId: number
    categoryId?: number | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellerCreateInput = {
    name: string
    contact: string
    type: string
    organisation: OrganisationCreateNestedOneWithoutSellersInput
  }

  export type SellerUncheckedCreateInput = {
    id?: number
    name: string
    contact: string
    type: string
    organisationId: number
  }

  export type SellerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutSellersNestedInput
  }

  export type SellerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
  }

  export type SellerCreateManyInput = {
    id?: number
    name: string
    contact: string
    type: string
    organisationId: number
  }

  export type SellerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SellerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionRecordCreateInput = {
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    organisation: OrganisationCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    TransactionShipping?: TransactionShippingCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordUncheckedCreateInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    organisationId: number
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    customerId?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    TransactionShipping?: TransactionShippingUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordUpdateInput = {
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    organisation?: OrganisationUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    TransactionShipping?: TransactionShippingUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    TransactionShipping?: TransactionShippingUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordCreateManyInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    organisationId: number
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    customerId?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
  }

  export type TransactionRecordUpdateManyMutationInput = {
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionItemCreateInput = {
    quantity: number
    totalPrice: number
    transaction: TransactionRecordCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutTransactionItemsInput
  }

  export type TransactionItemUncheckedCreateInput = {
    id?: number
    transactionId: number
    productId: number
    quantity: number
    totalPrice: number
  }

  export type TransactionItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    transaction?: TransactionRecordUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransactionItemsNestedInput
  }

  export type TransactionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionItemCreateManyInput = {
    id?: number
    transactionId: number
    productId: number
    quantity: number
    totalPrice: number
  }

  export type TransactionItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type CustomerCreateInput = {
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    organisation: OrganisationCreateNestedOneWithoutCustomersInput
    transactions?: TransactionRecordCreateNestedManyWithoutCustomerInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    organisationId: number
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutCustomerInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: OrganisationUpdateOneRequiredWithoutCustomersNestedInput
    transactions?: TransactionRecordUpdateManyWithoutCustomerNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    transactions?: TransactionRecordUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    organisationId: number
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryCreateInput = {
    quantity: number
    product: ProductCreateNestedOneWithoutInventoryInput
    category?: ProductCategoryCreateNestedOneWithoutInventoryInput
    organisation: OrganisationCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    productId: number
    categoryId?: number | null
    organisationId: number
    quantity: number
  }

  export type InventoryUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    category?: ProductCategoryUpdateOneWithoutInventoryNestedInput
    organisation?: OrganisationUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryCreateManyInput = {
    id?: number
    productId: number
    categoryId?: number | null
    organisationId: number
    quantity: number
  }

  export type InventoryUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SubscriptionDetailsCreateInput = {
    organisationId: number
    date: Date | string
    month: number
    year: number
    smsCount: number
    shopName: string
    mobileNumber: string
  }

  export type SubscriptionDetailsUncheckedCreateInput = {
    id?: number
    organisationId: number
    date: Date | string
    month: number
    year: number
    smsCount: number
    shopName: string
    mobileNumber: string
  }

  export type SubscriptionDetailsUpdateInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    smsCount?: IntFieldUpdateOperationsInput | number
    shopName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    smsCount?: IntFieldUpdateOperationsInput | number
    shopName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionDetailsCreateManyInput = {
    id?: number
    organisationId: number
    date: Date | string
    month: number
    year: number
    smsCount: number
    shopName: string
    mobileNumber: string
  }

  export type SubscriptionDetailsUpdateManyMutationInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    smsCount?: IntFieldUpdateOperationsInput | number
    shopName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    smsCount?: IntFieldUpdateOperationsInput | number
    shopName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ShippingMethodCreateInput = {
    name: string
    type: $Enums.ShippingMethodType
    minAmount?: number | null
    useWeight?: boolean
    ratePerKg?: number | null
    fixedRate?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organisation: OrganisationCreateNestedOneWithoutShippingMethodInput
  }

  export type ShippingMethodUncheckedCreateInput = {
    id?: number
    name: string
    type: $Enums.ShippingMethodType
    minAmount?: number | null
    useWeight?: boolean
    ratePerKg?: number | null
    fixedRate?: number | null
    isActive?: boolean
    organisationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingMethodUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    useWeight?: BoolFieldUpdateOperationsInput | boolean
    ratePerKg?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisation?: OrganisationUpdateOneRequiredWithoutShippingMethodNestedInput
  }

  export type ShippingMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    useWeight?: BoolFieldUpdateOperationsInput | boolean
    ratePerKg?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organisationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodCreateManyInput = {
    id?: number
    name: string
    type: $Enums.ShippingMethodType
    minAmount?: number | null
    useWeight?: boolean
    ratePerKg?: number | null
    fixedRate?: number | null
    isActive?: boolean
    organisationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingMethodUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    useWeight?: BoolFieldUpdateOperationsInput | boolean
    ratePerKg?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    useWeight?: BoolFieldUpdateOperationsInput | boolean
    ratePerKg?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    organisationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionShippingCreateInput = {
    methodName: string
    methodType: $Enums.ShippingMethodType
    baseRate?: number | null
    weightCharge?: number | null
    totalWeight?: number | null
    totalCost: number
    transaction: TransactionRecordCreateNestedOneWithoutTransactionShippingInput
  }

  export type TransactionShippingUncheckedCreateInput = {
    id?: number
    transactionId: number
    methodName: string
    methodType: $Enums.ShippingMethodType
    baseRate?: number | null
    weightCharge?: number | null
    totalWeight?: number | null
    totalCost: number
  }

  export type TransactionShippingUpdateInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    methodType?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    weightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: FloatFieldUpdateOperationsInput | number
    transaction?: TransactionRecordUpdateOneRequiredWithoutTransactionShippingNestedInput
  }

  export type TransactionShippingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    methodType?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    weightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionShippingCreateManyInput = {
    id?: number
    transactionId: number
    methodName: string
    methodType: $Enums.ShippingMethodType
    baseRate?: number | null
    weightCharge?: number | null
    totalWeight?: number | null
    totalCost: number
  }

  export type TransactionShippingUpdateManyMutationInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    methodType?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    weightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionShippingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    methodType?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    weightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: FloatFieldUpdateOperationsInput | number
  }

  export type MandateCreateInput = {
    merchantTranId: string
    bankRRN?: string | null
    UMN?: string | null
    amount: number
    status: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    txnInitDate?: Date | string | null
    txnCompletionDate?: Date | string | null
    responseCode?: string | null
    respCodeDescription?: string | null
    organisation: OrganisationCreateNestedOneWithoutMandateInput
  }

  export type MandateUncheckedCreateInput = {
    id?: number
    organisationId: number
    merchantTranId: string
    bankRRN?: string | null
    UMN?: string | null
    amount: number
    status: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    txnInitDate?: Date | string | null
    txnCompletionDate?: Date | string | null
    responseCode?: string | null
    respCodeDescription?: string | null
  }

  export type MandateUpdateInput = {
    merchantTranId?: StringFieldUpdateOperationsInput | string
    bankRRN?: NullableStringFieldUpdateOperationsInput | string | null
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    txnInitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txnCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    respCodeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: OrganisationUpdateOneRequiredWithoutMandateNestedInput
  }

  export type MandateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    merchantTranId?: StringFieldUpdateOperationsInput | string
    bankRRN?: NullableStringFieldUpdateOperationsInput | string | null
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    txnInitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txnCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    respCodeDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MandateCreateManyInput = {
    id?: number
    organisationId: number
    merchantTranId: string
    bankRRN?: string | null
    UMN?: string | null
    amount: number
    status: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    txnInitDate?: Date | string | null
    txnCompletionDate?: Date | string | null
    responseCode?: string | null
    respCodeDescription?: string | null
  }

  export type MandateUpdateManyMutationInput = {
    merchantTranId?: StringFieldUpdateOperationsInput | string
    bankRRN?: NullableStringFieldUpdateOperationsInput | string | null
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    txnInitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txnCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    respCodeDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MandateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    merchantTranId?: StringFieldUpdateOperationsInput | string
    bankRRN?: NullableStringFieldUpdateOperationsInput | string | null
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    txnInitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txnCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    respCodeDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActiveMandateCreateInput = {
    UMN?: string | null
    mandateSeqNo?: number
    amount: number
    notificationRetries?: number
    retryCount?: number
    status?: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    notified?: boolean
    lastAttemptAt?: Date | string | null
    lastNotificationAttempt?: Date | string | null
    organisation: OrganisationCreateNestedOneWithoutActiveMandatesInput
  }

  export type ActiveMandateUncheckedCreateInput = {
    id?: number
    organisationId: number
    UMN?: string | null
    mandateSeqNo?: number
    amount: number
    notificationRetries?: number
    retryCount?: number
    status?: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    notified?: boolean
    lastAttemptAt?: Date | string | null
    lastNotificationAttempt?: Date | string | null
  }

  export type ActiveMandateUpdateInput = {
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    mandateSeqNo?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notificationRetries?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    notified?: BoolFieldUpdateOperationsInput | boolean
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNotificationAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organisation?: OrganisationUpdateOneRequiredWithoutActiveMandatesNestedInput
  }

  export type ActiveMandateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    mandateSeqNo?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notificationRetries?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    notified?: BoolFieldUpdateOperationsInput | boolean
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNotificationAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActiveMandateCreateManyInput = {
    id?: number
    organisationId: number
    UMN?: string | null
    mandateSeqNo?: number
    amount: number
    notificationRetries?: number
    retryCount?: number
    status?: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    notified?: boolean
    lastAttemptAt?: Date | string | null
    lastNotificationAttempt?: Date | string | null
  }

  export type ActiveMandateUpdateManyMutationInput = {
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    mandateSeqNo?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notificationRetries?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    notified?: BoolFieldUpdateOperationsInput | boolean
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNotificationAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActiveMandateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    mandateSeqNo?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notificationRetries?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    notified?: BoolFieldUpdateOperationsInput | boolean
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNotificationAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MandateNotificationCreateInput = {
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    organisation: OrganisationCreateNestedOneWithoutMandateNotificationInput
  }

  export type MandateNotificationUncheckedCreateInput = {
    id?: number
    organisationId: number
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MandateNotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisation?: OrganisationUpdateOneRequiredWithoutMandateNotificationNestedInput
  }

  export type MandateNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandateNotificationCreateManyInput = {
    id?: number
    organisationId: number
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MandateNotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandateNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SellerListRelationFilter = {
    every?: SellerWhereInput
    some?: SellerWhereInput
    none?: SellerWhereInput
  }

  export type TransactionRecordListRelationFilter = {
    every?: TransactionRecordWhereInput
    some?: TransactionRecordWhereInput
    none?: TransactionRecordWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type CustomerSubmissionListRelationFilter = {
    every?: CustomerSubmissionWhereInput
    some?: CustomerSubmissionWhereInput
    none?: CustomerSubmissionWhereInput
  }

  export type ShippingMethodListRelationFilter = {
    every?: ShippingMethodWhereInput
    some?: ShippingMethodWhereInput
    none?: ShippingMethodWhereInput
  }

  export type MandateListRelationFilter = {
    every?: MandateWhereInput
    some?: MandateWhereInput
    none?: MandateWhereInput
  }

  export type ActiveMandateNullableScalarRelationFilter = {
    is?: ActiveMandateWhereInput | null
    isNot?: ActiveMandateWhereInput | null
  }

  export type MandateNotificationListRelationFilter = {
    every?: MandateNotificationWhereInput
    some?: MandateNotificationWhereInput
    none?: MandateNotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShippingMethodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MandateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MandateNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganisationOrderByRelevanceInput = {
    fields: OrganisationOrderByRelevanceFieldEnum | OrganisationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrganisationCountOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    companySize?: SortOrder
    shopName?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    smsCount?: SortOrder
    smsCost?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobileNumber?: SortOrder
    landlineNumber?: SortOrder
    websiteAddress?: SortOrder
    gstNumber?: SortOrder
    subscriptionType?: SortOrder
    endDate?: SortOrder
    whatsappNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    razorpayAccessToken?: SortOrder
    razorpayRefreshToken?: SortOrder
    razorpayTokenExpiresAt?: SortOrder
    razorpayAccountId?: SortOrder
    razorpayState?: SortOrder
    razorpayStateExpiresAt?: SortOrder
    monthlyUsage?: SortOrder
  }

  export type OrganisationAvgOrderByAggregateInput = {
    id?: SortOrder
    smsCount?: SortOrder
    smsCost?: SortOrder
    monthlyUsage?: SortOrder
  }

  export type OrganisationMaxOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    companySize?: SortOrder
    shopName?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    smsCount?: SortOrder
    smsCost?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobileNumber?: SortOrder
    landlineNumber?: SortOrder
    websiteAddress?: SortOrder
    gstNumber?: SortOrder
    subscriptionType?: SortOrder
    endDate?: SortOrder
    whatsappNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    razorpayAccessToken?: SortOrder
    razorpayRefreshToken?: SortOrder
    razorpayTokenExpiresAt?: SortOrder
    razorpayAccountId?: SortOrder
    razorpayState?: SortOrder
    razorpayStateExpiresAt?: SortOrder
    monthlyUsage?: SortOrder
  }

  export type OrganisationMinOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    companySize?: SortOrder
    shopName?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    district?: SortOrder
    city?: SortOrder
    state?: SortOrder
    smsCount?: SortOrder
    smsCost?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    mobileNumber?: SortOrder
    landlineNumber?: SortOrder
    websiteAddress?: SortOrder
    gstNumber?: SortOrder
    subscriptionType?: SortOrder
    endDate?: SortOrder
    whatsappNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    razorpayAccessToken?: SortOrder
    razorpayRefreshToken?: SortOrder
    razorpayTokenExpiresAt?: SortOrder
    razorpayAccountId?: SortOrder
    razorpayState?: SortOrder
    razorpayStateExpiresAt?: SortOrder
    monthlyUsage?: SortOrder
  }

  export type OrganisationSumOrderByAggregateInput = {
    id?: SortOrder
    smsCount?: SortOrder
    smsCost?: SortOrder
    monthlyUsage?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OrganisationScalarRelationFilter = {
    is?: OrganisationWhereInput
    isNot?: OrganisationWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type CustomerSubmissionOrderByRelevanceInput = {
    fields: CustomerSubmissionOrderByRelevanceFieldEnum | CustomerSubmissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    organisationId?: SortOrder
    customerId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    customerId?: SortOrder
  }

  export type CustomerSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    organisationId?: SortOrder
    customerId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    organisationId?: SortOrder
    customerId?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    customerId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductCategoryOrderByRelevanceInput = {
    fields: ProductCategoryOrderByRelevanceFieldEnum | ProductCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organisationId?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organisationId?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    organisationId?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type ProductCategoryNullableScalarRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type TransactionItemListRelationFilter = {
    every?: TransactionItemWhereInput
    some?: TransactionItemWhereInput
    none?: TransactionItemWhereInput
  }

  export type TransactionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    netPrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    seller?: SortOrder
    organisationId?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    netPrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    organisationId?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    netPrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    seller?: SortOrder
    organisationId?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    SKU?: SortOrder
    netPrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    seller?: SortOrder
    organisationId?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    netPrice?: SortOrder
    sellingPrice?: SortOrder
    quantity?: SortOrder
    organisationId?: SortOrder
    categoryId?: SortOrder
  }

  export type SellerOrderByRelevanceInput = {
    fields: SellerOrderByRelevanceFieldEnum | SellerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SellerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    type?: SortOrder
    organisationId?: SortOrder
  }

  export type SellerAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type SellerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    type?: SortOrder
    organisationId?: SortOrder
  }

  export type SellerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    type?: SortOrder
    organisationId?: SortOrder
  }

  export type SellerSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TransactionShippingListRelationFilter = {
    every?: TransactionShippingWhereInput
    some?: TransactionShippingWhereInput
    none?: TransactionShippingWhereInput
  }

  export type TransactionShippingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionRecordOrderByRelevanceInput = {
    fields: TransactionRecordOrderByRelevanceFieldEnum | TransactionRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    billNo?: SortOrder
    totalPrice?: SortOrder
    paymentMethod?: SortOrder
    amountPaid?: SortOrder
    balance?: SortOrder
    billingMode?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    trackingNumber?: SortOrder
    weight?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    isEdited?: SortOrder
  }

  export type TransactionRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    billNo?: SortOrder
    totalPrice?: SortOrder
    amountPaid?: SortOrder
    balance?: SortOrder
    organisationId?: SortOrder
    weight?: SortOrder
    customerId?: SortOrder
  }

  export type TransactionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    billNo?: SortOrder
    totalPrice?: SortOrder
    paymentMethod?: SortOrder
    amountPaid?: SortOrder
    balance?: SortOrder
    billingMode?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    trackingNumber?: SortOrder
    weight?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    isEdited?: SortOrder
  }

  export type TransactionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    billNo?: SortOrder
    totalPrice?: SortOrder
    paymentMethod?: SortOrder
    amountPaid?: SortOrder
    balance?: SortOrder
    billingMode?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    trackingNumber?: SortOrder
    weight?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    isEdited?: SortOrder
  }

  export type TransactionRecordSumOrderByAggregateInput = {
    id?: SortOrder
    billNo?: SortOrder
    totalPrice?: SortOrder
    amountPaid?: SortOrder
    balance?: SortOrder
    organisationId?: SortOrder
    weight?: SortOrder
    customerId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TransactionRecordScalarRelationFilter = {
    is?: TransactionRecordWhereInput
    isNot?: TransactionRecordWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type TransactionItemCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type TransactionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type TransactionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type TransactionItemMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type TransactionItemSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    district?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    email?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    organisationId?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    district?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    email?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    organisationId?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    district?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    email?: SortOrder
    flatNo?: SortOrder
    street?: SortOrder
    organisationId?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type InventoryProductIdOrganisationIdCompoundUniqueInput = {
    productId: number
    organisationId: number
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    organisationId?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    organisationId?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    organisationId?: SortOrder
    quantity?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    organisationId?: SortOrder
    quantity?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    organisationId?: SortOrder
    quantity?: SortOrder
  }

  export type SubscriptionDetailsOrderByRelevanceInput = {
    fields: SubscriptionDetailsOrderByRelevanceFieldEnum | SubscriptionDetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    month?: SortOrder
    year?: SortOrder
    smsCount?: SortOrder
    shopName?: SortOrder
    mobileNumber?: SortOrder
  }

  export type SubscriptionDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    smsCount?: SortOrder
  }

  export type SubscriptionDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    month?: SortOrder
    year?: SortOrder
    smsCount?: SortOrder
    shopName?: SortOrder
    mobileNumber?: SortOrder
  }

  export type SubscriptionDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    date?: SortOrder
    month?: SortOrder
    year?: SortOrder
    smsCount?: SortOrder
    shopName?: SortOrder
    mobileNumber?: SortOrder
  }

  export type SubscriptionDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    smsCount?: SortOrder
  }

  export type EnumShippingMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingMethodType | EnumShippingMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingMethodType[]
    notIn?: $Enums.ShippingMethodType[]
    not?: NestedEnumShippingMethodTypeFilter<$PrismaModel> | $Enums.ShippingMethodType
  }

  export type ShippingMethodOrderByRelevanceInput = {
    fields: ShippingMethodOrderByRelevanceFieldEnum | ShippingMethodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShippingMethodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    minAmount?: SortOrder
    useWeight?: SortOrder
    ratePerKg?: SortOrder
    fixedRate?: SortOrder
    isActive?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMethodAvgOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
    ratePerKg?: SortOrder
    fixedRate?: SortOrder
    organisationId?: SortOrder
  }

  export type ShippingMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    minAmount?: SortOrder
    useWeight?: SortOrder
    ratePerKg?: SortOrder
    fixedRate?: SortOrder
    isActive?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMethodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    minAmount?: SortOrder
    useWeight?: SortOrder
    ratePerKg?: SortOrder
    fixedRate?: SortOrder
    isActive?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShippingMethodSumOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
    ratePerKg?: SortOrder
    fixedRate?: SortOrder
    organisationId?: SortOrder
  }

  export type EnumShippingMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingMethodType | EnumShippingMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingMethodType[]
    notIn?: $Enums.ShippingMethodType[]
    not?: NestedEnumShippingMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShippingMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumShippingMethodTypeFilter<$PrismaModel>
  }

  export type TransactionShippingOrderByRelevanceInput = {
    fields: TransactionShippingOrderByRelevanceFieldEnum | TransactionShippingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionShippingCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    methodName?: SortOrder
    methodType?: SortOrder
    baseRate?: SortOrder
    weightCharge?: SortOrder
    totalWeight?: SortOrder
    totalCost?: SortOrder
  }

  export type TransactionShippingAvgOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    baseRate?: SortOrder
    weightCharge?: SortOrder
    totalWeight?: SortOrder
    totalCost?: SortOrder
  }

  export type TransactionShippingMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    methodName?: SortOrder
    methodType?: SortOrder
    baseRate?: SortOrder
    weightCharge?: SortOrder
    totalWeight?: SortOrder
    totalCost?: SortOrder
  }

  export type TransactionShippingMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    methodName?: SortOrder
    methodType?: SortOrder
    baseRate?: SortOrder
    weightCharge?: SortOrder
    totalWeight?: SortOrder
    totalCost?: SortOrder
  }

  export type TransactionShippingSumOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    baseRate?: SortOrder
    weightCharge?: SortOrder
    totalWeight?: SortOrder
    totalCost?: SortOrder
  }

  export type MandateOrderByRelevanceInput = {
    fields: MandateOrderByRelevanceFieldEnum | MandateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MandateCountOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    merchantTranId?: SortOrder
    bankRRN?: SortOrder
    UMN?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrder
    payerMobile?: SortOrder
    txnInitDate?: SortOrder
    txnCompletionDate?: SortOrder
    responseCode?: SortOrder
    respCodeDescription?: SortOrder
  }

  export type MandateAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    amount?: SortOrder
  }

  export type MandateMaxOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    merchantTranId?: SortOrder
    bankRRN?: SortOrder
    UMN?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrder
    payerMobile?: SortOrder
    txnInitDate?: SortOrder
    txnCompletionDate?: SortOrder
    responseCode?: SortOrder
    respCodeDescription?: SortOrder
  }

  export type MandateMinOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    merchantTranId?: SortOrder
    bankRRN?: SortOrder
    UMN?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrder
    payerMobile?: SortOrder
    txnInitDate?: SortOrder
    txnCompletionDate?: SortOrder
    responseCode?: SortOrder
    respCodeDescription?: SortOrder
  }

  export type MandateSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    amount?: SortOrder
  }

  export type ActiveMandateOrderByRelevanceInput = {
    fields: ActiveMandateOrderByRelevanceFieldEnum | ActiveMandateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActiveMandateCountOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    UMN?: SortOrder
    mandateSeqNo?: SortOrder
    amount?: SortOrder
    notificationRetries?: SortOrder
    retryCount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrder
    payerMobile?: SortOrder
    notified?: SortOrder
    lastAttemptAt?: SortOrder
    lastNotificationAttempt?: SortOrder
  }

  export type ActiveMandateAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    mandateSeqNo?: SortOrder
    amount?: SortOrder
    notificationRetries?: SortOrder
    retryCount?: SortOrder
  }

  export type ActiveMandateMaxOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    UMN?: SortOrder
    mandateSeqNo?: SortOrder
    amount?: SortOrder
    notificationRetries?: SortOrder
    retryCount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrder
    payerMobile?: SortOrder
    notified?: SortOrder
    lastAttemptAt?: SortOrder
    lastNotificationAttempt?: SortOrder
  }

  export type ActiveMandateMinOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    UMN?: SortOrder
    mandateSeqNo?: SortOrder
    amount?: SortOrder
    notificationRetries?: SortOrder
    retryCount?: SortOrder
    status?: SortOrder
    payerVA?: SortOrder
    payerName?: SortOrder
    payerMobile?: SortOrder
    notified?: SortOrder
    lastAttemptAt?: SortOrder
    lastNotificationAttempt?: SortOrder
  }

  export type ActiveMandateSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    mandateSeqNo?: SortOrder
    amount?: SortOrder
    notificationRetries?: SortOrder
    retryCount?: SortOrder
  }

  export type MandateNotificationOrderByRelevanceInput = {
    fields: MandateNotificationOrderByRelevanceFieldEnum | MandateNotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MandateNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MandateNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type MandateNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MandateNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MandateNotificationSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type ProductCategoryCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ProductCategoryCreateWithoutOrganisationInput, ProductCategoryUncheckedCreateWithoutOrganisationInput> | ProductCategoryCreateWithoutOrganisationInput[] | ProductCategoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutOrganisationInput | ProductCategoryCreateOrConnectWithoutOrganisationInput[]
    createMany?: ProductCategoryCreateManyOrganisationInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ProductCreateWithoutOrganisationInput, ProductUncheckedCreateWithoutOrganisationInput> | ProductCreateWithoutOrganisationInput[] | ProductUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrganisationInput | ProductCreateOrConnectWithoutOrganisationInput[]
    createMany?: ProductCreateManyOrganisationInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SellerCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<SellerCreateWithoutOrganisationInput, SellerUncheckedCreateWithoutOrganisationInput> | SellerCreateWithoutOrganisationInput[] | SellerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: SellerCreateOrConnectWithoutOrganisationInput | SellerCreateOrConnectWithoutOrganisationInput[]
    createMany?: SellerCreateManyOrganisationInputEnvelope
    connect?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
  }

  export type TransactionRecordCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<TransactionRecordCreateWithoutOrganisationInput, TransactionRecordUncheckedCreateWithoutOrganisationInput> | TransactionRecordCreateWithoutOrganisationInput[] | TransactionRecordUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutOrganisationInput | TransactionRecordCreateOrConnectWithoutOrganisationInput[]
    createMany?: TransactionRecordCreateManyOrganisationInputEnvelope
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<CustomerCreateWithoutOrganisationInput, CustomerUncheckedCreateWithoutOrganisationInput> | CustomerCreateWithoutOrganisationInput[] | CustomerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganisationInput | CustomerCreateOrConnectWithoutOrganisationInput[]
    createMany?: CustomerCreateManyOrganisationInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<InventoryCreateWithoutOrganisationInput, InventoryUncheckedCreateWithoutOrganisationInput> | InventoryCreateWithoutOrganisationInput[] | InventoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutOrganisationInput | InventoryCreateOrConnectWithoutOrganisationInput[]
    createMany?: InventoryCreateManyOrganisationInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type CustomerSubmissionCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<CustomerSubmissionCreateWithoutOrganisationInput, CustomerSubmissionUncheckedCreateWithoutOrganisationInput> | CustomerSubmissionCreateWithoutOrganisationInput[] | CustomerSubmissionUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutOrganisationInput | CustomerSubmissionCreateOrConnectWithoutOrganisationInput[]
    createMany?: CustomerSubmissionCreateManyOrganisationInputEnvelope
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
  }

  export type ShippingMethodCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ShippingMethodCreateWithoutOrganisationInput, ShippingMethodUncheckedCreateWithoutOrganisationInput> | ShippingMethodCreateWithoutOrganisationInput[] | ShippingMethodUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutOrganisationInput | ShippingMethodCreateOrConnectWithoutOrganisationInput[]
    createMany?: ShippingMethodCreateManyOrganisationInputEnvelope
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
  }

  export type MandateCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<MandateCreateWithoutOrganisationInput, MandateUncheckedCreateWithoutOrganisationInput> | MandateCreateWithoutOrganisationInput[] | MandateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateCreateOrConnectWithoutOrganisationInput | MandateCreateOrConnectWithoutOrganisationInput[]
    createMany?: MandateCreateManyOrganisationInputEnvelope
    connect?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
  }

  export type ActiveMandateCreateNestedOneWithoutOrganisationInput = {
    create?: XOR<ActiveMandateCreateWithoutOrganisationInput, ActiveMandateUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: ActiveMandateCreateOrConnectWithoutOrganisationInput
    connect?: ActiveMandateWhereUniqueInput
  }

  export type MandateNotificationCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<MandateNotificationCreateWithoutOrganisationInput, MandateNotificationUncheckedCreateWithoutOrganisationInput> | MandateNotificationCreateWithoutOrganisationInput[] | MandateNotificationUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateNotificationCreateOrConnectWithoutOrganisationInput | MandateNotificationCreateOrConnectWithoutOrganisationInput[]
    createMany?: MandateNotificationCreateManyOrganisationInputEnvelope
    connect?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ProductCategoryCreateWithoutOrganisationInput, ProductCategoryUncheckedCreateWithoutOrganisationInput> | ProductCategoryCreateWithoutOrganisationInput[] | ProductCategoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutOrganisationInput | ProductCategoryCreateOrConnectWithoutOrganisationInput[]
    createMany?: ProductCategoryCreateManyOrganisationInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ProductCreateWithoutOrganisationInput, ProductUncheckedCreateWithoutOrganisationInput> | ProductCreateWithoutOrganisationInput[] | ProductUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrganisationInput | ProductCreateOrConnectWithoutOrganisationInput[]
    createMany?: ProductCreateManyOrganisationInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SellerUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<SellerCreateWithoutOrganisationInput, SellerUncheckedCreateWithoutOrganisationInput> | SellerCreateWithoutOrganisationInput[] | SellerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: SellerCreateOrConnectWithoutOrganisationInput | SellerCreateOrConnectWithoutOrganisationInput[]
    createMany?: SellerCreateManyOrganisationInputEnvelope
    connect?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
  }

  export type TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<TransactionRecordCreateWithoutOrganisationInput, TransactionRecordUncheckedCreateWithoutOrganisationInput> | TransactionRecordCreateWithoutOrganisationInput[] | TransactionRecordUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutOrganisationInput | TransactionRecordCreateOrConnectWithoutOrganisationInput[]
    createMany?: TransactionRecordCreateManyOrganisationInputEnvelope
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<CustomerCreateWithoutOrganisationInput, CustomerUncheckedCreateWithoutOrganisationInput> | CustomerCreateWithoutOrganisationInput[] | CustomerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganisationInput | CustomerCreateOrConnectWithoutOrganisationInput[]
    createMany?: CustomerCreateManyOrganisationInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<InventoryCreateWithoutOrganisationInput, InventoryUncheckedCreateWithoutOrganisationInput> | InventoryCreateWithoutOrganisationInput[] | InventoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutOrganisationInput | InventoryCreateOrConnectWithoutOrganisationInput[]
    createMany?: InventoryCreateManyOrganisationInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<CustomerSubmissionCreateWithoutOrganisationInput, CustomerSubmissionUncheckedCreateWithoutOrganisationInput> | CustomerSubmissionCreateWithoutOrganisationInput[] | CustomerSubmissionUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutOrganisationInput | CustomerSubmissionCreateOrConnectWithoutOrganisationInput[]
    createMany?: CustomerSubmissionCreateManyOrganisationInputEnvelope
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
  }

  export type ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<ShippingMethodCreateWithoutOrganisationInput, ShippingMethodUncheckedCreateWithoutOrganisationInput> | ShippingMethodCreateWithoutOrganisationInput[] | ShippingMethodUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutOrganisationInput | ShippingMethodCreateOrConnectWithoutOrganisationInput[]
    createMany?: ShippingMethodCreateManyOrganisationInputEnvelope
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
  }

  export type MandateUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<MandateCreateWithoutOrganisationInput, MandateUncheckedCreateWithoutOrganisationInput> | MandateCreateWithoutOrganisationInput[] | MandateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateCreateOrConnectWithoutOrganisationInput | MandateCreateOrConnectWithoutOrganisationInput[]
    createMany?: MandateCreateManyOrganisationInputEnvelope
    connect?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
  }

  export type ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput = {
    create?: XOR<ActiveMandateCreateWithoutOrganisationInput, ActiveMandateUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: ActiveMandateCreateOrConnectWithoutOrganisationInput
    connect?: ActiveMandateWhereUniqueInput
  }

  export type MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<MandateNotificationCreateWithoutOrganisationInput, MandateNotificationUncheckedCreateWithoutOrganisationInput> | MandateNotificationCreateWithoutOrganisationInput[] | MandateNotificationUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateNotificationCreateOrConnectWithoutOrganisationInput | MandateNotificationCreateOrConnectWithoutOrganisationInput[]
    createMany?: MandateNotificationCreateManyOrganisationInputEnvelope
    connect?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductCategoryUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutOrganisationInput, ProductCategoryUncheckedCreateWithoutOrganisationInput> | ProductCategoryCreateWithoutOrganisationInput[] | ProductCategoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutOrganisationInput | ProductCategoryCreateOrConnectWithoutOrganisationInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutOrganisationInput | ProductCategoryUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ProductCategoryCreateManyOrganisationInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutOrganisationInput | ProductCategoryUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutOrganisationInput | ProductCategoryUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ProductCreateWithoutOrganisationInput, ProductUncheckedCreateWithoutOrganisationInput> | ProductCreateWithoutOrganisationInput[] | ProductUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrganisationInput | ProductCreateOrConnectWithoutOrganisationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrganisationInput | ProductUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ProductCreateManyOrganisationInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrganisationInput | ProductUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrganisationInput | ProductUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SellerUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<SellerCreateWithoutOrganisationInput, SellerUncheckedCreateWithoutOrganisationInput> | SellerCreateWithoutOrganisationInput[] | SellerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: SellerCreateOrConnectWithoutOrganisationInput | SellerCreateOrConnectWithoutOrganisationInput[]
    upsert?: SellerUpsertWithWhereUniqueWithoutOrganisationInput | SellerUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: SellerCreateManyOrganisationInputEnvelope
    set?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    disconnect?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    delete?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    connect?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    update?: SellerUpdateWithWhereUniqueWithoutOrganisationInput | SellerUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: SellerUpdateManyWithWhereWithoutOrganisationInput | SellerUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: SellerScalarWhereInput | SellerScalarWhereInput[]
  }

  export type TransactionRecordUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<TransactionRecordCreateWithoutOrganisationInput, TransactionRecordUncheckedCreateWithoutOrganisationInput> | TransactionRecordCreateWithoutOrganisationInput[] | TransactionRecordUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutOrganisationInput | TransactionRecordCreateOrConnectWithoutOrganisationInput[]
    upsert?: TransactionRecordUpsertWithWhereUniqueWithoutOrganisationInput | TransactionRecordUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: TransactionRecordCreateManyOrganisationInputEnvelope
    set?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    disconnect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    delete?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    update?: TransactionRecordUpdateWithWhereUniqueWithoutOrganisationInput | TransactionRecordUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: TransactionRecordUpdateManyWithWhereWithoutOrganisationInput | TransactionRecordUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: TransactionRecordScalarWhereInput | TransactionRecordScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<CustomerCreateWithoutOrganisationInput, CustomerUncheckedCreateWithoutOrganisationInput> | CustomerCreateWithoutOrganisationInput[] | CustomerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganisationInput | CustomerCreateOrConnectWithoutOrganisationInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutOrganisationInput | CustomerUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: CustomerCreateManyOrganisationInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutOrganisationInput | CustomerUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutOrganisationInput | CustomerUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<InventoryCreateWithoutOrganisationInput, InventoryUncheckedCreateWithoutOrganisationInput> | InventoryCreateWithoutOrganisationInput[] | InventoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutOrganisationInput | InventoryCreateOrConnectWithoutOrganisationInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutOrganisationInput | InventoryUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: InventoryCreateManyOrganisationInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutOrganisationInput | InventoryUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutOrganisationInput | InventoryUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type CustomerSubmissionUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<CustomerSubmissionCreateWithoutOrganisationInput, CustomerSubmissionUncheckedCreateWithoutOrganisationInput> | CustomerSubmissionCreateWithoutOrganisationInput[] | CustomerSubmissionUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutOrganisationInput | CustomerSubmissionCreateOrConnectWithoutOrganisationInput[]
    upsert?: CustomerSubmissionUpsertWithWhereUniqueWithoutOrganisationInput | CustomerSubmissionUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: CustomerSubmissionCreateManyOrganisationInputEnvelope
    set?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    disconnect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    delete?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    update?: CustomerSubmissionUpdateWithWhereUniqueWithoutOrganisationInput | CustomerSubmissionUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: CustomerSubmissionUpdateManyWithWhereWithoutOrganisationInput | CustomerSubmissionUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: CustomerSubmissionScalarWhereInput | CustomerSubmissionScalarWhereInput[]
  }

  export type ShippingMethodUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ShippingMethodCreateWithoutOrganisationInput, ShippingMethodUncheckedCreateWithoutOrganisationInput> | ShippingMethodCreateWithoutOrganisationInput[] | ShippingMethodUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutOrganisationInput | ShippingMethodCreateOrConnectWithoutOrganisationInput[]
    upsert?: ShippingMethodUpsertWithWhereUniqueWithoutOrganisationInput | ShippingMethodUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ShippingMethodCreateManyOrganisationInputEnvelope
    set?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    disconnect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    delete?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    update?: ShippingMethodUpdateWithWhereUniqueWithoutOrganisationInput | ShippingMethodUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ShippingMethodUpdateManyWithWhereWithoutOrganisationInput | ShippingMethodUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
  }

  export type MandateUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<MandateCreateWithoutOrganisationInput, MandateUncheckedCreateWithoutOrganisationInput> | MandateCreateWithoutOrganisationInput[] | MandateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateCreateOrConnectWithoutOrganisationInput | MandateCreateOrConnectWithoutOrganisationInput[]
    upsert?: MandateUpsertWithWhereUniqueWithoutOrganisationInput | MandateUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: MandateCreateManyOrganisationInputEnvelope
    set?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    disconnect?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    delete?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    connect?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    update?: MandateUpdateWithWhereUniqueWithoutOrganisationInput | MandateUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: MandateUpdateManyWithWhereWithoutOrganisationInput | MandateUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: MandateScalarWhereInput | MandateScalarWhereInput[]
  }

  export type ActiveMandateUpdateOneWithoutOrganisationNestedInput = {
    create?: XOR<ActiveMandateCreateWithoutOrganisationInput, ActiveMandateUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: ActiveMandateCreateOrConnectWithoutOrganisationInput
    upsert?: ActiveMandateUpsertWithoutOrganisationInput
    disconnect?: ActiveMandateWhereInput | boolean
    delete?: ActiveMandateWhereInput | boolean
    connect?: ActiveMandateWhereUniqueInput
    update?: XOR<XOR<ActiveMandateUpdateToOneWithWhereWithoutOrganisationInput, ActiveMandateUpdateWithoutOrganisationInput>, ActiveMandateUncheckedUpdateWithoutOrganisationInput>
  }

  export type MandateNotificationUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<MandateNotificationCreateWithoutOrganisationInput, MandateNotificationUncheckedCreateWithoutOrganisationInput> | MandateNotificationCreateWithoutOrganisationInput[] | MandateNotificationUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateNotificationCreateOrConnectWithoutOrganisationInput | MandateNotificationCreateOrConnectWithoutOrganisationInput[]
    upsert?: MandateNotificationUpsertWithWhereUniqueWithoutOrganisationInput | MandateNotificationUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: MandateNotificationCreateManyOrganisationInputEnvelope
    set?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    disconnect?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    delete?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    connect?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    update?: MandateNotificationUpdateWithWhereUniqueWithoutOrganisationInput | MandateNotificationUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: MandateNotificationUpdateManyWithWhereWithoutOrganisationInput | MandateNotificationUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: MandateNotificationScalarWhereInput | MandateNotificationScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutOrganisationInput, ProductCategoryUncheckedCreateWithoutOrganisationInput> | ProductCategoryCreateWithoutOrganisationInput[] | ProductCategoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutOrganisationInput | ProductCategoryCreateOrConnectWithoutOrganisationInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutOrganisationInput | ProductCategoryUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ProductCategoryCreateManyOrganisationInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutOrganisationInput | ProductCategoryUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutOrganisationInput | ProductCategoryUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ProductCreateWithoutOrganisationInput, ProductUncheckedCreateWithoutOrganisationInput> | ProductCreateWithoutOrganisationInput[] | ProductUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOrganisationInput | ProductCreateOrConnectWithoutOrganisationInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOrganisationInput | ProductUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ProductCreateManyOrganisationInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOrganisationInput | ProductUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOrganisationInput | ProductUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SellerUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<SellerCreateWithoutOrganisationInput, SellerUncheckedCreateWithoutOrganisationInput> | SellerCreateWithoutOrganisationInput[] | SellerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: SellerCreateOrConnectWithoutOrganisationInput | SellerCreateOrConnectWithoutOrganisationInput[]
    upsert?: SellerUpsertWithWhereUniqueWithoutOrganisationInput | SellerUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: SellerCreateManyOrganisationInputEnvelope
    set?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    disconnect?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    delete?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    connect?: SellerWhereUniqueInput | SellerWhereUniqueInput[]
    update?: SellerUpdateWithWhereUniqueWithoutOrganisationInput | SellerUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: SellerUpdateManyWithWhereWithoutOrganisationInput | SellerUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: SellerScalarWhereInput | SellerScalarWhereInput[]
  }

  export type TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<TransactionRecordCreateWithoutOrganisationInput, TransactionRecordUncheckedCreateWithoutOrganisationInput> | TransactionRecordCreateWithoutOrganisationInput[] | TransactionRecordUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutOrganisationInput | TransactionRecordCreateOrConnectWithoutOrganisationInput[]
    upsert?: TransactionRecordUpsertWithWhereUniqueWithoutOrganisationInput | TransactionRecordUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: TransactionRecordCreateManyOrganisationInputEnvelope
    set?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    disconnect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    delete?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    update?: TransactionRecordUpdateWithWhereUniqueWithoutOrganisationInput | TransactionRecordUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: TransactionRecordUpdateManyWithWhereWithoutOrganisationInput | TransactionRecordUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: TransactionRecordScalarWhereInput | TransactionRecordScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<CustomerCreateWithoutOrganisationInput, CustomerUncheckedCreateWithoutOrganisationInput> | CustomerCreateWithoutOrganisationInput[] | CustomerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganisationInput | CustomerCreateOrConnectWithoutOrganisationInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutOrganisationInput | CustomerUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: CustomerCreateManyOrganisationInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutOrganisationInput | CustomerUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutOrganisationInput | CustomerUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<InventoryCreateWithoutOrganisationInput, InventoryUncheckedCreateWithoutOrganisationInput> | InventoryCreateWithoutOrganisationInput[] | InventoryUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutOrganisationInput | InventoryCreateOrConnectWithoutOrganisationInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutOrganisationInput | InventoryUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: InventoryCreateManyOrganisationInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutOrganisationInput | InventoryUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutOrganisationInput | InventoryUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<CustomerSubmissionCreateWithoutOrganisationInput, CustomerSubmissionUncheckedCreateWithoutOrganisationInput> | CustomerSubmissionCreateWithoutOrganisationInput[] | CustomerSubmissionUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutOrganisationInput | CustomerSubmissionCreateOrConnectWithoutOrganisationInput[]
    upsert?: CustomerSubmissionUpsertWithWhereUniqueWithoutOrganisationInput | CustomerSubmissionUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: CustomerSubmissionCreateManyOrganisationInputEnvelope
    set?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    disconnect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    delete?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    update?: CustomerSubmissionUpdateWithWhereUniqueWithoutOrganisationInput | CustomerSubmissionUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: CustomerSubmissionUpdateManyWithWhereWithoutOrganisationInput | CustomerSubmissionUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: CustomerSubmissionScalarWhereInput | CustomerSubmissionScalarWhereInput[]
  }

  export type ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<ShippingMethodCreateWithoutOrganisationInput, ShippingMethodUncheckedCreateWithoutOrganisationInput> | ShippingMethodCreateWithoutOrganisationInput[] | ShippingMethodUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: ShippingMethodCreateOrConnectWithoutOrganisationInput | ShippingMethodCreateOrConnectWithoutOrganisationInput[]
    upsert?: ShippingMethodUpsertWithWhereUniqueWithoutOrganisationInput | ShippingMethodUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: ShippingMethodCreateManyOrganisationInputEnvelope
    set?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    disconnect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    delete?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    connect?: ShippingMethodWhereUniqueInput | ShippingMethodWhereUniqueInput[]
    update?: ShippingMethodUpdateWithWhereUniqueWithoutOrganisationInput | ShippingMethodUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: ShippingMethodUpdateManyWithWhereWithoutOrganisationInput | ShippingMethodUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
  }

  export type MandateUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<MandateCreateWithoutOrganisationInput, MandateUncheckedCreateWithoutOrganisationInput> | MandateCreateWithoutOrganisationInput[] | MandateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateCreateOrConnectWithoutOrganisationInput | MandateCreateOrConnectWithoutOrganisationInput[]
    upsert?: MandateUpsertWithWhereUniqueWithoutOrganisationInput | MandateUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: MandateCreateManyOrganisationInputEnvelope
    set?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    disconnect?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    delete?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    connect?: MandateWhereUniqueInput | MandateWhereUniqueInput[]
    update?: MandateUpdateWithWhereUniqueWithoutOrganisationInput | MandateUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: MandateUpdateManyWithWhereWithoutOrganisationInput | MandateUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: MandateScalarWhereInput | MandateScalarWhereInput[]
  }

  export type ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput = {
    create?: XOR<ActiveMandateCreateWithoutOrganisationInput, ActiveMandateUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: ActiveMandateCreateOrConnectWithoutOrganisationInput
    upsert?: ActiveMandateUpsertWithoutOrganisationInput
    disconnect?: ActiveMandateWhereInput | boolean
    delete?: ActiveMandateWhereInput | boolean
    connect?: ActiveMandateWhereUniqueInput
    update?: XOR<XOR<ActiveMandateUpdateToOneWithWhereWithoutOrganisationInput, ActiveMandateUpdateWithoutOrganisationInput>, ActiveMandateUncheckedUpdateWithoutOrganisationInput>
  }

  export type MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<MandateNotificationCreateWithoutOrganisationInput, MandateNotificationUncheckedCreateWithoutOrganisationInput> | MandateNotificationCreateWithoutOrganisationInput[] | MandateNotificationUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: MandateNotificationCreateOrConnectWithoutOrganisationInput | MandateNotificationCreateOrConnectWithoutOrganisationInput[]
    upsert?: MandateNotificationUpsertWithWhereUniqueWithoutOrganisationInput | MandateNotificationUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: MandateNotificationCreateManyOrganisationInputEnvelope
    set?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    disconnect?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    delete?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    connect?: MandateNotificationWhereUniqueInput | MandateNotificationWhereUniqueInput[]
    update?: MandateNotificationUpdateWithWhereUniqueWithoutOrganisationInput | MandateNotificationUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: MandateNotificationUpdateManyWithWhereWithoutOrganisationInput | MandateNotificationUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: MandateNotificationScalarWhereInput | MandateNotificationScalarWhereInput[]
  }

  export type OrganisationCreateNestedOneWithoutCustomerSubmissionInput = {
    create?: XOR<OrganisationCreateWithoutCustomerSubmissionInput, OrganisationUncheckedCreateWithoutCustomerSubmissionInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutCustomerSubmissionInput
    connect?: OrganisationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCustomerSubmissionInput = {
    create?: XOR<CustomerCreateWithoutCustomerSubmissionInput, CustomerUncheckedCreateWithoutCustomerSubmissionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerSubmissionInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrganisationUpdateOneRequiredWithoutCustomerSubmissionNestedInput = {
    create?: XOR<OrganisationCreateWithoutCustomerSubmissionInput, OrganisationUncheckedCreateWithoutCustomerSubmissionInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutCustomerSubmissionInput
    upsert?: OrganisationUpsertWithoutCustomerSubmissionInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutCustomerSubmissionInput, OrganisationUpdateWithoutCustomerSubmissionInput>, OrganisationUncheckedUpdateWithoutCustomerSubmissionInput>
  }

  export type CustomerUpdateOneWithoutCustomerSubmissionNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerSubmissionInput, CustomerUncheckedCreateWithoutCustomerSubmissionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerSubmissionInput
    upsert?: CustomerUpsertWithoutCustomerSubmissionInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerSubmissionInput, CustomerUpdateWithoutCustomerSubmissionInput>, CustomerUncheckedUpdateWithoutCustomerSubmissionInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganisationCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<OrganisationCreateWithoutProductCategoriesInput, OrganisationUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutProductCategoriesInput
    connect?: OrganisationWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrganisationUpdateOneRequiredWithoutProductCategoriesNestedInput = {
    create?: XOR<OrganisationCreateWithoutProductCategoriesInput, OrganisationUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutProductCategoriesInput
    upsert?: OrganisationUpsertWithoutProductCategoriesInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutProductCategoriesInput, OrganisationUpdateWithoutProductCategoriesInput>, OrganisationUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCategoryInput | InventoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCategoryInput | InventoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCategoryInput | InventoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput> | InventoryCreateWithoutCategoryInput[] | InventoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutCategoryInput | InventoryCreateOrConnectWithoutCategoryInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutCategoryInput | InventoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: InventoryCreateManyCategoryInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutCategoryInput | InventoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutCategoryInput | InventoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrganisationCreateNestedOneWithoutProductsInput = {
    create?: XOR<OrganisationCreateWithoutProductsInput, OrganisationUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutProductsInput
    connect?: OrganisationWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type InventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type TransactionItemCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type TransactionItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type OrganisationUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<OrganisationCreateWithoutProductsInput, OrganisationUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutProductsInput
    upsert?: OrganisationUpsertWithoutProductsInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutProductsInput, OrganisationUpdateWithoutProductsInput>, OrganisationUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type InventoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type TransactionItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutProductInput | TransactionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutProductInput | TransactionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutProductInput | TransactionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type TransactionItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput> | TransactionItemCreateWithoutProductInput[] | TransactionItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutProductInput | TransactionItemCreateOrConnectWithoutProductInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutProductInput | TransactionItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransactionItemCreateManyProductInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutProductInput | TransactionItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutProductInput | TransactionItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type OrganisationCreateNestedOneWithoutSellersInput = {
    create?: XOR<OrganisationCreateWithoutSellersInput, OrganisationUncheckedCreateWithoutSellersInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutSellersInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationUpdateOneRequiredWithoutSellersNestedInput = {
    create?: XOR<OrganisationCreateWithoutSellersInput, OrganisationUncheckedCreateWithoutSellersInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutSellersInput
    upsert?: OrganisationUpsertWithoutSellersInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutSellersInput, OrganisationUpdateWithoutSellersInput>, OrganisationUncheckedUpdateWithoutSellersInput>
  }

  export type OrganisationCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<OrganisationCreateWithoutTransactionsInput, OrganisationUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutTransactionsInput
    connect?: OrganisationWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type TransactionItemCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type TransactionShippingCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionShippingCreateWithoutTransactionInput, TransactionShippingUncheckedCreateWithoutTransactionInput> | TransactionShippingCreateWithoutTransactionInput[] | TransactionShippingUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionShippingCreateOrConnectWithoutTransactionInput | TransactionShippingCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionShippingCreateManyTransactionInputEnvelope
    connect?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
  }

  export type TransactionItemUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
  }

  export type TransactionShippingUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionShippingCreateWithoutTransactionInput, TransactionShippingUncheckedCreateWithoutTransactionInput> | TransactionShippingCreateWithoutTransactionInput[] | TransactionShippingUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionShippingCreateOrConnectWithoutTransactionInput | TransactionShippingCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionShippingCreateManyTransactionInputEnvelope
    connect?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OrganisationUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<OrganisationCreateWithoutTransactionsInput, OrganisationUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutTransactionsInput
    upsert?: OrganisationUpsertWithoutTransactionsInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutTransactionsInput, OrganisationUpdateWithoutTransactionsInput>, OrganisationUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionItemUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutTransactionInput | TransactionItemUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutTransactionInput | TransactionItemUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutTransactionInput | TransactionItemUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type TransactionShippingUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionShippingCreateWithoutTransactionInput, TransactionShippingUncheckedCreateWithoutTransactionInput> | TransactionShippingCreateWithoutTransactionInput[] | TransactionShippingUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionShippingCreateOrConnectWithoutTransactionInput | TransactionShippingCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionShippingUpsertWithWhereUniqueWithoutTransactionInput | TransactionShippingUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionShippingCreateManyTransactionInputEnvelope
    set?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    disconnect?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    delete?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    connect?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    update?: TransactionShippingUpdateWithWhereUniqueWithoutTransactionInput | TransactionShippingUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionShippingUpdateManyWithWhereWithoutTransactionInput | TransactionShippingUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionShippingScalarWhereInput | TransactionShippingScalarWhereInput[]
  }

  export type TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput> | TransactionItemCreateWithoutTransactionInput[] | TransactionItemUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionItemCreateOrConnectWithoutTransactionInput | TransactionItemCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionItemUpsertWithWhereUniqueWithoutTransactionInput | TransactionItemUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionItemCreateManyTransactionInputEnvelope
    set?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    disconnect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    delete?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    connect?: TransactionItemWhereUniqueInput | TransactionItemWhereUniqueInput[]
    update?: TransactionItemUpdateWithWhereUniqueWithoutTransactionInput | TransactionItemUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionItemUpdateManyWithWhereWithoutTransactionInput | TransactionItemUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
  }

  export type TransactionShippingUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionShippingCreateWithoutTransactionInput, TransactionShippingUncheckedCreateWithoutTransactionInput> | TransactionShippingCreateWithoutTransactionInput[] | TransactionShippingUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionShippingCreateOrConnectWithoutTransactionInput | TransactionShippingCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionShippingUpsertWithWhereUniqueWithoutTransactionInput | TransactionShippingUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionShippingCreateManyTransactionInputEnvelope
    set?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    disconnect?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    delete?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    connect?: TransactionShippingWhereUniqueInput | TransactionShippingWhereUniqueInput[]
    update?: TransactionShippingUpdateWithWhereUniqueWithoutTransactionInput | TransactionShippingUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionShippingUpdateManyWithWhereWithoutTransactionInput | TransactionShippingUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionShippingScalarWhereInput | TransactionShippingScalarWhereInput[]
  }

  export type TransactionRecordCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransactionRecordCreateWithoutItemsInput, TransactionRecordUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutItemsInput
    connect?: TransactionRecordWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransactionItemsInput = {
    create?: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type TransactionRecordUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransactionRecordCreateWithoutItemsInput, TransactionRecordUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutItemsInput
    upsert?: TransactionRecordUpsertWithoutItemsInput
    connect?: TransactionRecordWhereUniqueInput
    update?: XOR<XOR<TransactionRecordUpdateToOneWithWhereWithoutItemsInput, TransactionRecordUpdateWithoutItemsInput>, TransactionRecordUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutTransactionItemsNestedInput = {
    create?: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionItemsInput
    upsert?: ProductUpsertWithoutTransactionItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransactionItemsInput, ProductUpdateWithoutTransactionItemsInput>, ProductUncheckedUpdateWithoutTransactionItemsInput>
  }

  export type OrganisationCreateNestedOneWithoutCustomersInput = {
    create?: XOR<OrganisationCreateWithoutCustomersInput, OrganisationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutCustomersInput
    connect?: OrganisationWhereUniqueInput
  }

  export type TransactionRecordCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionRecordCreateWithoutCustomerInput, TransactionRecordUncheckedCreateWithoutCustomerInput> | TransactionRecordCreateWithoutCustomerInput[] | TransactionRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutCustomerInput | TransactionRecordCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionRecordCreateManyCustomerInputEnvelope
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
  }

  export type CustomerSubmissionCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerSubmissionCreateWithoutCustomersInput, CustomerSubmissionUncheckedCreateWithoutCustomersInput> | CustomerSubmissionCreateWithoutCustomersInput[] | CustomerSubmissionUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutCustomersInput | CustomerSubmissionCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerSubmissionCreateManyCustomersInputEnvelope
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
  }

  export type TransactionRecordUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionRecordCreateWithoutCustomerInput, TransactionRecordUncheckedCreateWithoutCustomerInput> | TransactionRecordCreateWithoutCustomerInput[] | TransactionRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutCustomerInput | TransactionRecordCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionRecordCreateManyCustomerInputEnvelope
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
  }

  export type CustomerSubmissionUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CustomerSubmissionCreateWithoutCustomersInput, CustomerSubmissionUncheckedCreateWithoutCustomersInput> | CustomerSubmissionCreateWithoutCustomersInput[] | CustomerSubmissionUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutCustomersInput | CustomerSubmissionCreateOrConnectWithoutCustomersInput[]
    createMany?: CustomerSubmissionCreateManyCustomersInputEnvelope
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
  }

  export type OrganisationUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<OrganisationCreateWithoutCustomersInput, OrganisationUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutCustomersInput
    upsert?: OrganisationUpsertWithoutCustomersInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutCustomersInput, OrganisationUpdateWithoutCustomersInput>, OrganisationUncheckedUpdateWithoutCustomersInput>
  }

  export type TransactionRecordUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionRecordCreateWithoutCustomerInput, TransactionRecordUncheckedCreateWithoutCustomerInput> | TransactionRecordCreateWithoutCustomerInput[] | TransactionRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutCustomerInput | TransactionRecordCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionRecordUpsertWithWhereUniqueWithoutCustomerInput | TransactionRecordUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionRecordCreateManyCustomerInputEnvelope
    set?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    disconnect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    delete?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    update?: TransactionRecordUpdateWithWhereUniqueWithoutCustomerInput | TransactionRecordUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionRecordUpdateManyWithWhereWithoutCustomerInput | TransactionRecordUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionRecordScalarWhereInput | TransactionRecordScalarWhereInput[]
  }

  export type CustomerSubmissionUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerSubmissionCreateWithoutCustomersInput, CustomerSubmissionUncheckedCreateWithoutCustomersInput> | CustomerSubmissionCreateWithoutCustomersInput[] | CustomerSubmissionUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutCustomersInput | CustomerSubmissionCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerSubmissionUpsertWithWhereUniqueWithoutCustomersInput | CustomerSubmissionUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerSubmissionCreateManyCustomersInputEnvelope
    set?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    disconnect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    delete?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    update?: CustomerSubmissionUpdateWithWhereUniqueWithoutCustomersInput | CustomerSubmissionUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerSubmissionUpdateManyWithWhereWithoutCustomersInput | CustomerSubmissionUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerSubmissionScalarWhereInput | CustomerSubmissionScalarWhereInput[]
  }

  export type TransactionRecordUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionRecordCreateWithoutCustomerInput, TransactionRecordUncheckedCreateWithoutCustomerInput> | TransactionRecordCreateWithoutCustomerInput[] | TransactionRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutCustomerInput | TransactionRecordCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionRecordUpsertWithWhereUniqueWithoutCustomerInput | TransactionRecordUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionRecordCreateManyCustomerInputEnvelope
    set?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    disconnect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    delete?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    connect?: TransactionRecordWhereUniqueInput | TransactionRecordWhereUniqueInput[]
    update?: TransactionRecordUpdateWithWhereUniqueWithoutCustomerInput | TransactionRecordUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionRecordUpdateManyWithWhereWithoutCustomerInput | TransactionRecordUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionRecordScalarWhereInput | TransactionRecordScalarWhereInput[]
  }

  export type CustomerSubmissionUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CustomerSubmissionCreateWithoutCustomersInput, CustomerSubmissionUncheckedCreateWithoutCustomersInput> | CustomerSubmissionCreateWithoutCustomersInput[] | CustomerSubmissionUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CustomerSubmissionCreateOrConnectWithoutCustomersInput | CustomerSubmissionCreateOrConnectWithoutCustomersInput[]
    upsert?: CustomerSubmissionUpsertWithWhereUniqueWithoutCustomersInput | CustomerSubmissionUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CustomerSubmissionCreateManyCustomersInputEnvelope
    set?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    disconnect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    delete?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    connect?: CustomerSubmissionWhereUniqueInput | CustomerSubmissionWhereUniqueInput[]
    update?: CustomerSubmissionUpdateWithWhereUniqueWithoutCustomersInput | CustomerSubmissionUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CustomerSubmissionUpdateManyWithWhereWithoutCustomersInput | CustomerSubmissionUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CustomerSubmissionScalarWhereInput | CustomerSubmissionScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ProductCategoryCreateWithoutInventoryInput, ProductCategoryUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutInventoryInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type OrganisationCreateNestedOneWithoutInventoryInput = {
    create?: XOR<OrganisationCreateWithoutInventoryInput, OrganisationUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutInventoryInput
    connect?: OrganisationWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryInput
    upsert?: ProductUpsertWithoutInventoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryInput, ProductUpdateWithoutInventoryInput>, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductCategoryUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutInventoryInput, ProductCategoryUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutInventoryInput
    upsert?: ProductCategoryUpsertWithoutInventoryInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutInventoryInput, ProductCategoryUpdateWithoutInventoryInput>, ProductCategoryUncheckedUpdateWithoutInventoryInput>
  }

  export type OrganisationUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<OrganisationCreateWithoutInventoryInput, OrganisationUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutInventoryInput
    upsert?: OrganisationUpsertWithoutInventoryInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutInventoryInput, OrganisationUpdateWithoutInventoryInput>, OrganisationUncheckedUpdateWithoutInventoryInput>
  }

  export type OrganisationCreateNestedOneWithoutShippingMethodInput = {
    create?: XOR<OrganisationCreateWithoutShippingMethodInput, OrganisationUncheckedCreateWithoutShippingMethodInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutShippingMethodInput
    connect?: OrganisationWhereUniqueInput
  }

  export type EnumShippingMethodTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShippingMethodType
  }

  export type OrganisationUpdateOneRequiredWithoutShippingMethodNestedInput = {
    create?: XOR<OrganisationCreateWithoutShippingMethodInput, OrganisationUncheckedCreateWithoutShippingMethodInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutShippingMethodInput
    upsert?: OrganisationUpsertWithoutShippingMethodInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutShippingMethodInput, OrganisationUpdateWithoutShippingMethodInput>, OrganisationUncheckedUpdateWithoutShippingMethodInput>
  }

  export type TransactionRecordCreateNestedOneWithoutTransactionShippingInput = {
    create?: XOR<TransactionRecordCreateWithoutTransactionShippingInput, TransactionRecordUncheckedCreateWithoutTransactionShippingInput>
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutTransactionShippingInput
    connect?: TransactionRecordWhereUniqueInput
  }

  export type TransactionRecordUpdateOneRequiredWithoutTransactionShippingNestedInput = {
    create?: XOR<TransactionRecordCreateWithoutTransactionShippingInput, TransactionRecordUncheckedCreateWithoutTransactionShippingInput>
    connectOrCreate?: TransactionRecordCreateOrConnectWithoutTransactionShippingInput
    upsert?: TransactionRecordUpsertWithoutTransactionShippingInput
    connect?: TransactionRecordWhereUniqueInput
    update?: XOR<XOR<TransactionRecordUpdateToOneWithWhereWithoutTransactionShippingInput, TransactionRecordUpdateWithoutTransactionShippingInput>, TransactionRecordUncheckedUpdateWithoutTransactionShippingInput>
  }

  export type OrganisationCreateNestedOneWithoutMandateInput = {
    create?: XOR<OrganisationCreateWithoutMandateInput, OrganisationUncheckedCreateWithoutMandateInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutMandateInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationUpdateOneRequiredWithoutMandateNestedInput = {
    create?: XOR<OrganisationCreateWithoutMandateInput, OrganisationUncheckedCreateWithoutMandateInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutMandateInput
    upsert?: OrganisationUpsertWithoutMandateInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutMandateInput, OrganisationUpdateWithoutMandateInput>, OrganisationUncheckedUpdateWithoutMandateInput>
  }

  export type OrganisationCreateNestedOneWithoutActiveMandatesInput = {
    create?: XOR<OrganisationCreateWithoutActiveMandatesInput, OrganisationUncheckedCreateWithoutActiveMandatesInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutActiveMandatesInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationUpdateOneRequiredWithoutActiveMandatesNestedInput = {
    create?: XOR<OrganisationCreateWithoutActiveMandatesInput, OrganisationUncheckedCreateWithoutActiveMandatesInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutActiveMandatesInput
    upsert?: OrganisationUpsertWithoutActiveMandatesInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutActiveMandatesInput, OrganisationUpdateWithoutActiveMandatesInput>, OrganisationUncheckedUpdateWithoutActiveMandatesInput>
  }

  export type OrganisationCreateNestedOneWithoutMandateNotificationInput = {
    create?: XOR<OrganisationCreateWithoutMandateNotificationInput, OrganisationUncheckedCreateWithoutMandateNotificationInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutMandateNotificationInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationUpdateOneRequiredWithoutMandateNotificationNestedInput = {
    create?: XOR<OrganisationCreateWithoutMandateNotificationInput, OrganisationUncheckedCreateWithoutMandateNotificationInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutMandateNotificationInput
    upsert?: OrganisationUpsertWithoutMandateNotificationInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutMandateNotificationInput, OrganisationUpdateWithoutMandateNotificationInput>, OrganisationUncheckedUpdateWithoutMandateNotificationInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumShippingMethodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingMethodType | EnumShippingMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingMethodType[]
    notIn?: $Enums.ShippingMethodType[]
    not?: NestedEnumShippingMethodTypeFilter<$PrismaModel> | $Enums.ShippingMethodType
  }

  export type NestedEnumShippingMethodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingMethodType | EnumShippingMethodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingMethodType[]
    notIn?: $Enums.ShippingMethodType[]
    not?: NestedEnumShippingMethodTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShippingMethodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingMethodTypeFilter<$PrismaModel>
    _max?: NestedEnumShippingMethodTypeFilter<$PrismaModel>
  }

  export type ProductCategoryCreateWithoutOrganisationInput = {
    name: string
    products?: ProductCreateNestedManyWithoutCategoryInput
    inventory?: InventoryCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutOrganisationInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutOrganisationInput, ProductCategoryUncheckedCreateWithoutOrganisationInput>
  }

  export type ProductCategoryCreateManyOrganisationInputEnvelope = {
    data: ProductCategoryCreateManyOrganisationInput | ProductCategoryCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutOrganisationInput = {
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    transactionItems?: TransactionItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    categoryId?: number | null
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    transactionItems?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrganisationInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrganisationInput, ProductUncheckedCreateWithoutOrganisationInput>
  }

  export type ProductCreateManyOrganisationInputEnvelope = {
    data: ProductCreateManyOrganisationInput | ProductCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type SellerCreateWithoutOrganisationInput = {
    name: string
    contact: string
    type: string
  }

  export type SellerUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    contact: string
    type: string
  }

  export type SellerCreateOrConnectWithoutOrganisationInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutOrganisationInput, SellerUncheckedCreateWithoutOrganisationInput>
  }

  export type SellerCreateManyOrganisationInputEnvelope = {
    data: SellerCreateManyOrganisationInput | SellerCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type TransactionRecordCreateWithoutOrganisationInput = {
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    TransactionShipping?: TransactionShippingCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordUncheckedCreateWithoutOrganisationInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    customerId?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    TransactionShipping?: TransactionShippingUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordCreateOrConnectWithoutOrganisationInput = {
    where: TransactionRecordWhereUniqueInput
    create: XOR<TransactionRecordCreateWithoutOrganisationInput, TransactionRecordUncheckedCreateWithoutOrganisationInput>
  }

  export type TransactionRecordCreateManyOrganisationInputEnvelope = {
    data: TransactionRecordCreateManyOrganisationInput | TransactionRecordCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutOrganisationInput = {
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    transactions?: TransactionRecordCreateNestedManyWithoutCustomerInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutCustomerInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutOrganisationInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrganisationInput, CustomerUncheckedCreateWithoutOrganisationInput>
  }

  export type CustomerCreateManyOrganisationInputEnvelope = {
    data: CustomerCreateManyOrganisationInput | CustomerCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutOrganisationInput = {
    quantity: number
    product: ProductCreateNestedOneWithoutInventoryInput
    category?: ProductCategoryCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutOrganisationInput = {
    id?: number
    productId: number
    categoryId?: number | null
    quantity: number
  }

  export type InventoryCreateOrConnectWithoutOrganisationInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutOrganisationInput, InventoryUncheckedCreateWithoutOrganisationInput>
  }

  export type InventoryCreateManyOrganisationInputEnvelope = {
    data: InventoryCreateManyOrganisationInput | InventoryCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type CustomerSubmissionCreateWithoutOrganisationInput = {
    token: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedOneWithoutCustomerSubmissionInput
  }

  export type CustomerSubmissionUncheckedCreateWithoutOrganisationInput = {
    id?: number
    token: string
    customerId?: number | null
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubmissionCreateOrConnectWithoutOrganisationInput = {
    where: CustomerSubmissionWhereUniqueInput
    create: XOR<CustomerSubmissionCreateWithoutOrganisationInput, CustomerSubmissionUncheckedCreateWithoutOrganisationInput>
  }

  export type CustomerSubmissionCreateManyOrganisationInputEnvelope = {
    data: CustomerSubmissionCreateManyOrganisationInput | CustomerSubmissionCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type ShippingMethodCreateWithoutOrganisationInput = {
    name: string
    type: $Enums.ShippingMethodType
    minAmount?: number | null
    useWeight?: boolean
    ratePerKg?: number | null
    fixedRate?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingMethodUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    type: $Enums.ShippingMethodType
    minAmount?: number | null
    useWeight?: boolean
    ratePerKg?: number | null
    fixedRate?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingMethodCreateOrConnectWithoutOrganisationInput = {
    where: ShippingMethodWhereUniqueInput
    create: XOR<ShippingMethodCreateWithoutOrganisationInput, ShippingMethodUncheckedCreateWithoutOrganisationInput>
  }

  export type ShippingMethodCreateManyOrganisationInputEnvelope = {
    data: ShippingMethodCreateManyOrganisationInput | ShippingMethodCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type MandateCreateWithoutOrganisationInput = {
    merchantTranId: string
    bankRRN?: string | null
    UMN?: string | null
    amount: number
    status: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    txnInitDate?: Date | string | null
    txnCompletionDate?: Date | string | null
    responseCode?: string | null
    respCodeDescription?: string | null
  }

  export type MandateUncheckedCreateWithoutOrganisationInput = {
    id?: number
    merchantTranId: string
    bankRRN?: string | null
    UMN?: string | null
    amount: number
    status: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    txnInitDate?: Date | string | null
    txnCompletionDate?: Date | string | null
    responseCode?: string | null
    respCodeDescription?: string | null
  }

  export type MandateCreateOrConnectWithoutOrganisationInput = {
    where: MandateWhereUniqueInput
    create: XOR<MandateCreateWithoutOrganisationInput, MandateUncheckedCreateWithoutOrganisationInput>
  }

  export type MandateCreateManyOrganisationInputEnvelope = {
    data: MandateCreateManyOrganisationInput | MandateCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type ActiveMandateCreateWithoutOrganisationInput = {
    UMN?: string | null
    mandateSeqNo?: number
    amount: number
    notificationRetries?: number
    retryCount?: number
    status?: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    notified?: boolean
    lastAttemptAt?: Date | string | null
    lastNotificationAttempt?: Date | string | null
  }

  export type ActiveMandateUncheckedCreateWithoutOrganisationInput = {
    id?: number
    UMN?: string | null
    mandateSeqNo?: number
    amount: number
    notificationRetries?: number
    retryCount?: number
    status?: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    notified?: boolean
    lastAttemptAt?: Date | string | null
    lastNotificationAttempt?: Date | string | null
  }

  export type ActiveMandateCreateOrConnectWithoutOrganisationInput = {
    where: ActiveMandateWhereUniqueInput
    create: XOR<ActiveMandateCreateWithoutOrganisationInput, ActiveMandateUncheckedCreateWithoutOrganisationInput>
  }

  export type MandateNotificationCreateWithoutOrganisationInput = {
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MandateNotificationUncheckedCreateWithoutOrganisationInput = {
    id?: number
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MandateNotificationCreateOrConnectWithoutOrganisationInput = {
    where: MandateNotificationWhereUniqueInput
    create: XOR<MandateNotificationCreateWithoutOrganisationInput, MandateNotificationUncheckedCreateWithoutOrganisationInput>
  }

  export type MandateNotificationCreateManyOrganisationInputEnvelope = {
    data: MandateNotificationCreateManyOrganisationInput | MandateNotificationCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutOrganisationInput, ProductCategoryUncheckedUpdateWithoutOrganisationInput>
    create: XOR<ProductCategoryCreateWithoutOrganisationInput, ProductCategoryUncheckedCreateWithoutOrganisationInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutOrganisationInput, ProductCategoryUncheckedUpdateWithoutOrganisationInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutOrganisationInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    organisationId?: IntFilter<"ProductCategory"> | number
  }

  export type ProductUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOrganisationInput, ProductUncheckedUpdateWithoutOrganisationInput>
    create: XOR<ProductCreateWithoutOrganisationInput, ProductUncheckedCreateWithoutOrganisationInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOrganisationInput, ProductUncheckedUpdateWithoutOrganisationInput>
  }

  export type ProductUpdateManyWithWhereWithoutOrganisationInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    SKU?: StringFilter<"Product"> | string
    netPrice?: FloatFilter<"Product"> | number
    sellingPrice?: FloatFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    seller?: StringFilter<"Product"> | string
    organisationId?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
  }

  export type SellerUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: SellerWhereUniqueInput
    update: XOR<SellerUpdateWithoutOrganisationInput, SellerUncheckedUpdateWithoutOrganisationInput>
    create: XOR<SellerCreateWithoutOrganisationInput, SellerUncheckedCreateWithoutOrganisationInput>
  }

  export type SellerUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: SellerWhereUniqueInput
    data: XOR<SellerUpdateWithoutOrganisationInput, SellerUncheckedUpdateWithoutOrganisationInput>
  }

  export type SellerUpdateManyWithWhereWithoutOrganisationInput = {
    where: SellerScalarWhereInput
    data: XOR<SellerUpdateManyMutationInput, SellerUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type SellerScalarWhereInput = {
    AND?: SellerScalarWhereInput | SellerScalarWhereInput[]
    OR?: SellerScalarWhereInput[]
    NOT?: SellerScalarWhereInput | SellerScalarWhereInput[]
    id?: IntFilter<"Seller"> | number
    name?: StringFilter<"Seller"> | string
    contact?: StringFilter<"Seller"> | string
    type?: StringFilter<"Seller"> | string
    organisationId?: IntFilter<"Seller"> | number
  }

  export type TransactionRecordUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: TransactionRecordWhereUniqueInput
    update: XOR<TransactionRecordUpdateWithoutOrganisationInput, TransactionRecordUncheckedUpdateWithoutOrganisationInput>
    create: XOR<TransactionRecordCreateWithoutOrganisationInput, TransactionRecordUncheckedCreateWithoutOrganisationInput>
  }

  export type TransactionRecordUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: TransactionRecordWhereUniqueInput
    data: XOR<TransactionRecordUpdateWithoutOrganisationInput, TransactionRecordUncheckedUpdateWithoutOrganisationInput>
  }

  export type TransactionRecordUpdateManyWithWhereWithoutOrganisationInput = {
    where: TransactionRecordScalarWhereInput
    data: XOR<TransactionRecordUpdateManyMutationInput, TransactionRecordUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type TransactionRecordScalarWhereInput = {
    AND?: TransactionRecordScalarWhereInput | TransactionRecordScalarWhereInput[]
    OR?: TransactionRecordScalarWhereInput[]
    NOT?: TransactionRecordScalarWhereInput | TransactionRecordScalarWhereInput[]
    id?: IntFilter<"TransactionRecord"> | number
    billNo?: IntFilter<"TransactionRecord"> | number
    totalPrice?: FloatFilter<"TransactionRecord"> | number
    paymentMethod?: StringFilter<"TransactionRecord"> | string
    amountPaid?: FloatFilter<"TransactionRecord"> | number
    balance?: FloatFilter<"TransactionRecord"> | number
    billingMode?: StringFilter<"TransactionRecord"> | string
    organisationId?: IntFilter<"TransactionRecord"> | number
    date?: DateTimeFilter<"TransactionRecord"> | Date | string
    time?: DateTimeFilter<"TransactionRecord"> | Date | string
    trackingNumber?: StringNullableFilter<"TransactionRecord"> | string | null
    weight?: FloatNullableFilter<"TransactionRecord"> | number | null
    customerId?: IntNullableFilter<"TransactionRecord"> | number | null
    status?: StringFilter<"TransactionRecord"> | string
    notes?: StringNullableFilter<"TransactionRecord"> | string | null
    paymentId?: StringNullableFilter<"TransactionRecord"> | string | null
    paymentStatus?: EnumPaymentStatusFilter<"TransactionRecord"> | $Enums.PaymentStatus
    isEdited?: BoolFilter<"TransactionRecord"> | boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutOrganisationInput, CustomerUncheckedUpdateWithoutOrganisationInput>
    create: XOR<CustomerCreateWithoutOrganisationInput, CustomerUncheckedCreateWithoutOrganisationInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutOrganisationInput, CustomerUncheckedUpdateWithoutOrganisationInput>
  }

  export type CustomerUpdateManyWithWhereWithoutOrganisationInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    district?: StringNullableFilter<"Customer"> | string | null
    state?: StringNullableFilter<"Customer"> | string | null
    pincode?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    flatNo?: StringNullableFilter<"Customer"> | string | null
    street?: StringNullableFilter<"Customer"> | string | null
    organisationId?: IntFilter<"Customer"> | number
  }

  export type InventoryUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutOrganisationInput, InventoryUncheckedUpdateWithoutOrganisationInput>
    create: XOR<InventoryCreateWithoutOrganisationInput, InventoryUncheckedCreateWithoutOrganisationInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutOrganisationInput, InventoryUncheckedUpdateWithoutOrganisationInput>
  }

  export type InventoryUpdateManyWithWhereWithoutOrganisationInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: IntFilter<"Inventory"> | number
    productId?: IntFilter<"Inventory"> | number
    categoryId?: IntNullableFilter<"Inventory"> | number | null
    organisationId?: IntFilter<"Inventory"> | number
    quantity?: IntFilter<"Inventory"> | number
  }

  export type CustomerSubmissionUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: CustomerSubmissionWhereUniqueInput
    update: XOR<CustomerSubmissionUpdateWithoutOrganisationInput, CustomerSubmissionUncheckedUpdateWithoutOrganisationInput>
    create: XOR<CustomerSubmissionCreateWithoutOrganisationInput, CustomerSubmissionUncheckedCreateWithoutOrganisationInput>
  }

  export type CustomerSubmissionUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: CustomerSubmissionWhereUniqueInput
    data: XOR<CustomerSubmissionUpdateWithoutOrganisationInput, CustomerSubmissionUncheckedUpdateWithoutOrganisationInput>
  }

  export type CustomerSubmissionUpdateManyWithWhereWithoutOrganisationInput = {
    where: CustomerSubmissionScalarWhereInput
    data: XOR<CustomerSubmissionUpdateManyMutationInput, CustomerSubmissionUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type CustomerSubmissionScalarWhereInput = {
    AND?: CustomerSubmissionScalarWhereInput | CustomerSubmissionScalarWhereInput[]
    OR?: CustomerSubmissionScalarWhereInput[]
    NOT?: CustomerSubmissionScalarWhereInput | CustomerSubmissionScalarWhereInput[]
    id?: IntFilter<"CustomerSubmission"> | number
    token?: StringFilter<"CustomerSubmission"> | string
    organisationId?: IntFilter<"CustomerSubmission"> | number
    customerId?: IntNullableFilter<"CustomerSubmission"> | number | null
    notes?: StringNullableFilter<"CustomerSubmission"> | string | null
    status?: StringFilter<"CustomerSubmission"> | string
    createdAt?: DateTimeFilter<"CustomerSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSubmission"> | Date | string
  }

  export type ShippingMethodUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: ShippingMethodWhereUniqueInput
    update: XOR<ShippingMethodUpdateWithoutOrganisationInput, ShippingMethodUncheckedUpdateWithoutOrganisationInput>
    create: XOR<ShippingMethodCreateWithoutOrganisationInput, ShippingMethodUncheckedCreateWithoutOrganisationInput>
  }

  export type ShippingMethodUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: ShippingMethodWhereUniqueInput
    data: XOR<ShippingMethodUpdateWithoutOrganisationInput, ShippingMethodUncheckedUpdateWithoutOrganisationInput>
  }

  export type ShippingMethodUpdateManyWithWhereWithoutOrganisationInput = {
    where: ShippingMethodScalarWhereInput
    data: XOR<ShippingMethodUpdateManyMutationInput, ShippingMethodUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type ShippingMethodScalarWhereInput = {
    AND?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
    OR?: ShippingMethodScalarWhereInput[]
    NOT?: ShippingMethodScalarWhereInput | ShippingMethodScalarWhereInput[]
    id?: IntFilter<"ShippingMethod"> | number
    name?: StringFilter<"ShippingMethod"> | string
    type?: EnumShippingMethodTypeFilter<"ShippingMethod"> | $Enums.ShippingMethodType
    minAmount?: FloatNullableFilter<"ShippingMethod"> | number | null
    useWeight?: BoolFilter<"ShippingMethod"> | boolean
    ratePerKg?: FloatNullableFilter<"ShippingMethod"> | number | null
    fixedRate?: FloatNullableFilter<"ShippingMethod"> | number | null
    isActive?: BoolFilter<"ShippingMethod"> | boolean
    organisationId?: IntFilter<"ShippingMethod"> | number
    createdAt?: DateTimeFilter<"ShippingMethod"> | Date | string
    updatedAt?: DateTimeFilter<"ShippingMethod"> | Date | string
  }

  export type MandateUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: MandateWhereUniqueInput
    update: XOR<MandateUpdateWithoutOrganisationInput, MandateUncheckedUpdateWithoutOrganisationInput>
    create: XOR<MandateCreateWithoutOrganisationInput, MandateUncheckedCreateWithoutOrganisationInput>
  }

  export type MandateUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: MandateWhereUniqueInput
    data: XOR<MandateUpdateWithoutOrganisationInput, MandateUncheckedUpdateWithoutOrganisationInput>
  }

  export type MandateUpdateManyWithWhereWithoutOrganisationInput = {
    where: MandateScalarWhereInput
    data: XOR<MandateUpdateManyMutationInput, MandateUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type MandateScalarWhereInput = {
    AND?: MandateScalarWhereInput | MandateScalarWhereInput[]
    OR?: MandateScalarWhereInput[]
    NOT?: MandateScalarWhereInput | MandateScalarWhereInput[]
    id?: IntFilter<"Mandate"> | number
    organisationId?: IntFilter<"Mandate"> | number
    merchantTranId?: StringFilter<"Mandate"> | string
    bankRRN?: StringNullableFilter<"Mandate"> | string | null
    UMN?: StringNullableFilter<"Mandate"> | string | null
    amount?: FloatFilter<"Mandate"> | number
    status?: StringFilter<"Mandate"> | string
    payerVA?: StringFilter<"Mandate"> | string
    payerName?: StringNullableFilter<"Mandate"> | string | null
    payerMobile?: StringNullableFilter<"Mandate"> | string | null
    txnInitDate?: DateTimeNullableFilter<"Mandate"> | Date | string | null
    txnCompletionDate?: DateTimeNullableFilter<"Mandate"> | Date | string | null
    responseCode?: StringNullableFilter<"Mandate"> | string | null
    respCodeDescription?: StringNullableFilter<"Mandate"> | string | null
  }

  export type ActiveMandateUpsertWithoutOrganisationInput = {
    update: XOR<ActiveMandateUpdateWithoutOrganisationInput, ActiveMandateUncheckedUpdateWithoutOrganisationInput>
    create: XOR<ActiveMandateCreateWithoutOrganisationInput, ActiveMandateUncheckedCreateWithoutOrganisationInput>
    where?: ActiveMandateWhereInput
  }

  export type ActiveMandateUpdateToOneWithWhereWithoutOrganisationInput = {
    where?: ActiveMandateWhereInput
    data: XOR<ActiveMandateUpdateWithoutOrganisationInput, ActiveMandateUncheckedUpdateWithoutOrganisationInput>
  }

  export type ActiveMandateUpdateWithoutOrganisationInput = {
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    mandateSeqNo?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notificationRetries?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    notified?: BoolFieldUpdateOperationsInput | boolean
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNotificationAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActiveMandateUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    mandateSeqNo?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    notificationRetries?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    notified?: BoolFieldUpdateOperationsInput | boolean
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNotificationAttempt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MandateNotificationUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: MandateNotificationWhereUniqueInput
    update: XOR<MandateNotificationUpdateWithoutOrganisationInput, MandateNotificationUncheckedUpdateWithoutOrganisationInput>
    create: XOR<MandateNotificationCreateWithoutOrganisationInput, MandateNotificationUncheckedCreateWithoutOrganisationInput>
  }

  export type MandateNotificationUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: MandateNotificationWhereUniqueInput
    data: XOR<MandateNotificationUpdateWithoutOrganisationInput, MandateNotificationUncheckedUpdateWithoutOrganisationInput>
  }

  export type MandateNotificationUpdateManyWithWhereWithoutOrganisationInput = {
    where: MandateNotificationScalarWhereInput
    data: XOR<MandateNotificationUpdateManyMutationInput, MandateNotificationUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type MandateNotificationScalarWhereInput = {
    AND?: MandateNotificationScalarWhereInput | MandateNotificationScalarWhereInput[]
    OR?: MandateNotificationScalarWhereInput[]
    NOT?: MandateNotificationScalarWhereInput | MandateNotificationScalarWhereInput[]
    id?: IntFilter<"MandateNotification"> | number
    organisationId?: IntFilter<"MandateNotification"> | number
    type?: StringFilter<"MandateNotification"> | string
    message?: StringFilter<"MandateNotification"> | string
    isRead?: BoolFilter<"MandateNotification"> | boolean
    createdAt?: DateTimeFilter<"MandateNotification"> | Date | string
  }

  export type OrganisationCreateWithoutCustomerSubmissionInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutCustomerSubmissionInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutCustomerSubmissionInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutCustomerSubmissionInput, OrganisationUncheckedCreateWithoutCustomerSubmissionInput>
  }

  export type CustomerCreateWithoutCustomerSubmissionInput = {
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    organisation: OrganisationCreateNestedOneWithoutCustomersInput
    transactions?: TransactionRecordCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerSubmissionInput = {
    id?: number
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    organisationId: number
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerSubmissionInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerSubmissionInput, CustomerUncheckedCreateWithoutCustomerSubmissionInput>
  }

  export type OrganisationUpsertWithoutCustomerSubmissionInput = {
    update: XOR<OrganisationUpdateWithoutCustomerSubmissionInput, OrganisationUncheckedUpdateWithoutCustomerSubmissionInput>
    create: XOR<OrganisationCreateWithoutCustomerSubmissionInput, OrganisationUncheckedCreateWithoutCustomerSubmissionInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutCustomerSubmissionInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutCustomerSubmissionInput, OrganisationUncheckedUpdateWithoutCustomerSubmissionInput>
  }

  export type OrganisationUpdateWithoutCustomerSubmissionInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutCustomerSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type CustomerUpsertWithoutCustomerSubmissionInput = {
    update: XOR<CustomerUpdateWithoutCustomerSubmissionInput, CustomerUncheckedUpdateWithoutCustomerSubmissionInput>
    create: XOR<CustomerCreateWithoutCustomerSubmissionInput, CustomerUncheckedCreateWithoutCustomerSubmissionInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerSubmissionInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerSubmissionInput, CustomerUncheckedUpdateWithoutCustomerSubmissionInput>
  }

  export type CustomerUpdateWithoutCustomerSubmissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: OrganisationUpdateOneRequiredWithoutCustomersNestedInput
    transactions?: TransactionRecordUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerSubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    transactions?: TransactionRecordUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrganisationCreateWithoutProductCategoriesInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutProductCategoriesInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutProductCategoriesInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutProductCategoriesInput, OrganisationUncheckedCreateWithoutProductCategoriesInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisation: OrganisationCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
    transactionItems?: TransactionItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisationId: number
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
    transactionItems?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type InventoryCreateWithoutCategoryInput = {
    quantity: number
    product: ProductCreateNestedOneWithoutInventoryInput
    organisation: OrganisationCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutCategoryInput = {
    id?: number
    productId: number
    organisationId: number
    quantity: number
  }

  export type InventoryCreateOrConnectWithoutCategoryInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput>
  }

  export type InventoryCreateManyCategoryInputEnvelope = {
    data: InventoryCreateManyCategoryInput | InventoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutProductCategoriesInput = {
    update: XOR<OrganisationUpdateWithoutProductCategoriesInput, OrganisationUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<OrganisationCreateWithoutProductCategoriesInput, OrganisationUncheckedCreateWithoutProductCategoriesInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutProductCategoriesInput, OrganisationUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type OrganisationUpdateWithoutProductCategoriesInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type InventoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutCategoryInput, InventoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<InventoryCreateWithoutCategoryInput, InventoryUncheckedCreateWithoutCategoryInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutCategoryInput, InventoryUncheckedUpdateWithoutCategoryInput>
  }

  export type InventoryUpdateManyWithWhereWithoutCategoryInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type OrganisationCreateWithoutProductsInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutProductsInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutProductsInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutProductsInput, OrganisationUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    name: string
    organisation: OrganisationCreateNestedOneWithoutProductCategoriesInput
    inventory?: InventoryCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    organisationId: number
    inventory?: InventoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type InventoryCreateWithoutProductInput = {
    quantity: number
    category?: ProductCategoryCreateNestedOneWithoutInventoryInput
    organisation: OrganisationCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: number
    categoryId?: number | null
    organisationId: number
    quantity: number
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryCreateManyProductInputEnvelope = {
    data: InventoryCreateManyProductInput | InventoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TransactionItemCreateWithoutProductInput = {
    quantity: number
    totalPrice: number
    transaction: TransactionRecordCreateNestedOneWithoutItemsInput
  }

  export type TransactionItemUncheckedCreateWithoutProductInput = {
    id?: number
    transactionId: number
    quantity: number
    totalPrice: number
  }

  export type TransactionItemCreateOrConnectWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    create: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput>
  }

  export type TransactionItemCreateManyProductInputEnvelope = {
    data: TransactionItemCreateManyProductInput | TransactionItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutProductsInput = {
    update: XOR<OrganisationUpdateWithoutProductsInput, OrganisationUncheckedUpdateWithoutProductsInput>
    create: XOR<OrganisationCreateWithoutProductsInput, OrganisationUncheckedCreateWithoutProductsInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutProductsInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutProductsInput, OrganisationUncheckedUpdateWithoutProductsInput>
  }

  export type OrganisationUpdateWithoutProductsInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutProductCategoriesNestedInput
    inventory?: InventoryUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    inventory?: InventoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type InventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateManyWithWhereWithoutProductInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutProductInput>
  }

  export type TransactionItemUpsertWithWhereUniqueWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    update: XOR<TransactionItemUpdateWithoutProductInput, TransactionItemUncheckedUpdateWithoutProductInput>
    create: XOR<TransactionItemCreateWithoutProductInput, TransactionItemUncheckedCreateWithoutProductInput>
  }

  export type TransactionItemUpdateWithWhereUniqueWithoutProductInput = {
    where: TransactionItemWhereUniqueInput
    data: XOR<TransactionItemUpdateWithoutProductInput, TransactionItemUncheckedUpdateWithoutProductInput>
  }

  export type TransactionItemUpdateManyWithWhereWithoutProductInput = {
    where: TransactionItemScalarWhereInput
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyWithoutProductInput>
  }

  export type TransactionItemScalarWhereInput = {
    AND?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
    OR?: TransactionItemScalarWhereInput[]
    NOT?: TransactionItemScalarWhereInput | TransactionItemScalarWhereInput[]
    id?: IntFilter<"TransactionItem"> | number
    transactionId?: IntFilter<"TransactionItem"> | number
    productId?: IntFilter<"TransactionItem"> | number
    quantity?: IntFilter<"TransactionItem"> | number
    totalPrice?: FloatFilter<"TransactionItem"> | number
  }

  export type OrganisationCreateWithoutSellersInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutSellersInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutSellersInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutSellersInput, OrganisationUncheckedCreateWithoutSellersInput>
  }

  export type OrganisationUpsertWithoutSellersInput = {
    update: XOR<OrganisationUpdateWithoutSellersInput, OrganisationUncheckedUpdateWithoutSellersInput>
    create: XOR<OrganisationCreateWithoutSellersInput, OrganisationUncheckedCreateWithoutSellersInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutSellersInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutSellersInput, OrganisationUncheckedUpdateWithoutSellersInput>
  }

  export type OrganisationUpdateWithoutSellersInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutSellersInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateWithoutTransactionsInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutTransactionsInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutTransactionsInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutTransactionsInput, OrganisationUncheckedCreateWithoutTransactionsInput>
  }

  export type CustomerCreateWithoutTransactionsInput = {
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    organisation: OrganisationCreateNestedOneWithoutCustomersInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
    organisationId: number
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionItemCreateWithoutTransactionInput = {
    quantity: number
    totalPrice: number
    product: ProductCreateNestedOneWithoutTransactionItemsInput
  }

  export type TransactionItemUncheckedCreateWithoutTransactionInput = {
    id?: number
    productId: number
    quantity: number
    totalPrice: number
  }

  export type TransactionItemCreateOrConnectWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    create: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionItemCreateManyTransactionInputEnvelope = {
    data: TransactionItemCreateManyTransactionInput | TransactionItemCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionShippingCreateWithoutTransactionInput = {
    methodName: string
    methodType: $Enums.ShippingMethodType
    baseRate?: number | null
    weightCharge?: number | null
    totalWeight?: number | null
    totalCost: number
  }

  export type TransactionShippingUncheckedCreateWithoutTransactionInput = {
    id?: number
    methodName: string
    methodType: $Enums.ShippingMethodType
    baseRate?: number | null
    weightCharge?: number | null
    totalWeight?: number | null
    totalCost: number
  }

  export type TransactionShippingCreateOrConnectWithoutTransactionInput = {
    where: TransactionShippingWhereUniqueInput
    create: XOR<TransactionShippingCreateWithoutTransactionInput, TransactionShippingUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionShippingCreateManyTransactionInputEnvelope = {
    data: TransactionShippingCreateManyTransactionInput | TransactionShippingCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutTransactionsInput = {
    update: XOR<OrganisationUpdateWithoutTransactionsInput, OrganisationUncheckedUpdateWithoutTransactionsInput>
    create: XOR<OrganisationCreateWithoutTransactionsInput, OrganisationUncheckedCreateWithoutTransactionsInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutTransactionsInput, OrganisationUncheckedUpdateWithoutTransactionsInput>
  }

  export type OrganisationUpdateWithoutTransactionsInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: OrganisationUpdateOneRequiredWithoutCustomersNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type TransactionItemUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    update: XOR<TransactionItemUpdateWithoutTransactionInput, TransactionItemUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionItemCreateWithoutTransactionInput, TransactionItemUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionItemUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionItemWhereUniqueInput
    data: XOR<TransactionItemUpdateWithoutTransactionInput, TransactionItemUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionItemUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionItemScalarWhereInput
    data: XOR<TransactionItemUpdateManyMutationInput, TransactionItemUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionShippingUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionShippingWhereUniqueInput
    update: XOR<TransactionShippingUpdateWithoutTransactionInput, TransactionShippingUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionShippingCreateWithoutTransactionInput, TransactionShippingUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionShippingUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionShippingWhereUniqueInput
    data: XOR<TransactionShippingUpdateWithoutTransactionInput, TransactionShippingUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionShippingUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionShippingScalarWhereInput
    data: XOR<TransactionShippingUpdateManyMutationInput, TransactionShippingUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionShippingScalarWhereInput = {
    AND?: TransactionShippingScalarWhereInput | TransactionShippingScalarWhereInput[]
    OR?: TransactionShippingScalarWhereInput[]
    NOT?: TransactionShippingScalarWhereInput | TransactionShippingScalarWhereInput[]
    id?: IntFilter<"TransactionShipping"> | number
    transactionId?: IntFilter<"TransactionShipping"> | number
    methodName?: StringFilter<"TransactionShipping"> | string
    methodType?: EnumShippingMethodTypeFilter<"TransactionShipping"> | $Enums.ShippingMethodType
    baseRate?: FloatNullableFilter<"TransactionShipping"> | number | null
    weightCharge?: FloatNullableFilter<"TransactionShipping"> | number | null
    totalWeight?: FloatNullableFilter<"TransactionShipping"> | number | null
    totalCost?: FloatFilter<"TransactionShipping"> | number
  }

  export type TransactionRecordCreateWithoutItemsInput = {
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    organisation: OrganisationCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    TransactionShipping?: TransactionShippingCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordUncheckedCreateWithoutItemsInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    organisationId: number
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    customerId?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    TransactionShipping?: TransactionShippingUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordCreateOrConnectWithoutItemsInput = {
    where: TransactionRecordWhereUniqueInput
    create: XOR<TransactionRecordCreateWithoutItemsInput, TransactionRecordUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutTransactionItemsInput = {
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisation: OrganisationCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    inventory?: InventoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransactionItemsInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisationId: number
    categoryId?: number | null
    inventory?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransactionItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
  }

  export type TransactionRecordUpsertWithoutItemsInput = {
    update: XOR<TransactionRecordUpdateWithoutItemsInput, TransactionRecordUncheckedUpdateWithoutItemsInput>
    create: XOR<TransactionRecordCreateWithoutItemsInput, TransactionRecordUncheckedCreateWithoutItemsInput>
    where?: TransactionRecordWhereInput
  }

  export type TransactionRecordUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransactionRecordWhereInput
    data: XOR<TransactionRecordUpdateWithoutItemsInput, TransactionRecordUncheckedUpdateWithoutItemsInput>
  }

  export type TransactionRecordUpdateWithoutItemsInput = {
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    organisation?: OrganisationUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    TransactionShipping?: TransactionShippingUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    TransactionShipping?: TransactionShippingUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type ProductUpsertWithoutTransactionItemsInput = {
    update: XOR<ProductUpdateWithoutTransactionItemsInput, ProductUncheckedUpdateWithoutTransactionItemsInput>
    create: XOR<ProductCreateWithoutTransactionItemsInput, ProductUncheckedCreateWithoutTransactionItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransactionItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransactionItemsInput, ProductUncheckedUpdateWithoutTransactionItemsInput>
  }

  export type ProductUpdateWithoutTransactionItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransactionItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrganisationCreateWithoutCustomersInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutCustomersInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutCustomersInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutCustomersInput, OrganisationUncheckedCreateWithoutCustomersInput>
  }

  export type TransactionRecordCreateWithoutCustomerInput = {
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    organisation: OrganisationCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
    TransactionShipping?: TransactionShippingCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordUncheckedCreateWithoutCustomerInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    organisationId: number
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
    TransactionShipping?: TransactionShippingUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordCreateOrConnectWithoutCustomerInput = {
    where: TransactionRecordWhereUniqueInput
    create: XOR<TransactionRecordCreateWithoutCustomerInput, TransactionRecordUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionRecordCreateManyCustomerInputEnvelope = {
    data: TransactionRecordCreateManyCustomerInput | TransactionRecordCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerSubmissionCreateWithoutCustomersInput = {
    token: string
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organisation: OrganisationCreateNestedOneWithoutCustomerSubmissionInput
  }

  export type CustomerSubmissionUncheckedCreateWithoutCustomersInput = {
    id?: number
    token: string
    organisationId: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSubmissionCreateOrConnectWithoutCustomersInput = {
    where: CustomerSubmissionWhereUniqueInput
    create: XOR<CustomerSubmissionCreateWithoutCustomersInput, CustomerSubmissionUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerSubmissionCreateManyCustomersInputEnvelope = {
    data: CustomerSubmissionCreateManyCustomersInput | CustomerSubmissionCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutCustomersInput = {
    update: XOR<OrganisationUpdateWithoutCustomersInput, OrganisationUncheckedUpdateWithoutCustomersInput>
    create: XOR<OrganisationCreateWithoutCustomersInput, OrganisationUncheckedCreateWithoutCustomersInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutCustomersInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutCustomersInput, OrganisationUncheckedUpdateWithoutCustomersInput>
  }

  export type OrganisationUpdateWithoutCustomersInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type TransactionRecordUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionRecordWhereUniqueInput
    update: XOR<TransactionRecordUpdateWithoutCustomerInput, TransactionRecordUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionRecordCreateWithoutCustomerInput, TransactionRecordUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionRecordUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionRecordWhereUniqueInput
    data: XOR<TransactionRecordUpdateWithoutCustomerInput, TransactionRecordUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionRecordUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionRecordScalarWhereInput
    data: XOR<TransactionRecordUpdateManyMutationInput, TransactionRecordUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerSubmissionUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CustomerSubmissionWhereUniqueInput
    update: XOR<CustomerSubmissionUpdateWithoutCustomersInput, CustomerSubmissionUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerSubmissionCreateWithoutCustomersInput, CustomerSubmissionUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerSubmissionUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CustomerSubmissionWhereUniqueInput
    data: XOR<CustomerSubmissionUpdateWithoutCustomersInput, CustomerSubmissionUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerSubmissionUpdateManyWithWhereWithoutCustomersInput = {
    where: CustomerSubmissionScalarWhereInput
    data: XOR<CustomerSubmissionUpdateManyMutationInput, CustomerSubmissionUncheckedUpdateManyWithoutCustomersInput>
  }

  export type ProductCreateWithoutInventoryInput = {
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisation: OrganisationCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    transactionItems?: TransactionItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisationId: number
    categoryId?: number | null
    transactionItems?: TransactionItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
  }

  export type ProductCategoryCreateWithoutInventoryInput = {
    name: string
    organisation: OrganisationCreateNestedOneWithoutProductCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutInventoryInput = {
    id?: number
    name: string
    organisationId: number
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutInventoryInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutInventoryInput, ProductCategoryUncheckedCreateWithoutInventoryInput>
  }

  export type OrganisationCreateWithoutInventoryInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutInventoryInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutInventoryInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutInventoryInput, OrganisationUncheckedCreateWithoutInventoryInput>
  }

  export type ProductUpsertWithoutInventoryInput = {
    update: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProductCreateWithoutInventoryInput, ProductUncheckedCreateWithoutInventoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryInput, ProductUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    transactionItems?: TransactionItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    transactionItems?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCategoryUpsertWithoutInventoryInput = {
    update: XOR<ProductCategoryUpdateWithoutInventoryInput, ProductCategoryUncheckedUpdateWithoutInventoryInput>
    create: XOR<ProductCategoryCreateWithoutInventoryInput, ProductCategoryUncheckedCreateWithoutInventoryInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutInventoryInput, ProductCategoryUncheckedUpdateWithoutInventoryInput>
  }

  export type ProductCategoryUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutProductCategoriesNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type OrganisationUpsertWithoutInventoryInput = {
    update: XOR<OrganisationUpdateWithoutInventoryInput, OrganisationUncheckedUpdateWithoutInventoryInput>
    create: XOR<OrganisationCreateWithoutInventoryInput, OrganisationUncheckedCreateWithoutInventoryInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutInventoryInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutInventoryInput, OrganisationUncheckedUpdateWithoutInventoryInput>
  }

  export type OrganisationUpdateWithoutInventoryInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateWithoutShippingMethodInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutShippingMethodInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutShippingMethodInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutShippingMethodInput, OrganisationUncheckedCreateWithoutShippingMethodInput>
  }

  export type OrganisationUpsertWithoutShippingMethodInput = {
    update: XOR<OrganisationUpdateWithoutShippingMethodInput, OrganisationUncheckedUpdateWithoutShippingMethodInput>
    create: XOR<OrganisationCreateWithoutShippingMethodInput, OrganisationUncheckedCreateWithoutShippingMethodInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutShippingMethodInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutShippingMethodInput, OrganisationUncheckedUpdateWithoutShippingMethodInput>
  }

  export type OrganisationUpdateWithoutShippingMethodInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutShippingMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type TransactionRecordCreateWithoutTransactionShippingInput = {
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    organisation: OrganisationCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    items?: TransactionItemCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordUncheckedCreateWithoutTransactionShippingInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    organisationId: number
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    customerId?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
    items?: TransactionItemUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionRecordCreateOrConnectWithoutTransactionShippingInput = {
    where: TransactionRecordWhereUniqueInput
    create: XOR<TransactionRecordCreateWithoutTransactionShippingInput, TransactionRecordUncheckedCreateWithoutTransactionShippingInput>
  }

  export type TransactionRecordUpsertWithoutTransactionShippingInput = {
    update: XOR<TransactionRecordUpdateWithoutTransactionShippingInput, TransactionRecordUncheckedUpdateWithoutTransactionShippingInput>
    create: XOR<TransactionRecordCreateWithoutTransactionShippingInput, TransactionRecordUncheckedCreateWithoutTransactionShippingInput>
    where?: TransactionRecordWhereInput
  }

  export type TransactionRecordUpdateToOneWithWhereWithoutTransactionShippingInput = {
    where?: TransactionRecordWhereInput
    data: XOR<TransactionRecordUpdateWithoutTransactionShippingInput, TransactionRecordUncheckedUpdateWithoutTransactionShippingInput>
  }

  export type TransactionRecordUpdateWithoutTransactionShippingInput = {
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    organisation?: OrganisationUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordUncheckedUpdateWithoutTransactionShippingInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type OrganisationCreateWithoutMandateInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutMandateInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutMandateInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutMandateInput, OrganisationUncheckedCreateWithoutMandateInput>
  }

  export type OrganisationUpsertWithoutMandateInput = {
    update: XOR<OrganisationUpdateWithoutMandateInput, OrganisationUncheckedUpdateWithoutMandateInput>
    create: XOR<OrganisationCreateWithoutMandateInput, OrganisationUncheckedCreateWithoutMandateInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutMandateInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutMandateInput, OrganisationUncheckedUpdateWithoutMandateInput>
  }

  export type OrganisationUpdateWithoutMandateInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutMandateInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateWithoutActiveMandatesInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    MandateNotification?: MandateNotificationCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutActiveMandatesInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    MandateNotification?: MandateNotificationUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutActiveMandatesInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutActiveMandatesInput, OrganisationUncheckedCreateWithoutActiveMandatesInput>
  }

  export type OrganisationUpsertWithoutActiveMandatesInput = {
    update: XOR<OrganisationUpdateWithoutActiveMandatesInput, OrganisationUncheckedUpdateWithoutActiveMandatesInput>
    create: XOR<OrganisationCreateWithoutActiveMandatesInput, OrganisationUncheckedCreateWithoutActiveMandatesInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutActiveMandatesInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutActiveMandatesInput, OrganisationUncheckedUpdateWithoutActiveMandatesInput>
  }

  export type OrganisationUpdateWithoutActiveMandatesInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutActiveMandatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    MandateNotification?: MandateNotificationUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateWithoutMandateNotificationInput = {
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryCreateNestedManyWithoutOrganisationInput
    products?: ProductCreateNestedManyWithoutOrganisationInput
    sellers?: SellerCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordCreateNestedManyWithoutOrganisationInput
    customers?: CustomerCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateCreateNestedOneWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutMandateNotificationInput = {
    id?: number
    password: string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    email: string
    phone: string
    name: string
    companySize: string
    shopName: string
    flatNo: string
    street: string
    district: string
    city?: string | null
    state: string
    smsCount?: number
    smsCost?: number
    country: string
    pincode: string
    mobileNumber: string
    landlineNumber?: string | null
    websiteAddress?: string | null
    gstNumber?: string | null
    subscriptionType: string
    endDate: Date | string
    whatsappNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    razorpayAccessToken?: string | null
    razorpayRefreshToken?: string | null
    razorpayTokenExpiresAt?: Date | string | null
    razorpayAccountId?: string | null
    razorpayState?: string | null
    razorpayStateExpiresAt?: Date | string | null
    monthlyUsage?: number
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutOrganisationInput
    products?: ProductUncheckedCreateNestedManyWithoutOrganisationInput
    sellers?: SellerUncheckedCreateNestedManyWithoutOrganisationInput
    transactions?: TransactionRecordUncheckedCreateNestedManyWithoutOrganisationInput
    customers?: CustomerUncheckedCreateNestedManyWithoutOrganisationInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutOrganisationInput
    CustomerSubmission?: CustomerSubmissionUncheckedCreateNestedManyWithoutOrganisationInput
    ShippingMethod?: ShippingMethodUncheckedCreateNestedManyWithoutOrganisationInput
    Mandate?: MandateUncheckedCreateNestedManyWithoutOrganisationInput
    activeMandates?: ActiveMandateUncheckedCreateNestedOneWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutMandateNotificationInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutMandateNotificationInput, OrganisationUncheckedCreateWithoutMandateNotificationInput>
  }

  export type OrganisationUpsertWithoutMandateNotificationInput = {
    update: XOR<OrganisationUpdateWithoutMandateNotificationInput, OrganisationUncheckedUpdateWithoutMandateNotificationInput>
    create: XOR<OrganisationCreateWithoutMandateNotificationInput, OrganisationUncheckedCreateWithoutMandateNotificationInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutMandateNotificationInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutMandateNotificationInput, OrganisationUncheckedUpdateWithoutMandateNotificationInput>
  }

  export type OrganisationUpdateWithoutMandateNotificationInput = {
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUpdateManyWithoutOrganisationNestedInput
    products?: ProductUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUpdateOneWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutMandateNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    companySize?: StringFieldUpdateOperationsInput | string
    shopName?: StringFieldUpdateOperationsInput | string
    flatNo?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    smsCount?: IntFieldUpdateOperationsInput | number
    smsCost?: FloatFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    pincode?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    landlineNumber?: NullableStringFieldUpdateOperationsInput | string | null
    websiteAddress?: NullableStringFieldUpdateOperationsInput | string | null
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    razorpayAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    razorpayAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayState?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayStateExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyUsage?: IntFieldUpdateOperationsInput | number
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutOrganisationNestedInput
    products?: ProductUncheckedUpdateManyWithoutOrganisationNestedInput
    sellers?: SellerUncheckedUpdateManyWithoutOrganisationNestedInput
    transactions?: TransactionRecordUncheckedUpdateManyWithoutOrganisationNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutOrganisationNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutOrganisationNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutOrganisationNestedInput
    ShippingMethod?: ShippingMethodUncheckedUpdateManyWithoutOrganisationNestedInput
    Mandate?: MandateUncheckedUpdateManyWithoutOrganisationNestedInput
    activeMandates?: ActiveMandateUncheckedUpdateOneWithoutOrganisationNestedInput
  }

  export type ProductCategoryCreateManyOrganisationInput = {
    id?: number
    name: string
  }

  export type ProductCreateManyOrganisationInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    categoryId?: number | null
  }

  export type SellerCreateManyOrganisationInput = {
    id?: number
    name: string
    contact: string
    type: string
  }

  export type TransactionRecordCreateManyOrganisationInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    customerId?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
  }

  export type CustomerCreateManyOrganisationInput = {
    id?: number
    name: string
    phone: string
    district?: string | null
    state?: string | null
    pincode?: string | null
    email?: string | null
    flatNo?: string | null
    street?: string | null
  }

  export type InventoryCreateManyOrganisationInput = {
    id?: number
    productId: number
    categoryId?: number | null
    quantity: number
  }

  export type CustomerSubmissionCreateManyOrganisationInput = {
    id?: number
    token: string
    customerId?: number | null
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShippingMethodCreateManyOrganisationInput = {
    id?: number
    name: string
    type: $Enums.ShippingMethodType
    minAmount?: number | null
    useWeight?: boolean
    ratePerKg?: number | null
    fixedRate?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MandateCreateManyOrganisationInput = {
    id?: number
    merchantTranId: string
    bankRRN?: string | null
    UMN?: string | null
    amount: number
    status: string
    payerVA: string
    payerName?: string | null
    payerMobile?: string | null
    txnInitDate?: Date | string | null
    txnCompletionDate?: Date | string | null
    responseCode?: string | null
    respCodeDescription?: string | null
  }

  export type MandateNotificationCreateManyOrganisationInput = {
    id?: number
    type: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ProductCategoryUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    inventory?: InventoryUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    transactionItems?: TransactionItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    transactionItems?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SellerUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SellerUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SellerUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionRecordUpdateWithoutOrganisationInput = {
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    TransactionShipping?: TransactionShippingUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    TransactionShipping?: TransactionShippingUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionRecordUpdateManyWithoutCustomerNestedInput
    CustomerSubmission?: CustomerSubmissionUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionRecordUncheckedUpdateManyWithoutCustomerNestedInput
    CustomerSubmission?: CustomerSubmissionUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    district?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUpdateWithoutOrganisationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    category?: ProductCategoryUpdateOneWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerSubmissionUpdateWithoutOrganisationInput = {
    token?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneWithoutCustomerSubmissionNestedInput
  }

  export type CustomerSubmissionUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubmissionUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    useWeight?: BoolFieldUpdateOperationsInput | boolean
    ratePerKg?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    useWeight?: BoolFieldUpdateOperationsInput | boolean
    ratePerKg?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShippingMethodUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    useWeight?: BoolFieldUpdateOperationsInput | boolean
    ratePerKg?: NullableFloatFieldUpdateOperationsInput | number | null
    fixedRate?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandateUpdateWithoutOrganisationInput = {
    merchantTranId?: StringFieldUpdateOperationsInput | string
    bankRRN?: NullableStringFieldUpdateOperationsInput | string | null
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    txnInitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txnCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    respCodeDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MandateUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantTranId?: StringFieldUpdateOperationsInput | string
    bankRRN?: NullableStringFieldUpdateOperationsInput | string | null
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    txnInitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txnCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    respCodeDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MandateUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    merchantTranId?: StringFieldUpdateOperationsInput | string
    bankRRN?: NullableStringFieldUpdateOperationsInput | string | null
    UMN?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payerVA?: StringFieldUpdateOperationsInput | string
    payerName?: NullableStringFieldUpdateOperationsInput | string | null
    payerMobile?: NullableStringFieldUpdateOperationsInput | string | null
    txnInitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txnCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responseCode?: NullableStringFieldUpdateOperationsInput | string | null
    respCodeDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MandateNotificationUpdateWithoutOrganisationInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandateNotificationUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MandateNotificationUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    name: string
    SKU: string
    netPrice: number
    sellingPrice: number
    quantity: number
    seller: string
    organisationId: number
  }

  export type InventoryCreateManyCategoryInput = {
    id?: number
    productId: number
    organisationId: number
    quantity: number
  }

  export type ProductUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisation?: OrganisationUpdateOneRequiredWithoutProductsNestedInput
    inventory?: InventoryUpdateManyWithoutProductNestedInput
    transactionItems?: TransactionItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    inventory?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    transactionItems?: TransactionItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    SKU?: StringFieldUpdateOperationsInput | string
    netPrice?: FloatFieldUpdateOperationsInput | number
    sellingPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    seller?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryUpdateWithoutCategoryInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutInventoryNestedInput
    organisation?: OrganisationUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryCreateManyProductInput = {
    id?: number
    categoryId?: number | null
    organisationId: number
    quantity: number
  }

  export type TransactionItemCreateManyProductInput = {
    id?: number
    transactionId: number
    quantity: number
    totalPrice: number
  }

  export type InventoryUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    category?: ProductCategoryUpdateOneWithoutInventoryNestedInput
    organisation?: OrganisationUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type InventoryUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    transaction?: TransactionRecordUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransactionItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    transactionId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionItemCreateManyTransactionInput = {
    id?: number
    productId: number
    quantity: number
    totalPrice: number
  }

  export type TransactionShippingCreateManyTransactionInput = {
    id?: number
    methodName: string
    methodType: $Enums.ShippingMethodType
    baseRate?: number | null
    weightCharge?: number | null
    totalWeight?: number | null
    totalCost: number
  }

  export type TransactionItemUpdateWithoutTransactionInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutTransactionItemsNestedInput
  }

  export type TransactionItemUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionItemUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionShippingUpdateWithoutTransactionInput = {
    methodName?: StringFieldUpdateOperationsInput | string
    methodType?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    weightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionShippingUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    methodType?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    weightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionShippingUncheckedUpdateManyWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodName?: StringFieldUpdateOperationsInput | string
    methodType?: EnumShippingMethodTypeFieldUpdateOperationsInput | $Enums.ShippingMethodType
    baseRate?: NullableFloatFieldUpdateOperationsInput | number | null
    weightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCost?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionRecordCreateManyCustomerInput = {
    id?: number
    billNo: number
    totalPrice: number
    paymentMethod: string
    amountPaid?: number
    balance?: number
    billingMode: string
    organisationId: number
    date: Date | string
    time: Date | string
    trackingNumber?: string | null
    weight?: number | null
    status?: string
    notes?: string | null
    paymentId?: string | null
    paymentStatus?: $Enums.PaymentStatus
    isEdited?: boolean
  }

  export type CustomerSubmissionCreateManyCustomersInput = {
    id?: number
    token: string
    organisationId: number
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionRecordUpdateWithoutCustomerInput = {
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    organisation?: OrganisationUpdateOneRequiredWithoutTransactionsNestedInput
    items?: TransactionItemUpdateManyWithoutTransactionNestedInput
    TransactionShipping?: TransactionShippingUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    items?: TransactionItemUncheckedUpdateManyWithoutTransactionNestedInput
    TransactionShipping?: TransactionShippingUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionRecordUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    billNo?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amountPaid?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    billingMode?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    isEdited?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerSubmissionUpdateWithoutCustomersInput = {
    token?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisation?: OrganisationUpdateOneRequiredWithoutCustomerSubmissionNestedInput
  }

  export type CustomerSubmissionUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSubmissionUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    organisationId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}